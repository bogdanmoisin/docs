{
    "docs": [
        {
            "location": "/", 
            "text": "Elcodi Documentation\n #\n\n\nThis documentation is rendered online at \n\nhttp://elcodi.io/docs\n\n\n\n\nQuick Start\n\n\nThe Book\n\n\nThe Components\n\n\nThe Cookbook", 
            "title": "Home"
        }, 
        {
            "location": "/#elcodi-documentation", 
            "text": "This documentation is rendered online at  http://elcodi.io/docs   Quick Start  The Book  The Components  The Cookbook", 
            "title": "Elcodi Documentation"
        }, 
        {
            "location": "/quick-start/", 
            "text": "Bamboo e-commerce\n #\n\n\nWelcome to Bamboo e-commerce - a fully-functional e-commerce application built\nusing \nElcodi\n components on top of the \nSymfony\n framework.\n\n\nYes, you got it right! Bamboo uses the Symfony framework but our components are\nframework agnostic, that is, they only depend on the Symfony components as \nopposed to the whole framework or any of its distributions.\n\n\nWhy should I use Bamboo? That's simple, to sell your products. We provide you \nwith an interface to sell your products and manage your store. You only have to \nfocus on offering a good product, we take care of the rest.\n\n\nRequirements\n #\n\n\nWe're trying to build this project with a light default dependencies. These are\nours.\n\n\n\n\nThe following dependencies are required for local installation, if you want we\nalso provide a provisioning system to run bamboo on a virtual machine using \nVagrant. Read more about the\n\nVagrant quickstart\n.\n\n\n\n\nPHP\n #\n\n\nTo use Bamboo and Elcodi you need a PHP version not lower than \n5.4\n. For more \ninfo just visit their \ninstallation page\n\n\nPHP GD\n #\n\n\n\n\nThis PHP extension is used to being already installed when you add PHP in your\ndistribution\n\n\n\n\nImages are a really important part of an store. Bamboo uses PHP GD to\nresize and optimize all product images. For more info just visit their\n\ninstallation page\n\n\nAfter that, you will be able to change the adapter and use other \nimplementations.\n\n\nMySQL\n #\n\n\nAnd, where do you save your data? By default we use MySQL, remember to install\nit as well as its extension for PHP. For more info just visit their\n\ninstallation page\n\n\nComposer\n #\n\n\nComposer\n is required to manage dependencies.\n\n\nif you have not yet installed Composer, download it following the instructions\non \nhttp://getcomposer.org/\n or just run the following\ncommand:\n\n\n$ curl -s http://getcomposer.org/installer | php\n\n\n\n\nInstallation\n #\n\n\nIf you're used to working with LAMP environment, then you will have Bamboo \nrunning in your computer in less than 5 minutes.\n\n\n1. Install the project\n #\n\n\nAfter installing composer you can create your new Bamboo project.\n\n\n$ php composer.phar create-project elcodi/bamboo bamboo -sdev\n\n\n\n\n\n\nThe installation process will ask you for some parameters like the database\ndriver, username, password, database name, etc\n\n\n\n\nEnter your directory to start the configuration step and use our magic command\nto create a complete development environment. Just one single line to rule them\nall\n\n\n$ cd bamboo/\n$ php app/console elcodi:install\n\n\n\n\nBy default only Spain will be installed. We have focused this step to run as \nfast as possible, so then, you'll be able to install more countries. You can add\nsome countries in addition by using the \n--country\n command option.\n\n\n$ php app/console elcodi:install --country=FR --country=IT\n\n\n\n\n2. Run the server\n #\n\n\nOur store is ready to run. Use the built-in server to take a look at the \nproject.\n\n\n$ php app/console server:run\n\n\n\n\n3. Visit your store\n #\n\n\nYou're done! Visit \nhttp://localhost:8000\n in your browser and take a look at\nwhat we have for you :) Use these Customer credentials in the store\n\n\nCustomer username: customer@customer.com\nCustomer password: 1234\n\n\n\n\nAnd for the admin panel, use this Admin credentials.\n\n\nAdmin username: admin@admin.com\nAdmin password: 1234\n\n\n\n\nRemember to remove these users properly as soon as you're in production.\n\n\nMetrics\n #\n\n\nMetrics are not enabled by default. If you want to enable them, then you need to\ninstall Redis. For more info just visit their\n\ninstallation page\n\n\nIn order to use the last Redis features, like the \nHyperLogLog\n commands, be\nsure your Redis version is at least \nv2.8.9\n.\n\n\nCache\n #\n\n\nBy default, Bamboo is installed without any doctrine cache. You can change this\nsettings by changing the file \napp/cache/config/common/cache.yml\n and by\nchanging the value \narray\n for another one.\n\n\nYou can check some documentation about different types of cache in the\n\nDoctrine Cache Bundle\n\nrepository page.\n\n\nThe most used cache type in Bamboo is \nredis\n. Make sure then that you have the\nphp redis extension installed properly.\n\n\nTests\n #\n\n\nWe are doing some tests, and this will be \nin cresciendo\n. You can ensure\nyourself that all the cases we've been working on are actually green. We are\nusing Behat and PHPUnit, so you only need to execute all suites by using this\npiece of code.\n\n\n$ php bin/behat\n$ php bin/phpunit -c app\n$ php app/console visithor:go --format=pretty --env=test\n\n\n\n\nIssues\n #\n\n\nYou can report any issue on \ngithub.com/elcodi/bamboo/issues\n or\n\ngithub.com/elcodi/elcodi/issues\n\n\nNeed help\n #\n\n\nIf you need any help with the installation or understanding elcodi or bamboo you\ncan contact us on \ngitter.im/elcodi/elcodi\n.\nWe will be glad to help you, just ask for help.", 
            "title": "Quick start"
        }, 
        {
            "location": "/quick-start/#bamboo-e-commerce", 
            "text": "Welcome to Bamboo e-commerce - a fully-functional e-commerce application built\nusing  Elcodi  components on top of the  Symfony  framework.  Yes, you got it right! Bamboo uses the Symfony framework but our components are\nframework agnostic, that is, they only depend on the Symfony components as \nopposed to the whole framework or any of its distributions.  Why should I use Bamboo? That's simple, to sell your products. We provide you \nwith an interface to sell your products and manage your store. You only have to \nfocus on offering a good product, we take care of the rest.", 
            "title": "Bamboo e-commerce"
        }, 
        {
            "location": "/quick-start/#requirements", 
            "text": "We're trying to build this project with a light default dependencies. These are\nours.   The following dependencies are required for local installation, if you want we\nalso provide a provisioning system to run bamboo on a virtual machine using \nVagrant. Read more about the Vagrant quickstart .   PHP  #  To use Bamboo and Elcodi you need a PHP version not lower than  5.4 . For more \ninfo just visit their  installation page  PHP GD  #   This PHP extension is used to being already installed when you add PHP in your\ndistribution   Images are a really important part of an store. Bamboo uses PHP GD to\nresize and optimize all product images. For more info just visit their installation page  After that, you will be able to change the adapter and use other \nimplementations.  MySQL  #  And, where do you save your data? By default we use MySQL, remember to install\nit as well as its extension for PHP. For more info just visit their installation page  Composer  #  Composer  is required to manage dependencies.  if you have not yet installed Composer, download it following the instructions\non  http://getcomposer.org/  or just run the following\ncommand:  $ curl -s http://getcomposer.org/installer | php", 
            "title": "Requirements"
        }, 
        {
            "location": "/quick-start/#installation", 
            "text": "If you're used to working with LAMP environment, then you will have Bamboo \nrunning in your computer in less than 5 minutes.  1. Install the project  #  After installing composer you can create your new Bamboo project.  $ php composer.phar create-project elcodi/bamboo bamboo -sdev   The installation process will ask you for some parameters like the database\ndriver, username, password, database name, etc   Enter your directory to start the configuration step and use our magic command\nto create a complete development environment. Just one single line to rule them\nall  $ cd bamboo/\n$ php app/console elcodi:install  By default only Spain will be installed. We have focused this step to run as \nfast as possible, so then, you'll be able to install more countries. You can add\nsome countries in addition by using the  --country  command option.  $ php app/console elcodi:install --country=FR --country=IT  2. Run the server  #  Our store is ready to run. Use the built-in server to take a look at the \nproject.  $ php app/console server:run  3. Visit your store  #  You're done! Visit  http://localhost:8000  in your browser and take a look at\nwhat we have for you :) Use these Customer credentials in the store  Customer username: customer@customer.com\nCustomer password: 1234  And for the admin panel, use this Admin credentials.  Admin username: admin@admin.com\nAdmin password: 1234  Remember to remove these users properly as soon as you're in production.", 
            "title": "Installation"
        }, 
        {
            "location": "/quick-start/#metrics", 
            "text": "Metrics are not enabled by default. If you want to enable them, then you need to\ninstall Redis. For more info just visit their installation page  In order to use the last Redis features, like the  HyperLogLog  commands, be\nsure your Redis version is at least  v2.8.9 .", 
            "title": "Metrics"
        }, 
        {
            "location": "/quick-start/#cache", 
            "text": "By default, Bamboo is installed without any doctrine cache. You can change this\nsettings by changing the file  app/cache/config/common/cache.yml  and by\nchanging the value  array  for another one.  You can check some documentation about different types of cache in the Doctrine Cache Bundle \nrepository page.  The most used cache type in Bamboo is  redis . Make sure then that you have the\nphp redis extension installed properly.", 
            "title": "Cache"
        }, 
        {
            "location": "/quick-start/#tests", 
            "text": "We are doing some tests, and this will be  in cresciendo . You can ensure\nyourself that all the cases we've been working on are actually green. We are\nusing Behat and PHPUnit, so you only need to execute all suites by using this\npiece of code.  $ php bin/behat\n$ php bin/phpunit -c app\n$ php app/console visithor:go --format=pretty --env=test", 
            "title": "Tests"
        }, 
        {
            "location": "/quick-start/#issues", 
            "text": "You can report any issue on  github.com/elcodi/bamboo/issues  or github.com/elcodi/elcodi/issues", 
            "title": "Issues"
        }, 
        {
            "location": "/quick-start/#need-help", 
            "text": "If you need any help with the installation or understanding elcodi or bamboo you\ncan contact us on  gitter.im/elcodi/elcodi .\nWe will be glad to help you, just ask for help.", 
            "title": "Need help"
        }, 
        {
            "location": "/book/cart-architecture/", 
            "text": "Cart Architecture\n #\n\n\nThis is one of the most important parts of the whole project. How Elcodi's cart\nworks? How it's been designed? And how can I deal with it?\n\n\nWe will show you how we have designed all the model and why have we decided this\narchitecture. It is important for you to understand the design in order to\ndetect all possible entries and modification points, to make the Cart component as\nmuch customized as you need.\n\n\nIntroduction\n #\n\n\nLet's start by determining what the Cart Component should take care about. Well,\nit's not difficult at all, so we are working in an E-commerce. The component itself\ntakes care about all related to the Cart and the Order. The component provides\nyou a complete service layer for your application, so knowing and understanding\nthis layer will help you a lot in your own implementation.\n\n\nWe will split all the model in two parts, the Cart part and the Order part. Both\nparts are connected but they can (and should) be treated in a very isolated way.\n\n\n\n\nFirst of all, forget about the Purchasable instance. This is just the way we\nwill refer to the concept of Product (please, read the \n\nProduct Architecture\n chapter in order to know more\nabout it. Let's focus on how the Cart and Order are built.\n\n\nCart\n #\n\n\nThe bucket itself. Every customer has it's own cart, and it's life is connected\nto the session and to the customer as well. This means that even if you change\nthe device, and as long as you're logged in, then you will be able to retrieve\nthe cart from the database.\n\n\nSome parts of the cart are not stored in database, like the prices. Because of\nsome products from your cart can be disabled between page views, or because\ntheir prices can be modified as well, every time you request your cart, prices\nare reloaded and saved locally, in your object life. Of course, this means two\nthings:\n\n\n\n\nYour cart loading consumes some resources in each request\n\n\nYou cannot lookup in your database by these values\n\n\n\n\nAnyway, this strategy helps a lot in your stored carts status. This means that\nyou will not store invalid prices.\n\n\nThe Cart model introduces a new object called Cart Line.\n\n\nCart Line\n #\n\n\nEverytime a new purchasable object is added into a Cart, you must save, at\nleast, one extra information about this relation (cart and purchasable): the\nquantity. Because of this, you cannot relate directly both elements. Of course,\nif the purchasable object needs more information about the relation, for example\ncolor, size or any single text, you should save them all as well.\n\n\nFor this, we will work with an extra man-in-the-middle class called CartLine. In\nthis class we'll save the Cart, the purchasable object and all this information.\nCartLine is designed using\n\nObject Composition\n. It means\nthat the life of all CartLine instances are coupled to the life of the Cart\ninstance.\n\n\n\n\nLoading the cart\n #\n\n\nAs we said, the cart is loaded each time, but, who loads it? In fact, and\nbecause of our service layer, you will find that loading cart is as easy as\nusing an event dispatcher called \nelcodi.event_dispatcher.cart\n.\n\n\n$cart = $this\n    -\ncartRepository\n    -\nfind(1);\n\n$this\n    -\ncartEventDispatcher\n    -\ndispatchCartLoadEvents($cart);\n\n\n\n\nLet's check as well how to inject the event listener. In that case we are\ninjecting both the event dispatcher and the cart repository, for cart\nretrieving.\n\n\nservices:\n    my_cart_loader:\n        class: My\\Cart\\Loader\\Class\n        arguments:\n            - @elcodi.repository.cart\n            - @elcodi.event_dispatcher.cart\n\n\n\n\nAfter that call, your cart will be completely loaded, including prices and\nchecks, and invalid cart lines will be safely removed. Of course, and because\nthe project uses a strong event layer, some events will be dispatched during the\nprocess.\n\n\n\n\ncart.preload\n\n\ncart.onload\n\n\ncart.inconsistent\n\n\n\n\nThe question then is... how can I know that a cart has been loaded? Well, easy\nindeed.\n\n\n$cart = $this\n    -\ncartRepository\n    -\nfind(1);\n\n$isLoaded = $cart-\nisLoaded();\n// $isLoaded === false\n\n$this\n    -\ncartEventDispatcher\n    -\ndispatchCartLoadEvents($cart);\n\n$isLoaded = $cart-\nisLoaded();\n// $isLoaded === true\n\n\n\n\nAdding Purchasables\n #\n\n\nThe main action of a cart is to add a new Product, right? Well, as you will see\nin the \nProduct architecture\n chapter, we are not\nworking with products, but with Purchasable instances.\n\n\nEach purchasable must be added into the cart by using the CartManager, a service\nthat is intended for managing Purchasables and Lines in a very intuitive way.\n\n\nLet's see a small example of how to use the service.\n\n\n$cart;\n$purchasable = $this\n    -\nproductFactory()\n    -\ncreate();\n\n$this\n    -\ncartManager\n    -\naddPurchasable(\n        $cart,\n        $purchasable,\n        3\n    );\n\n\n\n\nIn this example we have used the Product factory and the cart manager. Let's see\nthe dependency injection definition of the fictitious service.\n\n\nservices:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product\n            - @elcodi.manager.cart\n\n\n\n\nOf course, and because \nPurchasable\n is not a real class but an interface, we \nmust add any Purchasable implementation. Product and Variant are our \nimplementations, so in this example we use Product.\n\n\nAfter calling method \naddPurchasable\n, your cart will have 3 units of this \nproduct only if they are really available to be purchased. Otherwise, you will\nget some exceptions. The cart is automatically reloaded as well, and\nall prices are rebuilt again.\n\n\nThis method dispatches these events:\n\n\n\n\ncart_line.onadd\n\n\n\n\nRemoving Purchasables\n #\n\n\nYou can remove purchasables as well, by using another method in the service\nCartManager. Let's see an example using the same service and construction\ndefinition than before.\n\n\n$cart;\n$purchasable = $this\n    -\nproductFactory()\n    -\ncreate();\n\n$this\n    -\ncartManager\n    -\nremovePurchasable(\n        $cart,\n        $purchasable,\n        3\n    );\n\n\n\n\nAfter calling the method, your product units will be decreased as many times as\nthe last value of the call defines. If the value is higher or equal than the\nquantity of the purchasable in the cart, then this line is removed from the\ncart.\n\n\nAfter that, the cart is automatically reloaded as well, and all prices are\nrebuilt again.\n\n\nThis method dispatches these events:\n\n\n\n\ncart_line.onadd\n only if the purchasable is removed\nfrom the cart\n\n\n\n\nAdding a coupon\n #\n\n\nYou can add some coupons as well in your cart. Because we think that both\nconcepts are not the same and shouldn't be coupled at all, we decided to\nseparate them in two components.\n\n\nBoth components have their own events, so all logic regarding how to add coupons\ninto the cart is placed in a third component called CartCoupon. To know a little\nbit more about coupons, please read\n\nCoupon Architecture\n chapter.\n\n\nFor adding a new coupon into the cart, you need to use the service\n\nCartCouponManager\n. This service has some interesting methods for the\nmanagement of all coupons in your cart.\n\n\nLet's see an example.\n\n\n$cart;\n$couponCode = 'coupon5%';\n\n$this\n    -\ncartCouponManager\n    -\naddCouponByCode(\n        $cart,\n        $couponCode\n    );\n\n\n\n\nAssuming that your service depends only on the cart coupon manager, then this\nshould be the dependency injection definition.\n\n\nservices:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.manager.cart_coupon\n\n\n\n\nAfter this action, the coupon is inserted into the cart and the values of the\ncart are recomputed. During the association of both elements, some\nproblems can occur, for example, when two incompatible coupons are inserted in\nthe same cart. Then, you have to expect specific exceptions.\n\n\nYou can add a coupon as well with the Coupon instance as well, using the same\nCartCouponManager.\n\n\n$cart;\n$couponCode = 'coupon5%';\n$coupon = $this\n    -\ncouponRepository\n    -\nfindOneByCode('coupon5%');\n\n$this\n    -\ncartCouponManager\n    -\naddCoupon(\n        $cart,\n        $coupon\n    );\n\n\n\n\nThe definition of that example is not the same than the last one, so this one\ndepends on the \nCouponRepository\n service as well.\n\n\nThis method dispatches these events:\n\n\n\n\ncart_coupon.onapply\n\n\n\n\nRemoving a coupon\n #\n\n\nYou can remove a coupon from a cart using the same service than the\nlast example.\n\n\n$cart;\n$couponCode = 'coupon5%';\n\n$this\n    -\ncartCouponManager\n    -\nremoveCouponByCode(\n        $cart,\n        $couponCode\n    );\n\n\n\n\nYou can remove as well the coupon with the Coupon instance.\n\n\n$cart;\n$couponCode = 'coupon5%';\n$coupon = $this\n    -\ncouponRepository\n    -\nfindOneByCode('coupon5%');\n\n$this\n    -\ncartCouponManager\n    -\nremoveCoupon(\n        $cart,\n        $coupon\n    );\n\n\n\n\nAfter these actions, the cart is completely reloaded, like other actions.\n\n\nThis method dispatches these events:\n\n\n\n\ncart_coupon.onremove\n\n\n\n\nGetting Cart coupons\n #\n\n\nGiven a cart, you should be able to get all coupons applied. We'll\nuse the same manager again.\n\n\n$cart;\n\n$cartCoupons = $this\n    -\ncartCouponManager\n    -\ngetCoupons();\n\n\n\n\nCart transformation\n #\n\n\nOnce the cart must be converted to an order, there is a nice transformer for\nthat occasion. Let's see an example of that transformation. In that occasion, we\nassume that \ngetLoadedCart()\n returns an already loaded cart.\n\n\n$cart = $this-\ngetLoadedCart();\n\n$order = $this\n    -\ncartOrderTransformer\n    -\ncreateOrderFromCart($cart);\n\n\n\n\nThis action produces as well some new events.\n\n\n\n\norder.precreated\n\n\norder.oncreated\n\n\norder_line.oncreated\n\n\n\n\nAfter this action, the cart becomes ordered\n\n\n$cart = $this-\ngetLoadedCart();\n\n$order = $this\n    -\ncartOrderTransformer\n    -\ncreateOrderFromCart($cart);\n\n$cartIsOrdered = $cart-\nisOrdered();\n// $cartIsOrdered === true\n\n\n\n\nOrder\n #\n\n\nThe order should always be a plain copy of a cart. Because the\nobject's behaviour should be as immutable as possible, all prices are calculated\nand saved in database.\n\n\n\n\nInside the entity, you will find this information:\n\n\n\n\nCart where the order belongs\n\n\nDimensions of the order (only physical orders)\n\n\nOrderLines, each one as a mirror of each CartLine\n\n\nQuantity of the order, total number of elements\n\n\nPrices from products, coupons, shipping and total.\n\n\nAddresses from delivering and billing\n\n\nOrder States\n\n\n\n\nGetting Order coupons\n #\n\n\nBecause both components are decoupled (cart and coupon), you need some\nmiddleware for the order coupons retrieval. For this reason, the project \nprovides a service called \nOrderCouponManager\n for the management of all order\ncoupons. Let's see a simple example about how we can retrieve all coupons from \nan Order instance.\n\n\n$order;\n\n$orderCoupons = $this\n    -\norderCouponManager\n    -\ngetCoupons($order);\n\n\n\n\nOrder states\n #\n\n\nWhen an order is created, each instance can travel through an amount of\npredefined states.\n\n\nWith the basic implementation, you will find defined state machines for payment\nand shipping. To know more about this, please, read the \nPayments\n\nand the \nShipping\n chapters", 
            "title": "Cart architecture"
        }, 
        {
            "location": "/book/cart-architecture/#cart-architecture", 
            "text": "This is one of the most important parts of the whole project. How Elcodi's cart\nworks? How it's been designed? And how can I deal with it?  We will show you how we have designed all the model and why have we decided this\narchitecture. It is important for you to understand the design in order to\ndetect all possible entries and modification points, to make the Cart component as\nmuch customized as you need.", 
            "title": "Cart Architecture"
        }, 
        {
            "location": "/book/cart-architecture/#introduction", 
            "text": "Let's start by determining what the Cart Component should take care about. Well,\nit's not difficult at all, so we are working in an E-commerce. The component itself\ntakes care about all related to the Cart and the Order. The component provides\nyou a complete service layer for your application, so knowing and understanding\nthis layer will help you a lot in your own implementation.  We will split all the model in two parts, the Cart part and the Order part. Both\nparts are connected but they can (and should) be treated in a very isolated way.   First of all, forget about the Purchasable instance. This is just the way we\nwill refer to the concept of Product (please, read the  Product Architecture  chapter in order to know more\nabout it. Let's focus on how the Cart and Order are built.", 
            "title": "Introduction"
        }, 
        {
            "location": "/book/cart-architecture/#cart", 
            "text": "The bucket itself. Every customer has it's own cart, and it's life is connected\nto the session and to the customer as well. This means that even if you change\nthe device, and as long as you're logged in, then you will be able to retrieve\nthe cart from the database.  Some parts of the cart are not stored in database, like the prices. Because of\nsome products from your cart can be disabled between page views, or because\ntheir prices can be modified as well, every time you request your cart, prices\nare reloaded and saved locally, in your object life. Of course, this means two\nthings:   Your cart loading consumes some resources in each request  You cannot lookup in your database by these values   Anyway, this strategy helps a lot in your stored carts status. This means that\nyou will not store invalid prices.  The Cart model introduces a new object called Cart Line.", 
            "title": "Cart"
        }, 
        {
            "location": "/book/cart-architecture/#cart-line", 
            "text": "Everytime a new purchasable object is added into a Cart, you must save, at\nleast, one extra information about this relation (cart and purchasable): the\nquantity. Because of this, you cannot relate directly both elements. Of course,\nif the purchasable object needs more information about the relation, for example\ncolor, size or any single text, you should save them all as well.  For this, we will work with an extra man-in-the-middle class called CartLine. In\nthis class we'll save the Cart, the purchasable object and all this information.\nCartLine is designed using Object Composition . It means\nthat the life of all CartLine instances are coupled to the life of the Cart\ninstance.", 
            "title": "Cart Line"
        }, 
        {
            "location": "/book/cart-architecture/#loading-the-cart", 
            "text": "As we said, the cart is loaded each time, but, who loads it? In fact, and\nbecause of our service layer, you will find that loading cart is as easy as\nusing an event dispatcher called  elcodi.event_dispatcher.cart .  $cart = $this\n    - cartRepository\n    - find(1);\n\n$this\n    - cartEventDispatcher\n    - dispatchCartLoadEvents($cart);  Let's check as well how to inject the event listener. In that case we are\ninjecting both the event dispatcher and the cart repository, for cart\nretrieving.  services:\n    my_cart_loader:\n        class: My\\Cart\\Loader\\Class\n        arguments:\n            - @elcodi.repository.cart\n            - @elcodi.event_dispatcher.cart  After that call, your cart will be completely loaded, including prices and\nchecks, and invalid cart lines will be safely removed. Of course, and because\nthe project uses a strong event layer, some events will be dispatched during the\nprocess.   cart.preload  cart.onload  cart.inconsistent   The question then is... how can I know that a cart has been loaded? Well, easy\nindeed.  $cart = $this\n    - cartRepository\n    - find(1);\n\n$isLoaded = $cart- isLoaded();\n// $isLoaded === false\n\n$this\n    - cartEventDispatcher\n    - dispatchCartLoadEvents($cart);\n\n$isLoaded = $cart- isLoaded();\n// $isLoaded === true", 
            "title": "Loading the cart"
        }, 
        {
            "location": "/book/cart-architecture/#adding-purchasables", 
            "text": "The main action of a cart is to add a new Product, right? Well, as you will see\nin the  Product architecture  chapter, we are not\nworking with products, but with Purchasable instances.  Each purchasable must be added into the cart by using the CartManager, a service\nthat is intended for managing Purchasables and Lines in a very intuitive way.  Let's see a small example of how to use the service.  $cart;\n$purchasable = $this\n    - productFactory()\n    - create();\n\n$this\n    - cartManager\n    - addPurchasable(\n        $cart,\n        $purchasable,\n        3\n    );  In this example we have used the Product factory and the cart manager. Let's see\nthe dependency injection definition of the fictitious service.  services:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product\n            - @elcodi.manager.cart  Of course, and because  Purchasable  is not a real class but an interface, we \nmust add any Purchasable implementation. Product and Variant are our \nimplementations, so in this example we use Product.  After calling method  addPurchasable , your cart will have 3 units of this \nproduct only if they are really available to be purchased. Otherwise, you will\nget some exceptions. The cart is automatically reloaded as well, and\nall prices are rebuilt again.  This method dispatches these events:   cart_line.onadd", 
            "title": "Adding Purchasables"
        }, 
        {
            "location": "/book/cart-architecture/#removing-purchasables", 
            "text": "You can remove purchasables as well, by using another method in the service\nCartManager. Let's see an example using the same service and construction\ndefinition than before.  $cart;\n$purchasable = $this\n    - productFactory()\n    - create();\n\n$this\n    - cartManager\n    - removePurchasable(\n        $cart,\n        $purchasable,\n        3\n    );  After calling the method, your product units will be decreased as many times as\nthe last value of the call defines. If the value is higher or equal than the\nquantity of the purchasable in the cart, then this line is removed from the\ncart.  After that, the cart is automatically reloaded as well, and all prices are\nrebuilt again.  This method dispatches these events:   cart_line.onadd  only if the purchasable is removed\nfrom the cart", 
            "title": "Removing Purchasables"
        }, 
        {
            "location": "/book/cart-architecture/#adding-a-coupon", 
            "text": "You can add some coupons as well in your cart. Because we think that both\nconcepts are not the same and shouldn't be coupled at all, we decided to\nseparate them in two components.  Both components have their own events, so all logic regarding how to add coupons\ninto the cart is placed in a third component called CartCoupon. To know a little\nbit more about coupons, please read Coupon Architecture  chapter.  For adding a new coupon into the cart, you need to use the service CartCouponManager . This service has some interesting methods for the\nmanagement of all coupons in your cart.  Let's see an example.  $cart;\n$couponCode = 'coupon5%';\n\n$this\n    - cartCouponManager\n    - addCouponByCode(\n        $cart,\n        $couponCode\n    );  Assuming that your service depends only on the cart coupon manager, then this\nshould be the dependency injection definition.  services:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.manager.cart_coupon  After this action, the coupon is inserted into the cart and the values of the\ncart are recomputed. During the association of both elements, some\nproblems can occur, for example, when two incompatible coupons are inserted in\nthe same cart. Then, you have to expect specific exceptions.  You can add a coupon as well with the Coupon instance as well, using the same\nCartCouponManager.  $cart;\n$couponCode = 'coupon5%';\n$coupon = $this\n    - couponRepository\n    - findOneByCode('coupon5%');\n\n$this\n    - cartCouponManager\n    - addCoupon(\n        $cart,\n        $coupon\n    );  The definition of that example is not the same than the last one, so this one\ndepends on the  CouponRepository  service as well.  This method dispatches these events:   cart_coupon.onapply", 
            "title": "Adding a coupon"
        }, 
        {
            "location": "/book/cart-architecture/#removing-a-coupon", 
            "text": "You can remove a coupon from a cart using the same service than the\nlast example.  $cart;\n$couponCode = 'coupon5%';\n\n$this\n    - cartCouponManager\n    - removeCouponByCode(\n        $cart,\n        $couponCode\n    );  You can remove as well the coupon with the Coupon instance.  $cart;\n$couponCode = 'coupon5%';\n$coupon = $this\n    - couponRepository\n    - findOneByCode('coupon5%');\n\n$this\n    - cartCouponManager\n    - removeCoupon(\n        $cart,\n        $coupon\n    );  After these actions, the cart is completely reloaded, like other actions.  This method dispatches these events:   cart_coupon.onremove", 
            "title": "Removing a coupon"
        }, 
        {
            "location": "/book/cart-architecture/#getting-cart-coupons", 
            "text": "Given a cart, you should be able to get all coupons applied. We'll\nuse the same manager again.  $cart;\n\n$cartCoupons = $this\n    - cartCouponManager\n    - getCoupons();", 
            "title": "Getting Cart coupons"
        }, 
        {
            "location": "/book/cart-architecture/#cart-transformation", 
            "text": "Once the cart must be converted to an order, there is a nice transformer for\nthat occasion. Let's see an example of that transformation. In that occasion, we\nassume that  getLoadedCart()  returns an already loaded cart.  $cart = $this- getLoadedCart();\n\n$order = $this\n    - cartOrderTransformer\n    - createOrderFromCart($cart);  This action produces as well some new events.   order.precreated  order.oncreated  order_line.oncreated   After this action, the cart becomes ordered  $cart = $this- getLoadedCart();\n\n$order = $this\n    - cartOrderTransformer\n    - createOrderFromCart($cart);\n\n$cartIsOrdered = $cart- isOrdered();\n// $cartIsOrdered === true", 
            "title": "Cart transformation"
        }, 
        {
            "location": "/book/cart-architecture/#order", 
            "text": "The order should always be a plain copy of a cart. Because the\nobject's behaviour should be as immutable as possible, all prices are calculated\nand saved in database.   Inside the entity, you will find this information:   Cart where the order belongs  Dimensions of the order (only physical orders)  OrderLines, each one as a mirror of each CartLine  Quantity of the order, total number of elements  Prices from products, coupons, shipping and total.  Addresses from delivering and billing  Order States", 
            "title": "Order"
        }, 
        {
            "location": "/book/cart-architecture/#getting-order-coupons", 
            "text": "Because both components are decoupled (cart and coupon), you need some\nmiddleware for the order coupons retrieval. For this reason, the project \nprovides a service called  OrderCouponManager  for the management of all order\ncoupons. Let's see a simple example about how we can retrieve all coupons from \nan Order instance.  $order;\n\n$orderCoupons = $this\n    - orderCouponManager\n    - getCoupons($order);", 
            "title": "Getting Order coupons"
        }, 
        {
            "location": "/book/cart-architecture/#order-states", 
            "text": "When an order is created, each instance can travel through an amount of\npredefined states.  With the basic implementation, you will find defined state machines for payment\nand shipping. To know more about this, please, read the  Payments \nand the  Shipping  chapters", 
            "title": "Order states"
        }, 
        {
            "location": "/book/category-architecture/", 
            "text": "Category Architecture\n #\n\n\nElcodi brings you a small and simple category structure. Small and simple\ndoesn't mean bad and useless, but with sufficient quality to be useful and \nscalable for any E-commerce.\n\n\n\n\nCategory tree\n #\n\n\nThe main service of the component, and given that you have your categories built\nproperly, is the service Category Tree. This service is only intended to create\na basic structure of categories, ready to be saved in a plain way.\n\n\nImagine all steps in each Request without using this service.\n\n\n\n\nI want all categories\n\n\nI need to get them all from Database using Doctrine\n\n\nI need to sort them\n\n\nI need to filter them\n\n\nI need to organize them using the proper hierarchy\n\n\n\n\nWhile there are no changes in your database, these bunch of actions produce the\nsame result, so why we do it once and again? That's senseless.\n\n\nThis service will do this action only once and will save it in your cache\nsystem in a very reduced and simplified way. Of course the service will not save\nentities in cache but an array.\n\n\nAfter that, each request will only require that structure saved in cache,\nreducing this way the resources spend by the system.\n\n\nFlushing\n #\n\n\nAs soon as your model changes, then you must flush your cache layer. At the\nmoment this happens only when category or product table changes.\n\n\n\n\nOf course, if category changes, then the cached item should be flushed in \norder to be rebuilt again.\n\n\nBecause some categories may not appear because of no products are attached to\nit, if the table products changes then the cached tree should be flushed as\nwell. There is a flag that allow categories to appear even if they don't have\nproducts, so tree will be flushed only when this flag is disabled.\n\n\n\n\nOverwrite the service\n #\n\n\nEach project may add their own login about how categories should be stored.\nThat's a fact indeed. So, overwriting this service is as easier as overwriting\nany other service. Please, follow these cookbooks.\n\n\n\n\nOverwrite a service", 
            "title": "Category architecture"
        }, 
        {
            "location": "/book/category-architecture/#category-architecture", 
            "text": "Elcodi brings you a small and simple category structure. Small and simple\ndoesn't mean bad and useless, but with sufficient quality to be useful and \nscalable for any E-commerce.", 
            "title": "Category Architecture"
        }, 
        {
            "location": "/book/category-architecture/#category-tree", 
            "text": "The main service of the component, and given that you have your categories built\nproperly, is the service Category Tree. This service is only intended to create\na basic structure of categories, ready to be saved in a plain way.  Imagine all steps in each Request without using this service.   I want all categories  I need to get them all from Database using Doctrine  I need to sort them  I need to filter them  I need to organize them using the proper hierarchy   While there are no changes in your database, these bunch of actions produce the\nsame result, so why we do it once and again? That's senseless.  This service will do this action only once and will save it in your cache\nsystem in a very reduced and simplified way. Of course the service will not save\nentities in cache but an array.  After that, each request will only require that structure saved in cache,\nreducing this way the resources spend by the system.", 
            "title": "Category tree"
        }, 
        {
            "location": "/book/category-architecture/#flushing", 
            "text": "As soon as your model changes, then you must flush your cache layer. At the\nmoment this happens only when category or product table changes.   Of course, if category changes, then the cached item should be flushed in \norder to be rebuilt again.  Because some categories may not appear because of no products are attached to\nit, if the table products changes then the cached tree should be flushed as\nwell. There is a flag that allow categories to appear even if they don't have\nproducts, so tree will be flushed only when this flag is disabled.", 
            "title": "Flushing"
        }, 
        {
            "location": "/book/category-architecture/#overwrite-the-service", 
            "text": "Each project may add their own login about how categories should be stored.\nThat's a fact indeed. So, overwriting this service is as easier as overwriting\nany other service. Please, follow these cookbooks.   Overwrite a service", 
            "title": "Overwrite the service"
        }, 
        {
            "location": "/book/commands/", 
            "text": "Commands\n #\n\n\nOne of the ways Elcodi brings interaction between the user and the project is by\nusing the Symfony Console Component. This chapter lists all available commands\nin Bamboo provided by Elcodi components and Bamboo.\n\n\nelcodi:exchangerates:populate\n #\n\n\nThis command populates the currency exchange rates, using desired populator\nadapter.\n\n\nUsage:\n  php app/console elcodi:exchangerates:populate [options]\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Currency\\Command\\CurrencyExchangeRatesPopulateCommand\n\n\nService name: \nelcodi.command.populate_currency_rates\n\n\nExecution time: ~15 seconds\n\n\nHow to add a new Currency Rates Populator adapter\n\n\n\n\nelcodi:install\n #\n\n\nInstalls a fresh and basic bamboo instance by using custom fixtures. Installed\nproject uses fake data in order to recreate how your E-commerce can be if you\nwork with Elcodi.\n\n\nUsage:\n  php app/console elcodi:install [options]\n\nOptions:\n  -c, --country[=COUNTRY]  Countries to be loaded during the installation [default: [\nES\n]] (multiple values allowed)\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Common\\CommonBundle\\Command\\ElcodiInstallCommand\n\n\nService name: \nelcodi.command.elcodi_install\n\n\nExecution time: ~2 minutes\n\n\nQuick start\n\n\n\n\nelcodi:locations:drop\n #\n\n\nDrop a set of desired countries, defined by their country iso code.\n\n\nUsage:\n  php app/console elcodi:locations:drop [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Geo\\Command\\LocationDropCommand\n\n\nService name: \nelcodi.command.location_drop\n\n\nExecution time: It depends on the country size and on the number of countries \n\n\nHow to add a new Location Provider adapter\n\n\n\n\nelcodi:locations:load\n #\n\n\nLoad a full location tree using an external location source. This command avoids\nthe process of building all the tree using Doctrine, and simply loads the\ncountry structure by using directly mysql.\n\n\nUsage:\n  elcodi:locations:load [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Geo\\Command\\LocationLoadCommand\n\n\nService name: \nelcodi.command.location_load\n\n\nExecution time: It depends on the country size and on the number of countries \n\n\nHow to add a new Location Loader adapter\n\n\n\n\nelcodi:locations:populate\n #\n\n\nPopulates from source a full location tree, by using Doctrine and all the Geo\nmodel entity set. This process can be slow, specially the flush stage.\n\n\nUsage:\n  elcodi:locations:populate [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Geo\\Command\\LocationPopulateCommand\n\n\nService name: \nelcodi.command.location_populate\n\n\nExecution time: It depends on the country size and on the number of countries \n\n\nHow to add a new Location Populator adapter\n\n\n\n\nelcodi:metrics:load\n #\n\n\nMetrics are saved to cache in real time. This is mainly because of the process\nthat saves these metrics is asynchronous. These metrics are cached to Redis, and\nbecause Redis can be easily flushed, this command caches \nn\n days of metrics.\n\n\nUsage:\n  elcodi:metrics:load \ndays\n\n\nArguments:\n  days                     Number of days you want to load\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Metric\\Core\\Command\\MetricsLoadCommand\n\n\nService name: \nelcodi.command.metrics_load\n\n\nExecution time: It depends on the number of days loaded.\n\n\nHow to add a new Metric Bucket adapter\n\n\n\n\nelcodi:plugin:disable\n #\n\n\nDisable a plugin by its hash. To check all plugins hash, please check the\ncommand \nelcodi:plugin:list\n.\n\n\nUsage:\n  elcodi:plugin:disable \nhash\n\n  plugin:disable\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Plugin\\Command\\PluginDisableCommand\n\n\nService name: \nelcodi.command.plugin_disable\n\n\nExecution time: Less than 1 second\n\n\nPlugins book chapter\n\n\n\n\nelcodi:plugin:enable\n #\n\n\nEnable a plugin by its hash. To check all plugins hash, please check the command\n\nelcodi:plugin:list\n.\n\n\nUsage:\n  elcodi:plugin:enable \nhash\n\n  plugin:enable\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Plugin\\Command\\PluginEnableCommand\n\n\nService name: \nelcodi.command.plugin_enable\n\n\nExecution time: Less than 1 second\n\n\nPlugins book chapter\n\n\n\n\nelcodi:plugin:list\n #\n\n\nList all installed (both disabled and enabled) plugins with some related\ninformation.\n\n\nUsage:\n  elcodi:plugin:list \nhash\n\n  plugin:list\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Plugin\\Command\\PluginListCommand\n\n\nService name: \nelcodi.command.plugins_list\n\n\nExecution time: Less than 1 second\n\n\nPlugins book chapter\n\n\n\n\nelcodi:plugin:load\n #\n\n\nLoad all plugins to the system. This is the way Bamboo knows the existance of\ninstalled packages with plugins features. Once this command is executed, then\nyou will be able to manage them all in your admin panel\n\n\nUsage:\n  elcodi:plugins:load\n  plugin:load\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default: \ndev\n]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Plugin\\Command\\PluginLoadCommand\n\n\nService name: \nelcodi.command.plugins_load\n\n\nExecution time: Less than 1 second\n\n\nPlugins book chapter\n\n\n\n\nelcodi:sitemap:dump\n #\n\n\nDumps an entire sitemap.\n\n\nUsage:\n  elcodi:sitemap:dump [options] [--] \nbuilder-name\n \nbasepath\n\n\nArguments:\n  builder-name               Builder name\n  basepath                   Base path\n\nOptions:\n      --language[=LANGUAGE]  Language\n  -h, --help                 Display this help message\n  -q, --quiet                Do not output any message\n  -V, --version              Display this application version\n      --ansi                 Force ANSI output\n      --no-ansi              Disable ANSI output\n  -n, --no-interaction       Do not ask any interactive question\n  -s, --shell                Launch the shell.\n      --process-isolation    Launch commands from shell as a separate process.\n  -e, --env=ENV              The Environment name. [default: \ndev\n]\n      --no-debug             Switches off debug mode.\n  -v|vv|vvv, --verbose       Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Sitemap\\Command\\SitemapDumpCommand\n\n\nService name: \nelcodi.command.sitemap_dump\n\n\nExecution time: Less than 1 second\n\n\nSitemap Component\n\n\n\n\nelcodi:sitemap:profile\n #\n\n\nBuilds a sitemap profile\n\n\nUsage:\n  elcodi:sitemap:dump [options] [--] \nbuilder-name\n \nbasepath\n\n\nArguments:\n  builder-name               Builder name\n  basepath                   Base path\n\nOptions:\n      --language[=LANGUAGE]  Language\n  -h, --help                 Display this help message\n  -q, --quiet                Do not output any message\n  -V, --version              Display this application version\n      --ansi                 Force ANSI output\n      --no-ansi              Disable ANSI output\n  -n, --no-interaction       Do not ask any interactive question\n  -s, --shell                Launch the shell.\n      --process-isolation    Launch commands from shell as a separate process.\n  -e, --env=ENV              The Environment name. [default: \ndev\n]\n      --no-debug             Switches off debug mode.\n  -v|vv|vvv, --verbose       Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n\n\n\n\n\n\nNamespace: \nElcodi\\Component\\Sitemap\\Command\\SitemapProfileCommand\n\n\nService name: \nelcodi.command.sitemap_profile\n\n\nExecution time: Less than 1 second\n\n\nSitemap Component", 
            "title": "Commands"
        }, 
        {
            "location": "/book/commands/#commands", 
            "text": "One of the ways Elcodi brings interaction between the user and the project is by\nusing the Symfony Console Component. This chapter lists all available commands\nin Bamboo provided by Elcodi components and Bamboo.", 
            "title": "Commands"
        }, 
        {
            "location": "/book/commands/#elcodiexchangeratespopulate", 
            "text": "This command populates the currency exchange rates, using desired populator\nadapter.  Usage:\n  php app/console elcodi:exchangerates:populate [options]\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Currency\\Command\\CurrencyExchangeRatesPopulateCommand  Service name:  elcodi.command.populate_currency_rates  Execution time: ~15 seconds  How to add a new Currency Rates Populator adapter", 
            "title": "elcodi:exchangerates:populate"
        }, 
        {
            "location": "/book/commands/#elcodiinstall", 
            "text": "Installs a fresh and basic bamboo instance by using custom fixtures. Installed\nproject uses fake data in order to recreate how your E-commerce can be if you\nwork with Elcodi.  Usage:\n  php app/console elcodi:install [options]\n\nOptions:\n  -c, --country[=COUNTRY]  Countries to be loaded during the installation [default: [ ES ]] (multiple values allowed)\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Common\\CommonBundle\\Command\\ElcodiInstallCommand  Service name:  elcodi.command.elcodi_install  Execution time: ~2 minutes  Quick start", 
            "title": "elcodi:install"
        }, 
        {
            "location": "/book/commands/#elcodilocationsdrop", 
            "text": "Drop a set of desired countries, defined by their country iso code.  Usage:\n  php app/console elcodi:locations:drop [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Geo\\Command\\LocationDropCommand  Service name:  elcodi.command.location_drop  Execution time: It depends on the country size and on the number of countries   How to add a new Location Provider adapter", 
            "title": "elcodi:locations:drop"
        }, 
        {
            "location": "/book/commands/#elcodilocationsload", 
            "text": "Load a full location tree using an external location source. This command avoids\nthe process of building all the tree using Doctrine, and simply loads the\ncountry structure by using directly mysql.  Usage:\n  elcodi:locations:load [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Geo\\Command\\LocationLoadCommand  Service name:  elcodi.command.location_load  Execution time: It depends on the country size and on the number of countries   How to add a new Location Loader adapter", 
            "title": "elcodi:locations:load"
        }, 
        {
            "location": "/book/commands/#elcodilocationspopulate", 
            "text": "Populates from source a full location tree, by using Doctrine and all the Geo\nmodel entity set. This process can be slow, specially the flush stage.  Usage:\n  elcodi:locations:populate [options]\n\nOptions:\n  -c, --country=COUNTRY    Countries to be loaded, using Iso format (multiple values allowed)\n      --drop-if-exists     Drop country if this is already loaded\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Geo\\Command\\LocationPopulateCommand  Service name:  elcodi.command.location_populate  Execution time: It depends on the country size and on the number of countries   How to add a new Location Populator adapter", 
            "title": "elcodi:locations:populate"
        }, 
        {
            "location": "/book/commands/#elcodimetricsload", 
            "text": "Metrics are saved to cache in real time. This is mainly because of the process\nthat saves these metrics is asynchronous. These metrics are cached to Redis, and\nbecause Redis can be easily flushed, this command caches  n  days of metrics.  Usage:\n  elcodi:metrics:load  days \n\nArguments:\n  days                     Number of days you want to load\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Metric\\Core\\Command\\MetricsLoadCommand  Service name:  elcodi.command.metrics_load  Execution time: It depends on the number of days loaded.  How to add a new Metric Bucket adapter", 
            "title": "elcodi:metrics:load"
        }, 
        {
            "location": "/book/commands/#elcodiplugindisable", 
            "text": "Disable a plugin by its hash. To check all plugins hash, please check the\ncommand  elcodi:plugin:list .  Usage:\n  elcodi:plugin:disable  hash \n  plugin:disable\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Plugin\\Command\\PluginDisableCommand  Service name:  elcodi.command.plugin_disable  Execution time: Less than 1 second  Plugins book chapter", 
            "title": "elcodi:plugin:disable"
        }, 
        {
            "location": "/book/commands/#elcodipluginenable", 
            "text": "Enable a plugin by its hash. To check all plugins hash, please check the command elcodi:plugin:list .  Usage:\n  elcodi:plugin:enable  hash \n  plugin:enable\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Plugin\\Command\\PluginEnableCommand  Service name:  elcodi.command.plugin_enable  Execution time: Less than 1 second  Plugins book chapter", 
            "title": "elcodi:plugin:enable"
        }, 
        {
            "location": "/book/commands/#elcodipluginlist", 
            "text": "List all installed (both disabled and enabled) plugins with some related\ninformation.  Usage:\n  elcodi:plugin:list  hash \n  plugin:list\n\nArguments:\n  hash                     Plugin hash\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Plugin\\Command\\PluginListCommand  Service name:  elcodi.command.plugins_list  Execution time: Less than 1 second  Plugins book chapter", 
            "title": "elcodi:plugin:list"
        }, 
        {
            "location": "/book/commands/#elcodipluginload", 
            "text": "Load all plugins to the system. This is the way Bamboo knows the existance of\ninstalled packages with plugins features. Once this command is executed, then\nyou will be able to manage them all in your admin panel  Usage:\n  elcodi:plugins:load\n  plugin:load\n\nOptions:\n  -h, --help               Display this help message\n  -q, --quiet              Do not output any message\n  -V, --version            Display this application version\n      --ansi               Force ANSI output\n      --no-ansi            Disable ANSI output\n  -n, --no-interaction     Do not ask any interactive question\n  -s, --shell              Launch the shell.\n      --process-isolation  Launch commands from shell as a separate process.\n  -e, --env=ENV            The Environment name. [default:  dev ]\n      --no-debug           Switches off debug mode.\n  -v|vv|vvv, --verbose     Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Plugin\\Command\\PluginLoadCommand  Service name:  elcodi.command.plugins_load  Execution time: Less than 1 second  Plugins book chapter", 
            "title": "elcodi:plugin:load"
        }, 
        {
            "location": "/book/commands/#elcodisitemapdump", 
            "text": "Dumps an entire sitemap.  Usage:\n  elcodi:sitemap:dump [options] [--]  builder-name   basepath \n\nArguments:\n  builder-name               Builder name\n  basepath                   Base path\n\nOptions:\n      --language[=LANGUAGE]  Language\n  -h, --help                 Display this help message\n  -q, --quiet                Do not output any message\n  -V, --version              Display this application version\n      --ansi                 Force ANSI output\n      --no-ansi              Disable ANSI output\n  -n, --no-interaction       Do not ask any interactive question\n  -s, --shell                Launch the shell.\n      --process-isolation    Launch commands from shell as a separate process.\n  -e, --env=ENV              The Environment name. [default:  dev ]\n      --no-debug             Switches off debug mode.\n  -v|vv|vvv, --verbose       Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Sitemap\\Command\\SitemapDumpCommand  Service name:  elcodi.command.sitemap_dump  Execution time: Less than 1 second  Sitemap Component", 
            "title": "elcodi:sitemap:dump"
        }, 
        {
            "location": "/book/commands/#elcodisitemapprofile", 
            "text": "Builds a sitemap profile  Usage:\n  elcodi:sitemap:dump [options] [--]  builder-name   basepath \n\nArguments:\n  builder-name               Builder name\n  basepath                   Base path\n\nOptions:\n      --language[=LANGUAGE]  Language\n  -h, --help                 Display this help message\n  -q, --quiet                Do not output any message\n  -V, --version              Display this application version\n      --ansi                 Force ANSI output\n      --no-ansi              Disable ANSI output\n  -n, --no-interaction       Do not ask any interactive question\n  -s, --shell                Launch the shell.\n      --process-isolation    Launch commands from shell as a separate process.\n  -e, --env=ENV              The Environment name. [default:  dev ]\n      --no-debug             Switches off debug mode.\n  -v|vv|vvv, --verbose       Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug   Namespace:  Elcodi\\Component\\Sitemap\\Command\\SitemapProfileCommand  Service name:  elcodi.command.sitemap_profile  Execution time: Less than 1 second  Sitemap Component", 
            "title": "elcodi:sitemap:profile"
        }, 
        {
            "location": "/book/coupon-architecture/", 
            "text": "Coupon Architecture\n #\n\n\nOur coupon architecture is intended to work as a simple coupon server. All the\ncoupon model is decoupled from every other package, so you should be able to\nwork with coupons, and only with coupons.\n\n\nIn this chapter we will take a look at the different types of coupons we can\nwork in Elcodi. Of course, this model can evolve and get better.\n\n\nCreate coupon\n #\n\n\nIf you want to create a new coupon instance, you should always use the factory\nobject defined in the dependency injection layer. The service is defined with\nthe name \nelcodi.factory.coupon\n and is available for injection as follows.\n\n\nservices:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.coupon\n\n\n\n\na small snippet of this service could be that one\n\n\n$coupon = $this\n    -\ncouponFactory\n    -\ncreate()\n\n\n\n\nPlease, follow this cookbook if you need more information about elcodi factories.\n\n\n\n\nHow to implement a factory\n\n\n\n\nCoupon types\n #\n\n\n\n\nImportant. This part of the documentation describes how Elcodi manages the\ntypes involving the elcodi's Cart implementation.\n\n\n\n\nThere are several types of application in elcodi Coupons and each of them uses\na certain part of the Coupon entity. The type of the coupon can be defined using\nthe field \n$type\n of Coupon.\n\n\nuse Elcodi\\Component\\Coupon\\Entity\\Coupon;\n\n$coupon = new Coupon();\n$coupon-\nsetType($type);\n\n\n\n\nLet's take a look to each one.\n\n\nAbsolute value coupons\n #\n\n\nThis is the common and default coupon type. You apply an specific discount for\nthe cart defined by an specific amount, for example 10 euros.\n\n\nuse Elcodi\\Component\\CartCoupon\\Applicator\\AbsoluteCartCouponApplicator;\n\n$price = ... // Money instance\n\n$coupon-\nsetType(AbsoluteCartCouponApplicator::id();\n$coupon-\nsetPrice($price);\n\n\n\n\nPercent coupons\n #\n\n\nThis coupon introduces a percent discount for the final cart.\n\n\nuse Elcodi\\Component\\CartCoupon\\Applicator\\PercentCartCouponApplicator;\n\n$coupon-\nsetType(PercentCartCouponApplicator::id();\n$coupon-\nsetDiscount(15);\n\n\n\n\nNxM coupons\n #\n\n\nThis coupon is intended to be a \n\"buy n units and pay only m\"\n. Because the\nsystem should always be opened for evolution, the configuration of this coupon\nis done by using an specific syntax.\n\n\nuse Elcodi\\Component\\CartCoupon\\Applicator\\Abstracts\\AbstractMxNCartCouponApplicator;\n\n$coupon-\nsetType(AbstractMxNCartCouponApplicator::id();\n$coupon-\nsetValue('xxx');\n\n\n\n\nIn this chapter we will explain how to configure these coupons. This\nconfiguration is splitted in three blocks. Each one defines an specific part of\nthe coupon and they are splitted by the symbol \n:\n.\n\n\nNxM Configuration\n #\n\n\nFirst block. Configures the NxM definition:\n\n\n\n\nN: Units to buy\n\n\nM: Units to pay\n\n\n\n\nFor example, 3x2 means pay 2 and buy 3. That simple.\n\n\nFiltering Configuration\n #\n\n\nThe second block aims to be the filter of the coupon. What elements should this\ncoupon be applied on? You can filter by using product ids, category ids or\nmanufacturer ids.\n\n\nLet's see some examples with the explanation of the meaning (all of them start\nwith Pay 2 and Buy 3):\n\n\n\n\n3x2:p(12)\n - Only applies to purchasables with id 12\n\n\n3x2:p(50,2)\n - Only applies to purchasables with id 50 or 2\n\n\n3x2:c(1)\n - Only applies to purchasables of category with id 1\n\n\n3x2:c(1,3)\n - Only applies to purchasables of category with id 1 or 3\n\n\n3x2:m(5)\n - Only applies to purchasables of manufacturer with id 5\n\n\n3x2:m(5,45)\n - Only applies to purchasables of manufacturer with id 5 or 45\n\n\n3x2:c(50)\nm(2)\n - Only applies to purchasables of category with id 50 and\nmanufacturer with id 2\n\n\n3x2:p(10)|m(2)|c(4,10)\n - Only applies to purchasables that have id 50, or\nwith category 4 or 10, or with manufacturer 2.\n\n\n\n\nModifiers Configuration\n #\n\n\nLast block. Once you've filtered, you can configure some special behaviors of\nyour coupon. Each one of the modifiers are a simple letter at the end of the\nexpression. You can add as many as you need, no matter the order between them.\n\n\nThe first group of modifiers are related to what family of Purchasables this\ncoupon should apply with.\n\n\n\n\nP - Coupon applicable only on Products\n\n\nV - Coupon applicable only on Variants\n\n\nK - Coupon applicable only on Packs\n\n\n\n\nYou can combine them all\n\n\n\n\nPK - Coupon applicable only on Products and Packs\n\n\n\n\nLets see an example\n\n\n\n\n3x2:c(12):PK\n - Pay 2 and buy 3. Applicable only on products and packs that\nare from category with id 12.\n\n\n\n\nThe second group of modifiers are related to how to apply the coupon once all\npurchasable elements are selected.\n\n\nBy default, your MxN coupon is applied to each purchasable selected. For\nexample, if your cart has a product 3 times and a pack 3 times, both available\nfor a 3x2 coupon, the coupon will be applied for each one in an independent way,\nso you will pay 2 products and 2 packs. One of each them will be free.\n\n\n\n\nG - Group modificator. This modificator allow you to treat all purchasables as\nthe same when applying the coupon. With the last example, you would have 6\npurchasables, and you would get free only the 2 most cheap (no matter if they\nare products or packs).\n\n\n\n\n3x2:c(12):PKG\n\n\nAdding a new filter\n #\n\n\nYou can add a new filter by creating a new implementation of interface\n\nSymfony\\Component\\ExpressionLanguage\\ExpressionLanguage\n.\n\n\nThis filter uses the ExpressionLanguage that Symfony provides, so make sure you\nknow how it works.\n\n\nThis interface requires you to implement a method called registerFunction.\n\n\n/**\n * Interface ExpressionLanguageFunctionInterface.\n */\ninterface ExpressionLanguageFunctionInterface\n{\n    /**\n     * Register function.\n     *\n     * @param ExpressionLanguage $expressionLanguage Expression language\n     */\n    public function registerFunction(ExpressionLanguage $expressionLanguage);\n}\n\n\n\n\nOnce you have created this implementation, you need to register it in your\ndependency injection file with a tag.\n\n\nservices:\n    elcodi.cart_coupon_applicator_function.custom:\n        class: My\\Custom\\Applicator\\Function\\Namespace\n        public: false\n        tags:\n            - { name: elcodi.cart_coupon_applicator_function }\n\n\n\n\nAdding a new Type\n #\n\n\nYou can add a new Type as well. In that case you must create a new\nimplementation for interface\n\nElcodi\\Component\\CartCoupon\\Applicator\\Interfaces\\CartCouponApplicatorInterface\n.\n\n\nThis interface requires you to implement these methods.\n\n\n/**\n * Interface CartCouponApplicatorInterface.\n */\ninterface CartCouponApplicatorInterface\n{\n    /**\n     * Get the id of the Applicator.\n     *\n     * @return string Applicator id\n     */\n    public static function id();\n\n    /**\n     * Can be applied.\n     *\n     * @param CartInterface   $cart   Cart\n     * @param CouponInterface $coupon Coupon\n     *\n     * @return bool Can be applied\n     */\n    public function canBeApplied(\n        CartInterface $cart,\n        CouponInterface $coupon\n    );\n\n    /**\n     * Calculate coupon absolute value.\n     *\n     * @param CartInterface   $cart   Cart\n     * @param CouponInterface $coupon Coupon\n     *\n     * @return MoneyInterface|false Absolute value for this coupon in this cart.\n     */\n    public function getCouponAbsoluteValue(\n        CartInterface $cart,\n        CouponInterface $coupon\n    );\n}\n\n\n\n\nOnce you have implemented this method, then you need to register your new\nservice in your dependency injection configuration file.\n\n\nservices:\n    elcodi.cart_coupon_applicator.custom:\n        class: My\\Custom\\Applicator\\Namespace\n        tags:\n            - { name: elcodi.cart_coupon_applicator }\n\n\n\n\nCoupon enforcement\n #\n\n\nAnother possible coupon configuration is the enforcement. The real meaning of\nthat value is for \nHow the coupon is applied\n. Values can be manually and\nautomatically.\n\n\nnamespace Elcodi\\Component\\Coupon;\n/**\n * Class ElcodiCouponTypes\n */\nfinal class ElcodiCouponTypes\n{\n    /**\n     * @var integer\n     *\n     * Automatic enforcement\n     */\n    const ENFORCEMENT_AUTOMATIC = 1;\n\n    /**\n     * @var integer\n     *\n     * Manual enforcement\n     */\n    const ENFORCEMENT_MANUAL = 2;\n}\n\n\n\n\nWith the first one you are creating a coupon that will be applied automatically\nin all carts. This doesn't mean that will be really applied to all of them, but\njust tried.\n\n\nMinimum purchase\n #\n\n\nYou can define that a coupon is only applicable when a cart price is above a \ncertain price. The way to do that is by using the property called\n\n$minimumPurchase\n. This property may be an instance of \nElcodi\\Component\\Currency\\Entity\\Money\n.\n\n\n/**\n * Set minimum purchase\n *\n * @param MoneyInterface $amount Absolute Price\n *\n * @return $this Self object\n */\npublic function setMinimumPurchase(MoneyInterface $amount)\n{\n    $this-\nminimumPurchaseAmount = $amount-\ngetAmount();\n    $this-\nminimumPurchaseCurrency = $amount-\ngetCurrency();\n    return $this;\n}\n/**\n * Get minimum purchase\n *\n * @return MoneyInterface Absolute Price\n */\npublic function getMinimumPurchase()\n{\n    return Money::create(\n        $this-\nminimumPurchaseAmount,\n        $this-\nminimumPurchaseCurrency\n    );\n}\n\n\n\n\nAdding some Rules\n #\n\n\nWhen a Coupon is intended to be applied in a Cart and the field \n$rule\n is not\nnull, then this rule is applied. Of course, if the rule execution result is\nfalse, the coupon is refused.\n\n\nyou can read some information about rules by following these links\n\n\n\n\nNew in Symfony 2.4: The ExpressionLanguage Component\n\n\nExpressionLanguage Symfony Component", 
            "title": "Coupon architecture"
        }, 
        {
            "location": "/book/coupon-architecture/#coupon-architecture", 
            "text": "Our coupon architecture is intended to work as a simple coupon server. All the\ncoupon model is decoupled from every other package, so you should be able to\nwork with coupons, and only with coupons.  In this chapter we will take a look at the different types of coupons we can\nwork in Elcodi. Of course, this model can evolve and get better.", 
            "title": "Coupon Architecture"
        }, 
        {
            "location": "/book/coupon-architecture/#create-coupon", 
            "text": "If you want to create a new coupon instance, you should always use the factory\nobject defined in the dependency injection layer. The service is defined with\nthe name  elcodi.factory.coupon  and is available for injection as follows.  services:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.coupon  a small snippet of this service could be that one  $coupon = $this\n    - couponFactory\n    - create()  Please, follow this cookbook if you need more information about elcodi factories.   How to implement a factory", 
            "title": "Create coupon"
        }, 
        {
            "location": "/book/coupon-architecture/#coupon-types", 
            "text": "Important. This part of the documentation describes how Elcodi manages the\ntypes involving the elcodi's Cart implementation.   There are several types of application in elcodi Coupons and each of them uses\na certain part of the Coupon entity. The type of the coupon can be defined using\nthe field  $type  of Coupon.  use Elcodi\\Component\\Coupon\\Entity\\Coupon;\n\n$coupon = new Coupon();\n$coupon- setType($type);  Let's take a look to each one.  Absolute value coupons  #  This is the common and default coupon type. You apply an specific discount for\nthe cart defined by an specific amount, for example 10 euros.  use Elcodi\\Component\\CartCoupon\\Applicator\\AbsoluteCartCouponApplicator;\n\n$price = ... // Money instance\n\n$coupon- setType(AbsoluteCartCouponApplicator::id();\n$coupon- setPrice($price);  Percent coupons  #  This coupon introduces a percent discount for the final cart.  use Elcodi\\Component\\CartCoupon\\Applicator\\PercentCartCouponApplicator;\n\n$coupon- setType(PercentCartCouponApplicator::id();\n$coupon- setDiscount(15);  NxM coupons  #  This coupon is intended to be a  \"buy n units and pay only m\" . Because the\nsystem should always be opened for evolution, the configuration of this coupon\nis done by using an specific syntax.  use Elcodi\\Component\\CartCoupon\\Applicator\\Abstracts\\AbstractMxNCartCouponApplicator;\n\n$coupon- setType(AbstractMxNCartCouponApplicator::id();\n$coupon- setValue('xxx');  In this chapter we will explain how to configure these coupons. This\nconfiguration is splitted in three blocks. Each one defines an specific part of\nthe coupon and they are splitted by the symbol  : .  NxM Configuration  #  First block. Configures the NxM definition:   N: Units to buy  M: Units to pay   For example, 3x2 means pay 2 and buy 3. That simple.  Filtering Configuration  #  The second block aims to be the filter of the coupon. What elements should this\ncoupon be applied on? You can filter by using product ids, category ids or\nmanufacturer ids.  Let's see some examples with the explanation of the meaning (all of them start\nwith Pay 2 and Buy 3):   3x2:p(12)  - Only applies to purchasables with id 12  3x2:p(50,2)  - Only applies to purchasables with id 50 or 2  3x2:c(1)  - Only applies to purchasables of category with id 1  3x2:c(1,3)  - Only applies to purchasables of category with id 1 or 3  3x2:m(5)  - Only applies to purchasables of manufacturer with id 5  3x2:m(5,45)  - Only applies to purchasables of manufacturer with id 5 or 45  3x2:c(50) m(2)  - Only applies to purchasables of category with id 50 and\nmanufacturer with id 2  3x2:p(10)|m(2)|c(4,10)  - Only applies to purchasables that have id 50, or\nwith category 4 or 10, or with manufacturer 2.   Modifiers Configuration  #  Last block. Once you've filtered, you can configure some special behaviors of\nyour coupon. Each one of the modifiers are a simple letter at the end of the\nexpression. You can add as many as you need, no matter the order between them.  The first group of modifiers are related to what family of Purchasables this\ncoupon should apply with.   P - Coupon applicable only on Products  V - Coupon applicable only on Variants  K - Coupon applicable only on Packs   You can combine them all   PK - Coupon applicable only on Products and Packs   Lets see an example   3x2:c(12):PK  - Pay 2 and buy 3. Applicable only on products and packs that\nare from category with id 12.   The second group of modifiers are related to how to apply the coupon once all\npurchasable elements are selected.  By default, your MxN coupon is applied to each purchasable selected. For\nexample, if your cart has a product 3 times and a pack 3 times, both available\nfor a 3x2 coupon, the coupon will be applied for each one in an independent way,\nso you will pay 2 products and 2 packs. One of each them will be free.   G - Group modificator. This modificator allow you to treat all purchasables as\nthe same when applying the coupon. With the last example, you would have 6\npurchasables, and you would get free only the 2 most cheap (no matter if they\nare products or packs).   3x2:c(12):PKG  Adding a new filter  #  You can add a new filter by creating a new implementation of interface Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage .  This filter uses the ExpressionLanguage that Symfony provides, so make sure you\nknow how it works.  This interface requires you to implement a method called registerFunction.  /**\n * Interface ExpressionLanguageFunctionInterface.\n */\ninterface ExpressionLanguageFunctionInterface\n{\n    /**\n     * Register function.\n     *\n     * @param ExpressionLanguage $expressionLanguage Expression language\n     */\n    public function registerFunction(ExpressionLanguage $expressionLanguage);\n}  Once you have created this implementation, you need to register it in your\ndependency injection file with a tag.  services:\n    elcodi.cart_coupon_applicator_function.custom:\n        class: My\\Custom\\Applicator\\Function\\Namespace\n        public: false\n        tags:\n            - { name: elcodi.cart_coupon_applicator_function }  Adding a new Type  #  You can add a new Type as well. In that case you must create a new\nimplementation for interface Elcodi\\Component\\CartCoupon\\Applicator\\Interfaces\\CartCouponApplicatorInterface .  This interface requires you to implement these methods.  /**\n * Interface CartCouponApplicatorInterface.\n */\ninterface CartCouponApplicatorInterface\n{\n    /**\n     * Get the id of the Applicator.\n     *\n     * @return string Applicator id\n     */\n    public static function id();\n\n    /**\n     * Can be applied.\n     *\n     * @param CartInterface   $cart   Cart\n     * @param CouponInterface $coupon Coupon\n     *\n     * @return bool Can be applied\n     */\n    public function canBeApplied(\n        CartInterface $cart,\n        CouponInterface $coupon\n    );\n\n    /**\n     * Calculate coupon absolute value.\n     *\n     * @param CartInterface   $cart   Cart\n     * @param CouponInterface $coupon Coupon\n     *\n     * @return MoneyInterface|false Absolute value for this coupon in this cart.\n     */\n    public function getCouponAbsoluteValue(\n        CartInterface $cart,\n        CouponInterface $coupon\n    );\n}  Once you have implemented this method, then you need to register your new\nservice in your dependency injection configuration file.  services:\n    elcodi.cart_coupon_applicator.custom:\n        class: My\\Custom\\Applicator\\Namespace\n        tags:\n            - { name: elcodi.cart_coupon_applicator }", 
            "title": "Coupon types"
        }, 
        {
            "location": "/book/coupon-architecture/#coupon-enforcement", 
            "text": "Another possible coupon configuration is the enforcement. The real meaning of\nthat value is for  How the coupon is applied . Values can be manually and\nautomatically.  namespace Elcodi\\Component\\Coupon;\n/**\n * Class ElcodiCouponTypes\n */\nfinal class ElcodiCouponTypes\n{\n    /**\n     * @var integer\n     *\n     * Automatic enforcement\n     */\n    const ENFORCEMENT_AUTOMATIC = 1;\n\n    /**\n     * @var integer\n     *\n     * Manual enforcement\n     */\n    const ENFORCEMENT_MANUAL = 2;\n}  With the first one you are creating a coupon that will be applied automatically\nin all carts. This doesn't mean that will be really applied to all of them, but\njust tried.", 
            "title": "Coupon enforcement"
        }, 
        {
            "location": "/book/coupon-architecture/#minimum-purchase", 
            "text": "You can define that a coupon is only applicable when a cart price is above a \ncertain price. The way to do that is by using the property called $minimumPurchase . This property may be an instance of  Elcodi\\Component\\Currency\\Entity\\Money .  /**\n * Set minimum purchase\n *\n * @param MoneyInterface $amount Absolute Price\n *\n * @return $this Self object\n */\npublic function setMinimumPurchase(MoneyInterface $amount)\n{\n    $this- minimumPurchaseAmount = $amount- getAmount();\n    $this- minimumPurchaseCurrency = $amount- getCurrency();\n    return $this;\n}\n/**\n * Get minimum purchase\n *\n * @return MoneyInterface Absolute Price\n */\npublic function getMinimumPurchase()\n{\n    return Money::create(\n        $this- minimumPurchaseAmount,\n        $this- minimumPurchaseCurrency\n    );\n}", 
            "title": "Minimum purchase"
        }, 
        {
            "location": "/book/coupon-architecture/#adding-some-rules", 
            "text": "When a Coupon is intended to be applied in a Cart and the field  $rule  is not\nnull, then this rule is applied. Of course, if the rule execution result is\nfalse, the coupon is refused.  you can read some information about rules by following these links   New in Symfony 2.4: The ExpressionLanguage Component  ExpressionLanguage Symfony Component", 
            "title": "Adding some Rules"
        }, 
        {
            "location": "/book/dictionary/", 
            "text": "Dictionary\n #\n\n\nIn this dictionary you will find some meanings of some of our most used words.\nIf there is one word you don't know what is about, please ask us in out\n\nGitter channel\n and we will create the entry\nas soon as possible.\n\n\nWe will very happy to help you :)\n\n\nAttribute\n #\n\n\nRefers to a feature of a Variant.\n\nPlease, check \nVariant\n\n\nBamboo\n #\n\n\nBamboo is a simple and basic E-commerce application based on Symfony, that uses\nall Elcodi components for it's own business logic. All Elcodi related best \npractices are applied and used in this project.\n\n\nCartLine\n #\n\n\nEverytime a product or a variant is added into your cart, some information\nrelated to this specific action must be stored. For example, if you add a\nVariant and some extra information must be stored, where do you do it? Or where\ndo you store how many units of a product you want to buy?\n\n\nIf the relation between a Product and a Cart is persisted without any kind of\nmiddle class, then you cannot store this information.\n\n\nSo, a CartLine is an object in the middle between any purchasable and a cart to\nstore information about this purchasable instance and the cart.\n\n\n\n\nComponent\n #\n\n\nA component is a simple PHP Library. Only PHP Classes are placed inside this \npackage and must be framework agnostic. Because this project is a Symfony\nproject, each component has it's own Bundle, where all libraries are exposed to\nthe Symfony Dependency Injection and where are bundles are created and\nconfigured.\n\n\nElcodi has splitted its business logic in several components, each one \ncontaining specific parts of the model, and grouped semantically. CHeckout some\nof them:\n\n\n\n\nCart Component\n\n\nProduct Component\n\n\nCore Component\n\n\n\n\nSome of our components are detailed and documented in this documentation.\n\n\n\n\nElcodi Components\n\n\n\n\nAnd some other components are described as book chapters, describing a little\nbit more its architecture and workflow.\n\n\n\n\nCart Architecture\n\n\nProduct Architecture\n\n\n\n\nFactory\n #\n\n\nPHP Class with one single responsibility: create a new entity instance. This\nclass should know as well how this entity instance must be initialized given\nan specific environment\n\n\n\n\nMy CustomerFactory initializes all my Customer new instances as females \n  because my project is focused on women.\n\n\nOther projects can overwrite this class by defining how a Customer should be\n  initialized\n\n\nBecause of that, the customer itself should never know about it's own\n  initialization\n\n\n\n\nTo know a little bit more about factories, please follow this interesting links:\n\n\n\n\nHow to implement a factory\n\n\nFactory pattern in Symfony2\n\n\n\n\nPlugin\n #\n\n\nBecause Bamboo must be a project with a well-designed extension point. For such\nreason, and taking advantage of how Symfony Bundles work, we have created a \nplugin engine in order to allow people overwriting and extending Bamboo in a\nvery simple and intuitive way.\n\n\nWhen we refer to a Plugin then, we refer to these Bundles that are thought as \nPlugins, following their specification.\n\n\nThere is a full book chapter about Elcodi plugins, and this part is going to be\nimproved day by day with new ideas, with new developments and with new\nspecifications.\n\n\nElcodi Plugins\n\n\nRepository\n #\n\n\nEach entity has it's own repository. When we refer to a repository, we are\nautomatically referring to the Doctrine Repositories.\n\n\nEach repository is created by default and defined inside the Dependency\nInjection service map using the structure \nelcodi.repository.{entity_name}\n.\n\n\nTo know more about Repositories in Elcodi, please check these links.\n\n\nHow to implement a Repository\n\n\nDoctrine Repositories\n\n\nValue\n #\n\n\nRefers to a value of an attribute and assigned to a Variant.\n\nPlease, check \nVariant\n\n\nVariant\n #\n\n\nSometimes a Product is not enough when we need to define something we want to \nsell. Let's see an example.\n\n\n\n\nIn our store we sell a T-shirt\n\n\nIf your T-Shirt is only sold only in red color and you only have one size, \n  then that's good enough for you\n\n\nBut what happens when your T-shirt is available in many colors or many sizes?\n\n\nYour product will still be the same T-shirt, but you need a new entity to say\n  that people can buy this T-shirt in red, blue and grey, and in several sizes,\n  like small, medium or large.\n\n\nWhen we talk about Variant, we talk about each available combination, \n  containing the original product, the color and the size.\n\n\nOf course, if your have several Variants of a specific Product, people will be\n  able to add these variants to their carts, instead of the Product.\n\n\n\n\nThis is the main definition of what a Variant is, but in this case we will\nintroduce you as well the common terms \nAttribute\n and \nValue\n. Each variant\ninstance is a Product element combined to an Attribute and a Color.\n\n\nLet's continue with the same example, but specifying a little bit.\n\n\n\n\nWe have our T-shirt Product\n\n\nWe have created a new Attribute called Size\n\n\nWe have created three new values related to this Attribute, called Small,\nMedium and Large. All three have Size as Attribute.\n\n\nWe have created one new Variant, having our the T-shirt as product, and having\nSmall as Value. Because this Value has Size as Attribute, then we can say that:\n\n\n\n\nWe have a new Variant called \"Small T-shirt\"\n\n Product: T-shirt\n\n Attribute: Size\n* Value: Small\n\n\nOf course, a Variant is a \nPurchasable\n like Product, so you can add it into\nyour Cart.", 
            "title": "Dictionary"
        }, 
        {
            "location": "/book/dictionary/#dictionary", 
            "text": "In this dictionary you will find some meanings of some of our most used words.\nIf there is one word you don't know what is about, please ask us in out Gitter channel  and we will create the entry\nas soon as possible.  We will very happy to help you :)  Attribute  #  Refers to a feature of a Variant. \nPlease, check  Variant  Bamboo  #  Bamboo is a simple and basic E-commerce application based on Symfony, that uses\nall Elcodi components for it's own business logic. All Elcodi related best \npractices are applied and used in this project.  CartLine  #  Everytime a product or a variant is added into your cart, some information\nrelated to this specific action must be stored. For example, if you add a\nVariant and some extra information must be stored, where do you do it? Or where\ndo you store how many units of a product you want to buy?  If the relation between a Product and a Cart is persisted without any kind of\nmiddle class, then you cannot store this information.  So, a CartLine is an object in the middle between any purchasable and a cart to\nstore information about this purchasable instance and the cart.   Component  #  A component is a simple PHP Library. Only PHP Classes are placed inside this \npackage and must be framework agnostic. Because this project is a Symfony\nproject, each component has it's own Bundle, where all libraries are exposed to\nthe Symfony Dependency Injection and where are bundles are created and\nconfigured.  Elcodi has splitted its business logic in several components, each one \ncontaining specific parts of the model, and grouped semantically. CHeckout some\nof them:   Cart Component  Product Component  Core Component   Some of our components are detailed and documented in this documentation.   Elcodi Components   And some other components are described as book chapters, describing a little\nbit more its architecture and workflow.   Cart Architecture  Product Architecture   Factory  #  PHP Class with one single responsibility: create a new entity instance. This\nclass should know as well how this entity instance must be initialized given\nan specific environment   My CustomerFactory initializes all my Customer new instances as females \n  because my project is focused on women.  Other projects can overwrite this class by defining how a Customer should be\n  initialized  Because of that, the customer itself should never know about it's own\n  initialization   To know a little bit more about factories, please follow this interesting links:   How to implement a factory  Factory pattern in Symfony2   Plugin  #  Because Bamboo must be a project with a well-designed extension point. For such\nreason, and taking advantage of how Symfony Bundles work, we have created a \nplugin engine in order to allow people overwriting and extending Bamboo in a\nvery simple and intuitive way.  When we refer to a Plugin then, we refer to these Bundles that are thought as \nPlugins, following their specification.  There is a full book chapter about Elcodi plugins, and this part is going to be\nimproved day by day with new ideas, with new developments and with new\nspecifications.  Elcodi Plugins  Repository  #  Each entity has it's own repository. When we refer to a repository, we are\nautomatically referring to the Doctrine Repositories.  Each repository is created by default and defined inside the Dependency\nInjection service map using the structure  elcodi.repository.{entity_name} .  To know more about Repositories in Elcodi, please check these links.  How to implement a Repository  Doctrine Repositories  Value  #  Refers to a value of an attribute and assigned to a Variant. \nPlease, check  Variant  Variant  #  Sometimes a Product is not enough when we need to define something we want to \nsell. Let's see an example.   In our store we sell a T-shirt  If your T-Shirt is only sold only in red color and you only have one size, \n  then that's good enough for you  But what happens when your T-shirt is available in many colors or many sizes?  Your product will still be the same T-shirt, but you need a new entity to say\n  that people can buy this T-shirt in red, blue and grey, and in several sizes,\n  like small, medium or large.  When we talk about Variant, we talk about each available combination, \n  containing the original product, the color and the size.  Of course, if your have several Variants of a specific Product, people will be\n  able to add these variants to their carts, instead of the Product.   This is the main definition of what a Variant is, but in this case we will\nintroduce you as well the common terms  Attribute  and  Value . Each variant\ninstance is a Product element combined to an Attribute and a Color.  Let's continue with the same example, but specifying a little bit.   We have our T-shirt Product  We have created a new Attribute called Size  We have created three new values related to this Attribute, called Small,\nMedium and Large. All three have Size as Attribute.  We have created one new Variant, having our the T-shirt as product, and having\nSmall as Value. Because this Value has Size as Attribute, then we can say that:   We have a new Variant called \"Small T-shirt\"  Product: T-shirt  Attribute: Size\n* Value: Small  Of course, a Variant is a  Purchasable  like Product, so you can add it into\nyour Cart.", 
            "title": "Dictionary"
        }, 
        {
            "location": "/book/emails/", 
            "text": "Emails\n #\n\n\nAll these emails are managed by the application. In this chapter we will explain\nwhat emails you will find and where are sent. You will find as well how to work\nwith them and overwrite their content.", 
            "title": "Emails"
        }, 
        {
            "location": "/book/emails/#emails", 
            "text": "All these emails are managed by the application. In this chapter we will explain\nwhat emails you will find and where are sent. You will find as well how to work\nwith them and overwrite their content.", 
            "title": "Emails"
        }, 
        {
            "location": "/book/events/", 
            "text": "Elcodi Events\n #\n\n\nFull Elcodi Events documentation. Each entry describes what the event is \ncreated for, where is thrown and how can be used.\n\n\nPriorities\n #\n\n\nEach time an event is dispatched, a bunch of subscribers are ready to be \nexecuted. But who says which one must be executed first, and which one must be\nexecuted the last one?\n\n\nWell, each event listener can have a priority value, and once all these \nlisteners must be executed, one by one, they are previously sorted by this \nvalue, from 128 to -127. The more high, the before is executed.\n\n\nservices:\n\n    elcodi.event_listener.some:\n        class: My\\Bundle\\EventListener\\SomeEventListener\n        tags:\n            - { name: kernel.event_listener, event: order.oncreated, method: some, priority: 16 }\n\n\n\n\nThis parameter is not required, and by default is 0. When several listeners \nhave the same priority, then the \nfirst found, first executed\n solution is \nwisely applied.\n\n\ncart.preload\n #\n\n\nThis event is dispatched by the \nCartManager\n and is intended for one single \nreason: check anything related to a Cart before loading it. Once the cart is \nfetched from the database, and because most of the values must be computed on \nreal time (stock must be checked, for example), must be loaded somehow. Loading \na cart means checking its correctness and computing all prices.\n\n\nWell, if you need to do some checks after this computation is done, then use \nthis event.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartPreLoadEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartPreLoadEvent $event)\n{\n    $cart = $event-\ngetCart();\n}\n\n\n\n\ncart.onload\n #\n\n\nOnce the cart has been checked, this one can be loaded. This event is thrown \nonly when the cart is valid and, after it, cart instance must be complete and\nready to be used by the application.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartOnLoadEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartOnLoadEvent $event)\n{\n    $cart = $event-\ngetCart();\n}\n\n\n\n\ncart.onempty\n #\n\n\nYou can subscribe as well when the cart is emptied, so you can add some checks\nor actions related to this action.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartOnEmptyEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartOnEmptyEvent $event)\n{\n    $cart = $event-\ngetCart();\n}\n\n\n\n\ncart.inconsistent\n #\n\n\nOnce the cart is being checked, one of the possibilities is that any cart line\nis invalid, for example because there is no stock anymore of the product \nrelated, or because the product has been disabled meanwhile.\n\n\nBy default, these lines are removed from the cart, but you can add some extra\nbehavior by subscribing to this event.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartInconsistentEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartInconsistentEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $cartLine = $event-\ngetCartLine();\n}\n\n\n\n\ncart_line.onadd\n #\n\n\nEach time a new cart line is created and added into a cart, this event is \ndispatched.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartLineOnAddEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnAddEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $cartLine = $event-\ngetCartLine();\n}\n\n\n\n\ncart_line.onedit\n #\n\n\nEach time an existing cart line is edited, this event is dispatched. To edit a\ncart line means changing its quantity, for example.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartLineOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnEditEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $cartLine = $event-\ngetCartLine();\n}\n\n\n\n\ncart_line.onremove\n #\n\n\nEach time an existing cart line is removed, this event is dispatched.\n\n\nuse Elcodi\\Component\\Cart\\Event\\CartLineOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnEditEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $cartLine = $event-\ngetCartLine();\n}\n\n\n\n\norder.precreated\n #\n\n\nOnce a cart is purchased, a new Order instance must be created from it. This \nevent is dispatched before this order is created, so the instance is not a \nreality yet.\n\n\nIndeed, this event is more related to the cart that is going to be converted, so\nany business logic related to \"This cart is going to be transformed into an \nOrder\", should be placed here, no matter how the Order is.\n\n\nuse Elcodi\\Component\\Cart\\Event\\OrderPreCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderPreCreatedEvent $event)\n{\n    $cart = $event-\ngetCart();\n}\n\n\n\n\norder.oncreated\n #\n\n\nThe Order is now being created, so any kind of business logic related to the \nCart that is being transformed, or the new Order, you can subscribe to this\nevent.\n\n\nuse Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderOnCreatedEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $order = $event-\ngetOrder();\n}\n\n\n\n\norder_line.oncreated\n #\n\n\nWhen creating the order given a cart, for each cart line found, a new order line\nis created as well. Each time this happens, a new event of this type is \ndispatched.\n\n\nThis is used, for example, when the stock must be updated from each cart line.\n\n\nuse Elcodi\\Component\\Cart\\Event\\OrderLineOnCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderLineOnCreatedEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $order = $event-\ngetOrder();\n    $orderLine = $event-\ngetOrderLine();\n}\n\n\n\n\ncart_coupon.oncheck\n #\n\n\nEach time a cart is loaded, all coupons are checked one by one. You can access\nto the checked coupon and to the full cart object.\n\n\nuse Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnCheckEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnCheckEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n    $cartCoupon = $event-\ngetCartCoupon();\n}\n\n\n\n\ncart_coupon.onapply\n #\n\n\nEach time a new coupon is applied to an existing cart, this event is dispatched.\n\n\nThe association itself is done by an Event Listener as well with priority 0, so\nbefore that, the association object will not be available.\n\n\nuse Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnApplyEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnApplyEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n    $cartCoupon = $event-\ngetCartCoupon();\n}\n\n\n\n\ncart_coupon.onremove\n #\n\n\nEach time a coupon is removed from a cart, this event is dispatched. \n\n\nTake in account that the coupon is really removed from the cart (only the \nassociation is removed, not the coupon itself) by an Event Listener with \npriority 0.\n\n\nuse Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRemoveEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRemoveEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n    $cartCoupon = $event-\ngetCartCoupon();\n}\n\n\n\n\ncart_coupon.onrejected\n #\n\n\nEach time a coupon is intended to be applied to a cart, some kind of checks are\nperformed in order to know if this coupon is really applicable. If it is, great\nthen, otherwise, this event is dispatched.\n\n\nOne useful case for that event is notifying the administrator how many times a\ncoupon has been rejected by the application.\n\n\nuse Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRejectedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRejectedEvent $event)\n{\n    $cart = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n}\n\n\n\n\norder_coupon.onapply\n #\n\n\nOnce the cart is processed and a new order is created from it, for each \navailable coupon used and accepted a new association between the coupon and the\norder is created. Then, this event is dispatched.\n\n\nThe association itself is done by an Event Listener as well with priority 0, so\nbefore that, the association object will not be available.\n\n\nuse Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRejectedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRejectedEvent $event)\n{\n    $order = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n    $orderCoupon = $event-\ngetOrderCoupon();\n}\n\n\n\n\ncomment.onadd\n #\n\n\nA new comment has been added.\n\n\nuse Elcodi\\Component\\Comment\\Event\\CommentOnAddEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CommentOnAddEvent $event)\n{\n    $comment = $event-\ngetComment();\n}\n\n\n\n\ncomment.onedit\n #\n\n\nAn existing comment is being edited.\n\n\nuse Elcodi\\Component\\Comment\\Event\\CommentOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CommentOnEditEvent $event)\n{\n    $comment = $event-\ngetComment();\n}\n\n\n\n\ncomment.preremove\n #\n\n\ncomment.onremove\n #\n\n\ncomment.onvoted\n #\n\n\ncoupon.onused\n #\n\n\nEach time a certain coupon is used, this coupon is dispatched. Commonly used to\nincrease the coupon usages.\n\n\nuse Elcodi\\Component\\Coupon\\Event\\CouponOnUsedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CouponOnUsedEvent $event)\n{\n    $order = $event-\ngetCart();\n    $coupon = $event-\ngetCoupon();\n    $orderCoupon = $event-\ngetOrderCoupon();\n}\n\n\n\n\naddress.onclone\n #\n\n\nBecause an address can be changed after has been used in an order, for example,\neach time an address is edited, should be cloned. When this happens, this event\nis dispatched in order to some extra actions.\n\n\nuse Elcodi\\Component\\Geo\\Event\\AddressOnCloneEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(AddressOnCloneEvent $event)\n{\n    $originalAddress = $event-\ngetOriginalAddress();\n    $clonedAddress = $event-\ngetClonedAddress();\n}\n\n\n\n\nimage.preupload\n #\n\n\nAn image is going to be uploaded and saved. Useful for some image manipulation\nbefore being uploaded.\n\n\nuse Elcodi\\Component\\Media\\Event\\ImageUploadedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ImageUploadedEvent $event)\n{\n    $image = $event-\ngetImage();\n}\n\n\n\n\nimage.onupload\n #\n\n\nImage has been uploaded and saved into database\n\n\nuse Elcodi\\Component\\Media\\Event\\ImageUploadedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ImageUploadedEvent $event)\n{\n    $image = $event-\ngetImage();\n}\n\n\n\n\nnewsletter.onsubscribe\n #\n\n\nA user has been subscribed to the newsletter.\n\n\nuse Elcodi\\Component\\Newsletter\\Event\\NewsletterSubscriptionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(NewsletterSubscriptionEvent $event)\n{\n    $newsletterSubscription = $event-\ngetNewsletterSubscription();\n}\n\n\n\n\nnewsletter.onunsubscribe\n #\n\n\nA user has been unsubscribed from the newsletter.\n\n\nuse Elcodi\\Component\\Newsletter\\Event\\NewsletterUnsubscriptionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(NewsletterUnsubscriptionEvent $event)\n{\n    $newsletterSubscription = $event-\ngetNewsletterSubscription();\n}\n\n\n\n\npayment.collect\n #\n\n\nThis event is used by the core when all available payment methods are collected.\nEach bundle will inject itself as a payment method.\n\n\nThis event is not passive, but active. This means that is not just an event, but\na collector (implemented the same way in Symfony, but theoretically different).\n\n\nuse Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PaymentCollectionEvent $event)\n{\n    $cart = $event-\ngetCart();\n\n    /**\n     * Only available with Carts that ...\n     */\n    if ($cart-\ngetPrice() \n //) {\n\n        return;\n    }\n\n    $paymentMethod = new PaymentMethod(\n        'my-payment-method-24872378942',\n        'payment name',\n        'payment description',\n        $this\n            -\nrouter\n            -\ngenerate('payment_route')\n    );\n\n    $event-\naddPaymentMethod($paymentMethod);\n}\n\n\n\n\nshipping.collect\n #\n\n\nThis event is used by the core when all available shipping methods are \ncollected. Of course, each shipping method should check if is valid given the\ncart, the user information or any other related parameter.\n\n\nThis event is not passive, but active. This means that is not just an event, but\na collector (implemented the same way in Symfony, but theoretically different).\n\n\nuse Elcodi\\Component\\Shipping\\Entity\\ShippingMethod;\nuse Elcodi\\Component\\Shipping\\Event\\ShippingCollectionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ShippingCollectionEvent $event)\n{\n    $euro = // Currency instance\n    $cart = $event-\ngetCart();\n\n    /**\n     * Only available with Carts that ...\n     */\n    if ($cart-\ngetPrice() \n //) {\n\n        return;\n    }\n\n\n    $shippingMethod = new ShippingMethod(\n        'custom-shipping-method-437829',\n        'UPS',\n        'Super fast shipping!',\n        '4 days shipping, worldwide',\n        Money::create(10, $euro);\n    );\n\n    $event-\naddShippingMethod($paymentMethod);\n}\n\n\n\n\nstate_machine.{machine_id}.initialization\n #\n\n\nGiven a machine id, and once this initialized for any transition, this event is\ndispatched. Useful for machine configuration.\n\n\nuse Elcodi\\Component\\StateTransitionMachine\\Event\\InitializationEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(InitializationEvent $event)\n{\n    $object = $event-\ngetObject();\n    $stateLineStack = $event-\ngetStateLineStack();\n}\n\n\n\n\nstate_machine.{machine_id}.transition_from_{state_name}\n #\n\n\nState transition done by a machine with id {machine_id} that goes from a state\ncalled {state_name} to any state\n\n\nuse Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event-\ngetObject();\n    $stateLineStack = $event-\ngetStateLineStack();\n    $transition = $event-\ngetTransition();\n}\n\n\n\n\nstate_machine.{machine_id}.transition_{transition_name}\n #\n\n\nState transition with name {transition_name} done by a machine with id \n{machine_id}.\n\n\nuse Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event-\ngetObject();\n    $stateLineStack = $event-\ngetStateLineStack();\n    $transition = $event-\ngetTransition();\n}\n\n\n\n\nstate_machine.{machine_id}.transition_to_{state_name}\n #\n\n\nState transition done by a machine with id {machine_id} that goes from any state\nto a state called {state_name}\n\n\nuse Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event-\ngetObject();\n    $stateLineStack = $event-\ngetStateLineStack();\n    $transition = $event-\ngetTransition();\n}\n\n\n\n\nstate_machine.transition\n #\n\n\nAny state transition done by any state machine\n\n\nuse Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event-\ngetObject();\n    $stateLineStack = $event-\ngetStateLineStack();\n    $transition = $event-\ngetTransition();\n}\n\n\n\n\npassword.remember\n #\n\n\nSome user have used the password remember feature. This means that a new url has\nbeen created for that user in order to give her the possibility to create a new\npassword in a very secured way.\n\n\nuse Elcodi\\Component\\User\\Event\\PasswordRememberEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PasswordRememberEvent $event)\n{\n    $user = $event-\ngetUser();\n    $rememberUrl = $event-\ngetRememberUrl();\n}\n\n\n\n\npassword.recover\n #\n\n\nA user has changed the password by using the remember url. Once this password\nchanges, this event is dispatched.\n\n\nuse Elcodi\\Component\\User\\Event\\PasswordRecoverEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PasswordRecoverEvent $event)\n{\n    $user = $event-\ngetUser();\n}\n\n\n\n\nuser.register\n #\n\n\nA new user object has been registered. Many type of users can coexist, but all\nwill dispatch the same event. You can check the type of user inside your service\nby using \ninstanceof\n.\n\n\nuse Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $user = $event-\ngetUser();\n\n    if ($user instanceof CustomerInterface) {\n\n        // ...\n    } else {\n        // ...\n    }\n}\n\n\n\n\ncustomer.register\n #\n\n\nA new customer object has been registered. Use this event if you want to listen\nonly when a customer is registered, instead of any kind of user.\n\n\nuse Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $customer = $event-\ngetUser();\n}\n\n\n\n\nadminuser.register\n #\n\n\nA new adminuser object has been registered. Use this event if you want to listen\nonly when a admin user is registered, instead of any kind of user.\n\n\nuse Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $customer = $event-\ngetUser();\n}", 
            "title": "Events"
        }, 
        {
            "location": "/book/events/#elcodi-events", 
            "text": "Full Elcodi Events documentation. Each entry describes what the event is \ncreated for, where is thrown and how can be used.  Priorities  #  Each time an event is dispatched, a bunch of subscribers are ready to be \nexecuted. But who says which one must be executed first, and which one must be\nexecuted the last one?  Well, each event listener can have a priority value, and once all these \nlisteners must be executed, one by one, they are previously sorted by this \nvalue, from 128 to -127. The more high, the before is executed.  services:\n\n    elcodi.event_listener.some:\n        class: My\\Bundle\\EventListener\\SomeEventListener\n        tags:\n            - { name: kernel.event_listener, event: order.oncreated, method: some, priority: 16 }  This parameter is not required, and by default is 0. When several listeners \nhave the same priority, then the  first found, first executed  solution is \nwisely applied.  cart.preload  #  This event is dispatched by the  CartManager  and is intended for one single \nreason: check anything related to a Cart before loading it. Once the cart is \nfetched from the database, and because most of the values must be computed on \nreal time (stock must be checked, for example), must be loaded somehow. Loading \na cart means checking its correctness and computing all prices.  Well, if you need to do some checks after this computation is done, then use \nthis event.  use Elcodi\\Component\\Cart\\Event\\CartPreLoadEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartPreLoadEvent $event)\n{\n    $cart = $event- getCart();\n}  cart.onload  #  Once the cart has been checked, this one can be loaded. This event is thrown \nonly when the cart is valid and, after it, cart instance must be complete and\nready to be used by the application.  use Elcodi\\Component\\Cart\\Event\\CartOnLoadEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartOnLoadEvent $event)\n{\n    $cart = $event- getCart();\n}  cart.onempty  #  You can subscribe as well when the cart is emptied, so you can add some checks\nor actions related to this action.  use Elcodi\\Component\\Cart\\Event\\CartOnEmptyEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartOnEmptyEvent $event)\n{\n    $cart = $event- getCart();\n}  cart.inconsistent  #  Once the cart is being checked, one of the possibilities is that any cart line\nis invalid, for example because there is no stock anymore of the product \nrelated, or because the product has been disabled meanwhile.  By default, these lines are removed from the cart, but you can add some extra\nbehavior by subscribing to this event.  use Elcodi\\Component\\Cart\\Event\\CartInconsistentEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartInconsistentEvent $event)\n{\n    $cart = $event- getCart();\n    $cartLine = $event- getCartLine();\n}  cart_line.onadd  #  Each time a new cart line is created and added into a cart, this event is \ndispatched.  use Elcodi\\Component\\Cart\\Event\\CartLineOnAddEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnAddEvent $event)\n{\n    $cart = $event- getCart();\n    $cartLine = $event- getCartLine();\n}  cart_line.onedit  #  Each time an existing cart line is edited, this event is dispatched. To edit a\ncart line means changing its quantity, for example.  use Elcodi\\Component\\Cart\\Event\\CartLineOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnEditEvent $event)\n{\n    $cart = $event- getCart();\n    $cartLine = $event- getCartLine();\n}  cart_line.onremove  #  Each time an existing cart line is removed, this event is dispatched.  use Elcodi\\Component\\Cart\\Event\\CartLineOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartLineOnEditEvent $event)\n{\n    $cart = $event- getCart();\n    $cartLine = $event- getCartLine();\n}  order.precreated  #  Once a cart is purchased, a new Order instance must be created from it. This \nevent is dispatched before this order is created, so the instance is not a \nreality yet.  Indeed, this event is more related to the cart that is going to be converted, so\nany business logic related to \"This cart is going to be transformed into an \nOrder\", should be placed here, no matter how the Order is.  use Elcodi\\Component\\Cart\\Event\\OrderPreCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderPreCreatedEvent $event)\n{\n    $cart = $event- getCart();\n}  order.oncreated  #  The Order is now being created, so any kind of business logic related to the \nCart that is being transformed, or the new Order, you can subscribe to this\nevent.  use Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderOnCreatedEvent $event)\n{\n    $cart = $event- getCart();\n    $order = $event- getOrder();\n}  order_line.oncreated  #  When creating the order given a cart, for each cart line found, a new order line\nis created as well. Each time this happens, a new event of this type is \ndispatched.  This is used, for example, when the stock must be updated from each cart line.  use Elcodi\\Component\\Cart\\Event\\OrderLineOnCreatedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(OrderLineOnCreatedEvent $event)\n{\n    $cart = $event- getCart();\n    $order = $event- getOrder();\n    $orderLine = $event- getOrderLine();\n}  cart_coupon.oncheck  #  Each time a cart is loaded, all coupons are checked one by one. You can access\nto the checked coupon and to the full cart object.  use Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnCheckEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnCheckEvent $event)\n{\n    $cart = $event- getCart();\n    $coupon = $event- getCoupon();\n    $cartCoupon = $event- getCartCoupon();\n}  cart_coupon.onapply  #  Each time a new coupon is applied to an existing cart, this event is dispatched.  The association itself is done by an Event Listener as well with priority 0, so\nbefore that, the association object will not be available.  use Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnApplyEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnApplyEvent $event)\n{\n    $cart = $event- getCart();\n    $coupon = $event- getCoupon();\n    $cartCoupon = $event- getCartCoupon();\n}  cart_coupon.onremove  #  Each time a coupon is removed from a cart, this event is dispatched.   Take in account that the coupon is really removed from the cart (only the \nassociation is removed, not the coupon itself) by an Event Listener with \npriority 0.  use Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRemoveEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRemoveEvent $event)\n{\n    $cart = $event- getCart();\n    $coupon = $event- getCoupon();\n    $cartCoupon = $event- getCartCoupon();\n}  cart_coupon.onrejected  #  Each time a coupon is intended to be applied to a cart, some kind of checks are\nperformed in order to know if this coupon is really applicable. If it is, great\nthen, otherwise, this event is dispatched.  One useful case for that event is notifying the administrator how many times a\ncoupon has been rejected by the application.  use Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRejectedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRejectedEvent $event)\n{\n    $cart = $event- getCart();\n    $coupon = $event- getCoupon();\n}  order_coupon.onapply  #  Once the cart is processed and a new order is created from it, for each \navailable coupon used and accepted a new association between the coupon and the\norder is created. Then, this event is dispatched.  The association itself is done by an Event Listener as well with priority 0, so\nbefore that, the association object will not be available.  use Elcodi\\Component\\CartCoupon\\Event\\CartCouponOnRejectedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CartCouponOnRejectedEvent $event)\n{\n    $order = $event- getCart();\n    $coupon = $event- getCoupon();\n    $orderCoupon = $event- getOrderCoupon();\n}  comment.onadd  #  A new comment has been added.  use Elcodi\\Component\\Comment\\Event\\CommentOnAddEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CommentOnAddEvent $event)\n{\n    $comment = $event- getComment();\n}  comment.onedit  #  An existing comment is being edited.  use Elcodi\\Component\\Comment\\Event\\CommentOnEditEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CommentOnEditEvent $event)\n{\n    $comment = $event- getComment();\n}  comment.preremove  #  comment.onremove  #  comment.onvoted  #  coupon.onused  #  Each time a certain coupon is used, this coupon is dispatched. Commonly used to\nincrease the coupon usages.  use Elcodi\\Component\\Coupon\\Event\\CouponOnUsedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(CouponOnUsedEvent $event)\n{\n    $order = $event- getCart();\n    $coupon = $event- getCoupon();\n    $orderCoupon = $event- getOrderCoupon();\n}  address.onclone  #  Because an address can be changed after has been used in an order, for example,\neach time an address is edited, should be cloned. When this happens, this event\nis dispatched in order to some extra actions.  use Elcodi\\Component\\Geo\\Event\\AddressOnCloneEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(AddressOnCloneEvent $event)\n{\n    $originalAddress = $event- getOriginalAddress();\n    $clonedAddress = $event- getClonedAddress();\n}  image.preupload  #  An image is going to be uploaded and saved. Useful for some image manipulation\nbefore being uploaded.  use Elcodi\\Component\\Media\\Event\\ImageUploadedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ImageUploadedEvent $event)\n{\n    $image = $event- getImage();\n}  image.onupload  #  Image has been uploaded and saved into database  use Elcodi\\Component\\Media\\Event\\ImageUploadedEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ImageUploadedEvent $event)\n{\n    $image = $event- getImage();\n}  newsletter.onsubscribe  #  A user has been subscribed to the newsletter.  use Elcodi\\Component\\Newsletter\\Event\\NewsletterSubscriptionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(NewsletterSubscriptionEvent $event)\n{\n    $newsletterSubscription = $event- getNewsletterSubscription();\n}  newsletter.onunsubscribe  #  A user has been unsubscribed from the newsletter.  use Elcodi\\Component\\Newsletter\\Event\\NewsletterUnsubscriptionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(NewsletterUnsubscriptionEvent $event)\n{\n    $newsletterSubscription = $event- getNewsletterSubscription();\n}  payment.collect  #  This event is used by the core when all available payment methods are collected.\nEach bundle will inject itself as a payment method.  This event is not passive, but active. This means that is not just an event, but\na collector (implemented the same way in Symfony, but theoretically different).  use Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PaymentCollectionEvent $event)\n{\n    $cart = $event- getCart();\n\n    /**\n     * Only available with Carts that ...\n     */\n    if ($cart- getPrice()   //) {\n\n        return;\n    }\n\n    $paymentMethod = new PaymentMethod(\n        'my-payment-method-24872378942',\n        'payment name',\n        'payment description',\n        $this\n            - router\n            - generate('payment_route')\n    );\n\n    $event- addPaymentMethod($paymentMethod);\n}  shipping.collect  #  This event is used by the core when all available shipping methods are \ncollected. Of course, each shipping method should check if is valid given the\ncart, the user information or any other related parameter.  This event is not passive, but active. This means that is not just an event, but\na collector (implemented the same way in Symfony, but theoretically different).  use Elcodi\\Component\\Shipping\\Entity\\ShippingMethod;\nuse Elcodi\\Component\\Shipping\\Event\\ShippingCollectionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(ShippingCollectionEvent $event)\n{\n    $euro = // Currency instance\n    $cart = $event- getCart();\n\n    /**\n     * Only available with Carts that ...\n     */\n    if ($cart- getPrice()   //) {\n\n        return;\n    }\n\n\n    $shippingMethod = new ShippingMethod(\n        'custom-shipping-method-437829',\n        'UPS',\n        'Super fast shipping!',\n        '4 days shipping, worldwide',\n        Money::create(10, $euro);\n    );\n\n    $event- addShippingMethod($paymentMethod);\n}  state_machine.{machine_id}.initialization  #  Given a machine id, and once this initialized for any transition, this event is\ndispatched. Useful for machine configuration.  use Elcodi\\Component\\StateTransitionMachine\\Event\\InitializationEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(InitializationEvent $event)\n{\n    $object = $event- getObject();\n    $stateLineStack = $event- getStateLineStack();\n}  state_machine.{machine_id}.transition_from_{state_name}  #  State transition done by a machine with id {machine_id} that goes from a state\ncalled {state_name} to any state  use Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event- getObject();\n    $stateLineStack = $event- getStateLineStack();\n    $transition = $event- getTransition();\n}  state_machine.{machine_id}.transition_{transition_name}  #  State transition with name {transition_name} done by a machine with id \n{machine_id}.  use Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event- getObject();\n    $stateLineStack = $event- getStateLineStack();\n    $transition = $event- getTransition();\n}  state_machine.{machine_id}.transition_to_{state_name}  #  State transition done by a machine with id {machine_id} that goes from any state\nto a state called {state_name}  use Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event- getObject();\n    $stateLineStack = $event- getStateLineStack();\n    $transition = $event- getTransition();\n}  state_machine.transition  #  Any state transition done by any state machine  use Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(TransitionEvent $event)\n{\n    $object = $event- getObject();\n    $stateLineStack = $event- getStateLineStack();\n    $transition = $event- getTransition();\n}  password.remember  #  Some user have used the password remember feature. This means that a new url has\nbeen created for that user in order to give her the possibility to create a new\npassword in a very secured way.  use Elcodi\\Component\\User\\Event\\PasswordRememberEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PasswordRememberEvent $event)\n{\n    $user = $event- getUser();\n    $rememberUrl = $event- getRememberUrl();\n}  password.recover  #  A user has changed the password by using the remember url. Once this password\nchanges, this event is dispatched.  use Elcodi\\Component\\User\\Event\\PasswordRecoverEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(PasswordRecoverEvent $event)\n{\n    $user = $event- getUser();\n}  user.register  #  A new user object has been registered. Many type of users can coexist, but all\nwill dispatch the same event. You can check the type of user inside your service\nby using  instanceof .  use Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $user = $event- getUser();\n\n    if ($user instanceof CustomerInterface) {\n\n        // ...\n    } else {\n        // ...\n    }\n}  customer.register  #  A new customer object has been registered. Use this event if you want to listen\nonly when a customer is registered, instead of any kind of user.  use Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $customer = $event- getUser();\n}  adminuser.register  #  A new adminuser object has been registered. Use this event if you want to listen\nonly when a admin user is registered, instead of any kind of user.  use Elcodi\\Component\\User\\Event\\UserRegisterEvent;\n\n/**\n * Method subscribed to the event\n */\npublic function doSomething(UserRegisterEvent $event)\n{\n    $customer = $event- getUser();\n}", 
            "title": "Elcodi Events"
        }, 
        {
            "location": "/book/features/", 
            "text": "Features\n #\n\n\nThis is the list of all features Bamboo offers you in its simple and basic\ninstallation. This list will grow over the time, and some features will be added\nby external plugins.\n\n\nStore\n #\n\n\n\n\nHome page, with some products\n\n\nProduct page, with related products\n\n\nVariant page, with related products\n\n\nCart page, with all your cart information\n\n\nLogin and Register infrastructure for customers\n\n\nCustomer administration page with Addresses management\n\n\nLanguage selection\n\n\nCurrency selection\n\n\n\n\nCheckout process\n #\n\n\n\n\nCoupons appliance\n\n\nPayment method selection\n\n\nShipping method selection\n\n\nProducts management (increase, decrease, empty cart...)\n\n\n\n\nAdmin\n #\n\n\n\n\nMain dashboard with some interesting metrics about your site\n\n\nCustomers management\n\n\nOrders management, with shipping and payment tracking\n\n\nProducts and Variants management, with some metrics and shared comments\n\n\nCategories management\n\n\nCoupons management\n\n\nMailing management\n\n\nStatic pages management\n\n\nApp store, with all your plugins\n\n\nPlugin management\n\n\nShipping methods management\n\n\nPayment methods management\n\n\nLanguages management\n\n\nCurrencies management\n\n\nStore customization panels", 
            "title": "Features"
        }, 
        {
            "location": "/book/features/#features", 
            "text": "This is the list of all features Bamboo offers you in its simple and basic\ninstallation. This list will grow over the time, and some features will be added\nby external plugins.", 
            "title": "Features"
        }, 
        {
            "location": "/book/features/#store", 
            "text": "Home page, with some products  Product page, with related products  Variant page, with related products  Cart page, with all your cart information  Login and Register infrastructure for customers  Customer administration page with Addresses management  Language selection  Currency selection", 
            "title": "Store"
        }, 
        {
            "location": "/book/features/#checkout-process", 
            "text": "Coupons appliance  Payment method selection  Shipping method selection  Products management (increase, decrease, empty cart...)", 
            "title": "Checkout process"
        }, 
        {
            "location": "/book/features/#admin", 
            "text": "Main dashboard with some interesting metrics about your site  Customers management  Orders management, with shipping and payment tracking  Products and Variants management, with some metrics and shared comments  Categories management  Coupons management  Mailing management  Static pages management  App store, with all your plugins  Plugin management  Shipping methods management  Payment methods management  Languages management  Currencies management  Store customization panels", 
            "title": "Admin"
        }, 
        {
            "location": "/book/", 
            "text": "Elcodi Book\n #\n\n\nWelcome to the Elcodi Book, specially designed for all Elcodi developers with\nthe single purpose of providing a solid base to start coding.\n\n\nFirst of all, some tips about the real meaning of Elcodi. Take your time in\nthese chapters. The more you understand our philosophy, the better you will code\nyour projects based on Elcodi.\n\n\n\n\nWhat is Elcodi\n\n\nWhy Elcodi\n\n\nPhilosophy\n\n\nStandards\n\n\n\n\nThen, some interesting topics about implementation and configuration. In this \nchapters you will understand how we have resolved some approaches and you can be\npart of it by adding your own business logic.\n\n\n\n\nQuick Start\n\n\nQuick Start using Vagrant\n\n\nFeatures\n\n\nProcesses\n\n\nCommands\n\n\nEmails\n\n\nDictionary\n\n\nEvents\n\n\nProduct Architecture\n\n\nCategory Architecture\n\n\nCart Architecture\n\n\nCoupon Architecture\n\n\nPlugins\n\n\nPayments\n\n\nShipping\n\n\n\n\nSome of our components can be used out of the box. They don't have specific\nE-commerce related business logic, so they can be described in an isolated way.\n\n\n\n\nEntity Translator\n\n\nMedia\n\n\nMenu\n\n\nSitemap\n\n\nState Transition Machine\n\n\nMetrics\n\n\nTemplate\n\n\n\n\nFinally, these chapters will help you about some extra elements related to the\nproject. Interesting if you want to, not only use Elcodi as an open source\nproject, but as a personal project, with the possibility of helping us growing\nand becoming better day by day\n\n\n\n\nTranslate Elcodi\n\n\nCookbook list\n\n\nRoadmap\n\n\nRunning tests suite\n\n\nPull Requests", 
            "title": "Home"
        }, 
        {
            "location": "/book/#elcodi-book", 
            "text": "Welcome to the Elcodi Book, specially designed for all Elcodi developers with\nthe single purpose of providing a solid base to start coding.  First of all, some tips about the real meaning of Elcodi. Take your time in\nthese chapters. The more you understand our philosophy, the better you will code\nyour projects based on Elcodi.   What is Elcodi  Why Elcodi  Philosophy  Standards   Then, some interesting topics about implementation and configuration. In this \nchapters you will understand how we have resolved some approaches and you can be\npart of it by adding your own business logic.   Quick Start  Quick Start using Vagrant  Features  Processes  Commands  Emails  Dictionary  Events  Product Architecture  Category Architecture  Cart Architecture  Coupon Architecture  Plugins  Payments  Shipping   Some of our components can be used out of the box. They don't have specific\nE-commerce related business logic, so they can be described in an isolated way.   Entity Translator  Media  Menu  Sitemap  State Transition Machine  Metrics  Template   Finally, these chapters will help you about some extra elements related to the\nproject. Interesting if you want to, not only use Elcodi as an open source\nproject, but as a personal project, with the possibility of helping us growing\nand becoming better day by day   Translate Elcodi  Cookbook list  Roadmap  Running tests suite  Pull Requests", 
            "title": "Elcodi Book"
        }, 
        {
            "location": "/book/payments/", 
            "text": "Payments\n #\n\n\nAll e-commerce, for sure, need to have a payment platform for completing the\nshopping workflow successfully.\n\n\nFor this integration or implementation, all kind of projects are used to working\nwith external PHP libraries, so in our case we are not going to be different at\nall (and because we believe in third party projects as well). In this example we\nwill work using a simple and free payment example, so the real meaning of these\nlines is showing you how to build your own payment library.\n\n\nRequirements\n #\n\n\nThis chapter is a little bit complex, so let's focus on some interesting topics\nrelated with Payments and this implementation. Some extra information will be\nenough to have a base before starting this read.\n\n\n\n\nPlugins\n\n\nDependency Injection Symfony Component\n\n\nEvent Dispatcher Symfony Component\n\n\nPaymentSuite Payment PHP Library\n\n\nPayum Payment PHP\n\n\n\n\nExample\n #\n\n\nLet's figure out that we want to add a new free payment module. This payment\nmethod will have a reference name called \nfree_payment\n, and even is not\nimportant at all what's the name, we will use it to detect how we should use the\nname, whatever it is, in our services and bundle implementation.\n\n\nOur payment method will be always available.\n\n\nCalling for Shipping methods\n #\n\n\nImagine that your cart is already completed and finished. Then it's time to pay\nit. Elcodi platform only provides you one single and easy way of collecting all\nthese methods.\n\n\nIt is important to understand that Elcodi will never consider throwing any kind\nof event related to any specific payment method neither any order paid related\none, so each integration should have their own events for that.\n\n\nIn other words, Elcodi only will provide a simple point of entry to the payment\nengine.\n\n\nAt the point we need to  want to collect all payment methods, we are going to\nuse the service created specifically for that.\n\n\n$paymentMethods = $this\n    -\nget('elcodi.wrapper.payment_methods')\n    -\nget($cart);\n\n\n\n\nInternally, this piece of code dispatches an event called \n\n\"payment.collect\"\n, responsible exclusively for\ncollecting all these payment methods.\n\n\nIt is necessary to say that at this point, the Event Dispatcher component is not\nworking in a very strict way it should work, so it's being used as a collector\nmanager instead of an event dispatcher. The difference between both is that an\nevent should be inmutable (an event just happends, and there's no much to be\ndone then... just add some reactions using event listeners), but in that case,\nthe object Event has a \nhasXXX\n method, so, even not being imortant the order\nof the listeners execution, the event is being modified on the fly. A changer\nevent... weird, right?\n\n\n\n\nImplement a collector\n\n\n\n\nAnyway, the recollection event is dispatched and all installed and initialized\nPlugins (in Kernel) are called to add some payment methods there.\n\n\nAdding new Payment Method\n #\n\n\nFor you, developer, that you want to add a payment method, that's your chapter.\nRemember the event \n\"shipping.collect\"\n? Well, we\nmust listen it in order to add new payment methods.\n\n\nSince now, none object is passed though the event in order to decide if a\npayment method is available or not, so only the plugin statement should be\nchecked.\n\n\nLet's take a look firstly how can we subscribe to this event using the same\nmethodology of subscribing any event.\n\n\nservices:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.free_payment.event_listener.payment_collect:\n        class: Elcodi\\Plugin\\FreePayment\\EventListener\\PaymentCollectEventListener\n        tags:\n            - { name: kernel.event_listener, event: payment.collect, method: addCustomPaymentMethods }\n\n\n\n\nGreat. In this Event Listener we should add all our business logic (of course,\nis much better to place all your business logic inside a service, but it depends\non your strategy). We'll doing like this in this example. Let's take a look.\n\n\nuse Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Class PaymentCollectEventListener\n */\nclass PaymentCollectEventListener\n{\n    /**\n     * Look for available payment methods\n     *\n     * @param PaymentCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomPaymentMethods(PaymentCollectionEvent $event)\n    {\n        $event\n            -\naddPaymentMethod(new PaymentMethod(\n                'free-payment',\n                'Your order for free!',\n                'You can buy whatever you want for free!',\n                'http://my-free-payment.com',\n                'http://my-free-payment.com/logo.png,\n                '\nscript\n/script\n'\n            ));\n    }\n}\n\n\n\n\nAs you can see, when we create a new instance of the object \nPaymentMethod\n you\ncan add some properties like \nurl\n, \nimageUrl\n and \nscript\n.\n\n\nnamespace Elcodi\\Component\\Payment\\Entity;\n\n/**\n * Class PaymentMethod\n */\nclass PaymentMethod\n{\n    /**\n     * Construct\n     *\n     * @param string $id          Id\n     * @param string $name        Name\n     * @param string $description Description\n     * @param string $url         Url\n     * @param string $imageUrl    Image url\n     * @param string $script      Script\n     */\n    public function __construct(\n        $id,\n        $name,\n        $description,\n        $url,\n        $imageUrl = '',\n        $script = ''\n    ) {\n        $this-\nid = $id;\n        $this-\nname = $name;\n        $this-\ndescription = $description;\n        $this-\nurl = $url;\n        $this-\nimageUrl = $imageUrl;\n        $this-\nscript = $script;\n    }\n}\n\n\n\n\nThis is because, in most cases, a payment platform, or in all middleware\nintegrations, we are used to working with one of these scenarios:\n\n\n\n\nThe platform proposes us an external url with an associated image. It is\ncommon to see this when our user must jump to another domain for the payment\naction. In that case, we should use both \nurl\n and \nimageUrl\n.\n\n\nThe platform provides us an script with HTML and some JS. This is used for\ninternal payment with some callable urls managed by the script itself. In that\ncase you should use \nscript\n and \nimageUrl\n.\n\n\n\n\nPayment scripts\n #\n\n\nTo work with platforms that require some HTML or JS to be used, then it is\ncommon and healthy to use Twig templating, instead of PHP variables.\n\n\nLet's see a little bit more complex example of how to use speciic scripts and\nthe router for the creation of routes.\n\n\nuse Symfony\\Bundle\\FrameworkBundle\\Templating\\EngineInterface;\nuse Symfony\\Component\\Form\\FormFactory;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n\nuse Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Class PaymentCollectEventListener\n */\nclass PaymentCollectEventListener\n{   \n    /**\n     * @var EngineInterface\n     *\n     * Twig engine\n     */\n    protected $templating;\n\n    /**\n     * @var FormFactory\n     *\n     * Form factory\n     */\n    protected $formFactory;\n\n    /**\n     * @var UrlGeneratorInterface\n     *\n     * Router\n     */\n    protected $router;\n\n    /**\n     * Construct\n     *\n     * @param EngineInterface $templating         Twig engine\n     * @param FormFactory     $formFactory        Form factory\n     * @param UrlGeneratorInterface $urlGenerator Url generator\n     */\n    public function __construct(\n        EngineInterface $templating,\n        FormFactory $formFactory,\n        UrlGeneratorInterface $urlGenerator\n    ) {\n        $this-\ntemplating = $templating;\n        $this-\nformFactory = $formFactory;\n        $this-\nurlGenerator = $urlGenerator;\n    }\n\n    /**\n     * Look for available payment methods\n     *\n     * @param PaymentCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomPaymentMethods(PaymentCollectionEvent $event)\n    {\n        /**\n         * If we need to create a new url\n         */\n        $url = $this\n            -\nurlGenerator\n            -\ngenerate('free_payment_url);\n\n        /**\n         * If we need to inject a custom view with a custom form view, then\n         * you must create both elements like is shown here\n         */\n        $form = $this\n            -\nformFactory\n            -\ncreate('free_payment_form_type')\n            -\ncreateView();\n\n        $view = $this\n            -\ntemplating\n            -\nrender('FreePaymentBundle:Payment:view.html.twig', [\n                'form' =\n $form,\n            ]);\n\n        $event\n            -\naddPaymentMethod(new PaymentMethod(\n                'free-payment',\n                'Your order for free!',\n                'You can buy whatever you want for free!',\n                $url,\n                'http://my-free-payment.com/logo.png,\n                $view\n            ));\n    }\n}\n\n\n\n\nAnd the Dependency Injection definition would be like this\n\n\nservices:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.free_payment.event_listener.payment_collect:\n        class: Elcodi\\Plugin\\FreePayment\\EventListener\\PaymentCollectEventListener\n        arguments:\n            - @templating\n            - @form.factory\n            - @router\n        tags:\n            - { name: kernel.event_listener, event: payment.collect, method: addCustomPaymentMethods }\n\n\n\n\nAccessing collected methods\n #\n\n\nOnce we have added all our payment methods, then we should be able to access all\nthe information in order to be able to offer all payment methods to the final\nuser.\n\n\nThis is a piece of code of our template.\n\n\ndiv class=\nform-checkout\n\n    {% for paymentMethod in paymentMethods %}\n        {% set paymentMethodName = paymentMethod.name %}\n        {% if paymentMethod.url %}\n                \nh2\n{{ paymentMethodName|trans }}\n/h2\n\n                \np\na href=\n{{ paymentMethod.url }}\n class=\nbutton button-secondary\n{{ 'template.store_template_bundle.checkout.payment.continue'|trans }}\n/a\n/p\n\n                \nhr /\n\n        {% else %}\n            \ndetails class=\ntest-payment-{{ paymentMethod.id }} form form-{{ paymentMethodName|trans|lower }}\n\n                \nsummary\n{{ paymentMethodName|trans }}\n/summary\n\n                \ndiv class=\npayment-wrapper\n\n                    {{ paymentMethod.script|raw }}\n                \n/div\n\n            \n/details\n\n        {% endif %}\n\n    {% endfor %}\n\n/div\n\n\n\n\n\nAs you can see in both cases (with and without script), each element of the\narray named \npaymentMethods\n is a payment method instance inserted by each\nPayment integration plugin previously.\n\n\nAnother way to access the payment methods directly from the templating layer is\nusing the Twig function.\n\n\n{% set paymentMethods = elcodi_payment_methods() %}\n\n\n\n\nPayment\n #\n\n\nAs said before, each platform should take care about the payment process. Of \ncourse, only one strict action must be done in this process, and this is the\ntransformation of the cart to a valid order.\n\n\nThis action is not responsibility of the payment platform at all, but it should\ndispatch the change by using one available service.\n\n\n$cart = $this\n    -\ncartWrapper\n    -\nget();\n\n$order = $this\n    -\ncontainer\n    -\nget('elcodi.transformer.cart_order')\n    -\ncreateOrderFromCart($cart);\n\n\n\n\nPayment State Machine\n #\n\n\nAt this point, the order is ready to be shipped. Once starting these last steps\non this documentation, please take a look at the State Transition Machine \ndocumentation.\n\n\n\n\nState Transition Machine\n\n\n\n\nBamboo. by default, proposes a payment state diagram like we can see here.\n\n\n\n\n\n\n\n\nFrom\n\n\nAction\n\n\nTo\n\n\n\n\n\n\n\n\n\n\nunpaid\n\n\npay\n\n\npaid\n\n\n\n\n\n\npaid\n\n\nrefund\n\n\nrefunded\n\n\n\n\n\n\n\n\nand through the Symfony Container we have access to some specific objects of the\nPayment State Machine.\n\n\n#\n# Order state machine for Shipping\n#\nelcodi.order_payment_states_machine_builder:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineBuilder\n    arguments:\n        - @elcodi.factory.state_transition_machine\n        - %elcodi.order_payment_states_machine_identifier%\n        - %elcodi.order_payment_states_machine_states%\n        - %elcodi.order_payment_states_machine_point_of_entry%\n\nelcodi.order.payment_states_machine:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\Machine\n    factory:\n        - @elcodi.order_payment_states_machine_builder\n        - compile\n\nelcodi.order_payment_states_machine_manager:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineManager\n    arguments:\n        - @elcodi.order.payment_states_machine\n        - @event_dispatcher\n        - @elcodi.factory.state_transition_machine_state_line\n\n\n\n\nUpdating the Payment state\n #\n\n\nWith this access to the Payment State Machine, we can change the state of an\nOrder by using the service \nelcodi.order_payment_states_machine\n.\n\n\nLet's see an example of how to go to the state called \npaid\n, taking in account\nthat our actual state is called \nunpaid\n.\n\n\n$order = // Order instance;\n\n$stateLineStack = $this\n    -\nget('elcodi.order_payment_states_machine_manager')\n    -\ntransition(\n        $order,\n        $order-\ngetPaymentStateLineStack(),\n        'paid',\n        'Order paid by credit cart'\n    );\n\n$order-\nsetPaymentStateLineStack($stateLineStack);\n$this\n    -\nget('elcodi.object_manager.order')\n    -\nflush($order);\n\n\n\n\nOnly if given transition is possible all is going to work properly. Otherwise\nsome Exceptions will be thrown.", 
            "title": "Payments"
        }, 
        {
            "location": "/book/payments/#payments", 
            "text": "All e-commerce, for sure, need to have a payment platform for completing the\nshopping workflow successfully.  For this integration or implementation, all kind of projects are used to working\nwith external PHP libraries, so in our case we are not going to be different at\nall (and because we believe in third party projects as well). In this example we\nwill work using a simple and free payment example, so the real meaning of these\nlines is showing you how to build your own payment library.", 
            "title": "Payments"
        }, 
        {
            "location": "/book/payments/#requirements", 
            "text": "This chapter is a little bit complex, so let's focus on some interesting topics\nrelated with Payments and this implementation. Some extra information will be\nenough to have a base before starting this read.   Plugins  Dependency Injection Symfony Component  Event Dispatcher Symfony Component  PaymentSuite Payment PHP Library  Payum Payment PHP", 
            "title": "Requirements"
        }, 
        {
            "location": "/book/payments/#example", 
            "text": "Let's figure out that we want to add a new free payment module. This payment\nmethod will have a reference name called  free_payment , and even is not\nimportant at all what's the name, we will use it to detect how we should use the\nname, whatever it is, in our services and bundle implementation.  Our payment method will be always available.", 
            "title": "Example"
        }, 
        {
            "location": "/book/payments/#calling-for-shipping-methods", 
            "text": "Imagine that your cart is already completed and finished. Then it's time to pay\nit. Elcodi platform only provides you one single and easy way of collecting all\nthese methods.  It is important to understand that Elcodi will never consider throwing any kind\nof event related to any specific payment method neither any order paid related\none, so each integration should have their own events for that.  In other words, Elcodi only will provide a simple point of entry to the payment\nengine.  At the point we need to  want to collect all payment methods, we are going to\nuse the service created specifically for that.  $paymentMethods = $this\n    - get('elcodi.wrapper.payment_methods')\n    - get($cart);  Internally, this piece of code dispatches an event called  \"payment.collect\" , responsible exclusively for\ncollecting all these payment methods.  It is necessary to say that at this point, the Event Dispatcher component is not\nworking in a very strict way it should work, so it's being used as a collector\nmanager instead of an event dispatcher. The difference between both is that an\nevent should be inmutable (an event just happends, and there's no much to be\ndone then... just add some reactions using event listeners), but in that case,\nthe object Event has a  hasXXX  method, so, even not being imortant the order\nof the listeners execution, the event is being modified on the fly. A changer\nevent... weird, right?   Implement a collector   Anyway, the recollection event is dispatched and all installed and initialized\nPlugins (in Kernel) are called to add some payment methods there.", 
            "title": "Calling for Shipping methods"
        }, 
        {
            "location": "/book/payments/#adding-new-payment-method", 
            "text": "For you, developer, that you want to add a payment method, that's your chapter.\nRemember the event  \"shipping.collect\" ? Well, we\nmust listen it in order to add new payment methods.  Since now, none object is passed though the event in order to decide if a\npayment method is available or not, so only the plugin statement should be\nchecked.  Let's take a look firstly how can we subscribe to this event using the same\nmethodology of subscribing any event.  services:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.free_payment.event_listener.payment_collect:\n        class: Elcodi\\Plugin\\FreePayment\\EventListener\\PaymentCollectEventListener\n        tags:\n            - { name: kernel.event_listener, event: payment.collect, method: addCustomPaymentMethods }  Great. In this Event Listener we should add all our business logic (of course,\nis much better to place all your business logic inside a service, but it depends\non your strategy). We'll doing like this in this example. Let's take a look.  use Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Class PaymentCollectEventListener\n */\nclass PaymentCollectEventListener\n{\n    /**\n     * Look for available payment methods\n     *\n     * @param PaymentCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomPaymentMethods(PaymentCollectionEvent $event)\n    {\n        $event\n            - addPaymentMethod(new PaymentMethod(\n                'free-payment',\n                'Your order for free!',\n                'You can buy whatever you want for free!',\n                'http://my-free-payment.com',\n                'http://my-free-payment.com/logo.png,\n                ' script /script '\n            ));\n    }\n}  As you can see, when we create a new instance of the object  PaymentMethod  you\ncan add some properties like  url ,  imageUrl  and  script .  namespace Elcodi\\Component\\Payment\\Entity;\n\n/**\n * Class PaymentMethod\n */\nclass PaymentMethod\n{\n    /**\n     * Construct\n     *\n     * @param string $id          Id\n     * @param string $name        Name\n     * @param string $description Description\n     * @param string $url         Url\n     * @param string $imageUrl    Image url\n     * @param string $script      Script\n     */\n    public function __construct(\n        $id,\n        $name,\n        $description,\n        $url,\n        $imageUrl = '',\n        $script = ''\n    ) {\n        $this- id = $id;\n        $this- name = $name;\n        $this- description = $description;\n        $this- url = $url;\n        $this- imageUrl = $imageUrl;\n        $this- script = $script;\n    }\n}  This is because, in most cases, a payment platform, or in all middleware\nintegrations, we are used to working with one of these scenarios:   The platform proposes us an external url with an associated image. It is\ncommon to see this when our user must jump to another domain for the payment\naction. In that case, we should use both  url  and  imageUrl .  The platform provides us an script with HTML and some JS. This is used for\ninternal payment with some callable urls managed by the script itself. In that\ncase you should use  script  and  imageUrl .", 
            "title": "Adding new Payment Method"
        }, 
        {
            "location": "/book/payments/#payment-scripts", 
            "text": "To work with platforms that require some HTML or JS to be used, then it is\ncommon and healthy to use Twig templating, instead of PHP variables.  Let's see a little bit more complex example of how to use speciic scripts and\nthe router for the creation of routes.  use Symfony\\Bundle\\FrameworkBundle\\Templating\\EngineInterface;\nuse Symfony\\Component\\Form\\FormFactory;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n\nuse Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Payment\\Entity\\PaymentMethod;\nuse Elcodi\\Component\\Payment\\Event\\PaymentCollectionEvent;\n\n/**\n * Class PaymentCollectEventListener\n */\nclass PaymentCollectEventListener\n{   \n    /**\n     * @var EngineInterface\n     *\n     * Twig engine\n     */\n    protected $templating;\n\n    /**\n     * @var FormFactory\n     *\n     * Form factory\n     */\n    protected $formFactory;\n\n    /**\n     * @var UrlGeneratorInterface\n     *\n     * Router\n     */\n    protected $router;\n\n    /**\n     * Construct\n     *\n     * @param EngineInterface $templating         Twig engine\n     * @param FormFactory     $formFactory        Form factory\n     * @param UrlGeneratorInterface $urlGenerator Url generator\n     */\n    public function __construct(\n        EngineInterface $templating,\n        FormFactory $formFactory,\n        UrlGeneratorInterface $urlGenerator\n    ) {\n        $this- templating = $templating;\n        $this- formFactory = $formFactory;\n        $this- urlGenerator = $urlGenerator;\n    }\n\n    /**\n     * Look for available payment methods\n     *\n     * @param PaymentCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomPaymentMethods(PaymentCollectionEvent $event)\n    {\n        /**\n         * If we need to create a new url\n         */\n        $url = $this\n            - urlGenerator\n            - generate('free_payment_url);\n\n        /**\n         * If we need to inject a custom view with a custom form view, then\n         * you must create both elements like is shown here\n         */\n        $form = $this\n            - formFactory\n            - create('free_payment_form_type')\n            - createView();\n\n        $view = $this\n            - templating\n            - render('FreePaymentBundle:Payment:view.html.twig', [\n                'form' =  $form,\n            ]);\n\n        $event\n            - addPaymentMethod(new PaymentMethod(\n                'free-payment',\n                'Your order for free!',\n                'You can buy whatever you want for free!',\n                $url,\n                'http://my-free-payment.com/logo.png,\n                $view\n            ));\n    }\n}  And the Dependency Injection definition would be like this  services:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.free_payment.event_listener.payment_collect:\n        class: Elcodi\\Plugin\\FreePayment\\EventListener\\PaymentCollectEventListener\n        arguments:\n            - @templating\n            - @form.factory\n            - @router\n        tags:\n            - { name: kernel.event_listener, event: payment.collect, method: addCustomPaymentMethods }", 
            "title": "Payment scripts"
        }, 
        {
            "location": "/book/payments/#accessing-collected-methods", 
            "text": "Once we have added all our payment methods, then we should be able to access all\nthe information in order to be able to offer all payment methods to the final\nuser.  This is a piece of code of our template.  div class= form-checkout \n    {% for paymentMethod in paymentMethods %}\n        {% set paymentMethodName = paymentMethod.name %}\n        {% if paymentMethod.url %}\n                 h2 {{ paymentMethodName|trans }} /h2 \n                 p a href= {{ paymentMethod.url }}  class= button button-secondary {{ 'template.store_template_bundle.checkout.payment.continue'|trans }} /a /p \n                 hr / \n        {% else %}\n             details class= test-payment-{{ paymentMethod.id }} form form-{{ paymentMethodName|trans|lower }} \n                 summary {{ paymentMethodName|trans }} /summary \n                 div class= payment-wrapper \n                    {{ paymentMethod.script|raw }}\n                 /div \n             /details \n        {% endif %}\n\n    {% endfor %} /div   As you can see in both cases (with and without script), each element of the\narray named  paymentMethods  is a payment method instance inserted by each\nPayment integration plugin previously.  Another way to access the payment methods directly from the templating layer is\nusing the Twig function.  {% set paymentMethods = elcodi_payment_methods() %}", 
            "title": "Accessing collected methods"
        }, 
        {
            "location": "/book/payments/#payment", 
            "text": "As said before, each platform should take care about the payment process. Of \ncourse, only one strict action must be done in this process, and this is the\ntransformation of the cart to a valid order.  This action is not responsibility of the payment platform at all, but it should\ndispatch the change by using one available service.  $cart = $this\n    - cartWrapper\n    - get();\n\n$order = $this\n    - container\n    - get('elcodi.transformer.cart_order')\n    - createOrderFromCart($cart);", 
            "title": "Payment"
        }, 
        {
            "location": "/book/payments/#payment-state-machine", 
            "text": "At this point, the order is ready to be shipped. Once starting these last steps\non this documentation, please take a look at the State Transition Machine \ndocumentation.   State Transition Machine   Bamboo. by default, proposes a payment state diagram like we can see here.     From  Action  To      unpaid  pay  paid    paid  refund  refunded     and through the Symfony Container we have access to some specific objects of the\nPayment State Machine.  #\n# Order state machine for Shipping\n#\nelcodi.order_payment_states_machine_builder:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineBuilder\n    arguments:\n        - @elcodi.factory.state_transition_machine\n        - %elcodi.order_payment_states_machine_identifier%\n        - %elcodi.order_payment_states_machine_states%\n        - %elcodi.order_payment_states_machine_point_of_entry%\n\nelcodi.order.payment_states_machine:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\Machine\n    factory:\n        - @elcodi.order_payment_states_machine_builder\n        - compile\n\nelcodi.order_payment_states_machine_manager:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineManager\n    arguments:\n        - @elcodi.order.payment_states_machine\n        - @event_dispatcher\n        - @elcodi.factory.state_transition_machine_state_line", 
            "title": "Payment State Machine"
        }, 
        {
            "location": "/book/payments/#updating-the-payment-state", 
            "text": "With this access to the Payment State Machine, we can change the state of an\nOrder by using the service  elcodi.order_payment_states_machine .  Let's see an example of how to go to the state called  paid , taking in account\nthat our actual state is called  unpaid .  $order = // Order instance;\n\n$stateLineStack = $this\n    - get('elcodi.order_payment_states_machine_manager')\n    - transition(\n        $order,\n        $order- getPaymentStateLineStack(),\n        'paid',\n        'Order paid by credit cart'\n    );\n\n$order- setPaymentStateLineStack($stateLineStack);\n$this\n    - get('elcodi.object_manager.order')\n    - flush($order);  Only if given transition is possible all is going to work properly. Otherwise\nsome Exceptions will be thrown.", 
            "title": "Updating the Payment state"
        }, 
        {
            "location": "/book/philosophy/", 
            "text": "Elcodi Philosophy\n #\n\n\nOne of the questions we are very used to responding is... why Elcodi and not any\nother possible options?\n\n\nThis question is indeed bad formulated, so we've never based our philosophy in\nbeing different from the others in a very explicit way, so the project just was\nborn thanks that, some years ago, none of the existing options filfilled our \nneeds as a company and as a client. So, because of that, we decided to create a\nnew way of coding an E-commerce product.\n\n\nWe named it Elcodi.\n\n\nFor starting this chapter is fair enough to say that Elcodi goes a little futher\nthan a simple technological solution, so the basic needs of any technical\ndepartment are not covered only with a repository full of PHP code lines.\nIn Elcodi we aim to create a small foundation of thoughts and reflections\nrelated completely with the code quality, with the software architecture and\nwith the open source, on top of pragmatism.\n\n\nWe bring you here some small topics.\n\n\nClean Code\n #\n\n\nYes. Clean Code. How super cool is saying \nclean code\n, right? As developers \nwe've heard this expression hundreds of times, and seems that we never give it \nenough importance to what really means Clean Code on open source. The real \nmeaning is the base of our principles, and for that reason all our code (at \nleast that's our goal) must be enough clean, neat, organized and documented to\nmake it understandable by every single developer working on Elcodi.\n\n\n\n\nBut the code should be self-explained!\n\n\nIndeed. That makes reference to the code quality. Variables well named, code\nwell structured (not everything in the same line, for example), well designed\nblocks and classes and methods well named as well. Have you ever heard speak on\nthe context change problem? Clean Code should cover this topic as well.\n\n\n\n\nImagine that a developer is working with Elcodi as a dependency in his vendor\nfolder. As a developer, he should focus only in what is really important for\nhim, his business logic. The other code related to his work should be enough\nclear, easy and fast to comprehend in order to focus as less as possible the\ndeveloper.\n\n\nAnd you know what? People is intended to understand better the human language\nthan the code itself. This means that if you can provide an easy comprehension\nlayer for anyone that only what to know something about a class or a method,\nthen why not? You're reducing this annoying cost of focus change.\n\n\n\n\nWith PHPDoc documentation, both in terms of class responsibility and method\ndefinition\n\n\nWith a great definition of method input and output\n\n\nWith an even better nomenclature of methods\n\n\nUsing normalization as much as possible\n\n\nUsing PSR standards\n\n\n\n\nOf course, all non-code-related must be removed in order to no create visual\nnoise and to not introduce ambiguity.\n\n\nReal pragmatism\n #\n\n\nWe assume that to reach a goal there are always many ways. Some of them are can\nbe considered as good ways and could be treated as such. That's because each\npossible implementation is the combination of a theoretical base and a set of\nexternal realities far from being idyllic, for example, time, requirements and \nresources.\n\n\nIn Elcodi we think that these unfavorable conditions are always present around\nus, so we have been working so far by simplifying and improving the user\nexperience, without forgetting about the complexity and the completeness of the\nfinal project.\n\n\nWhat does it really means?\n\n\n\n\nWe want our code to be as much readable and understandable as possible\n\n\nWe fled from complex architectures, forgetting about these structures that can\nbe too difficult for most part of the developers\n\n\nWe are mainly focused on providing a grateful and kind experience. We want,\nand is one of our most important points, reduce and mitigate the pain when\nworking with E-commerce.\n\n\nWe are a Community-first project. This means that we are aware of how\ndifficult is starting with a new technology. We will there with you.\n\n\n\n\nWe work so hard to bring to the community the possibility to have a big voice.\nWe listen them everyday to concrete our roadmap, so they can actively\nparticipate to the progress of the project\n\n\nCommunity first\n #\n\n\nOne of our virtues is that the project was born from the community, we exist\nbecause of the community and we strongly think that the community will be, at\nthe end, what will make Elcodi a successful project\n\n\nEach developer interested in our project is (and will always be) a great\nopportunity for us to improve our work, so it worth spending some time helping\npeople with the project, evangelizing our point of view, our way of doing and\nsharing lot of knowledge and fun.\n\n\nWe spend part of our effort in creating new projects based in Elcodi, feeding\nthe community with new use cases, with new motivated developers on growing with\nour philosophy and bringing people new and stronger reasons to share this path\nwith us.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/book/philosophy/#elcodi-philosophy", 
            "text": "One of the questions we are very used to responding is... why Elcodi and not any\nother possible options?  This question is indeed bad formulated, so we've never based our philosophy in\nbeing different from the others in a very explicit way, so the project just was\nborn thanks that, some years ago, none of the existing options filfilled our \nneeds as a company and as a client. So, because of that, we decided to create a\nnew way of coding an E-commerce product.  We named it Elcodi.  For starting this chapter is fair enough to say that Elcodi goes a little futher\nthan a simple technological solution, so the basic needs of any technical\ndepartment are not covered only with a repository full of PHP code lines.\nIn Elcodi we aim to create a small foundation of thoughts and reflections\nrelated completely with the code quality, with the software architecture and\nwith the open source, on top of pragmatism.  We bring you here some small topics.", 
            "title": "Elcodi Philosophy"
        }, 
        {
            "location": "/book/philosophy/#clean-code", 
            "text": "Yes. Clean Code. How super cool is saying  clean code , right? As developers \nwe've heard this expression hundreds of times, and seems that we never give it \nenough importance to what really means Clean Code on open source. The real \nmeaning is the base of our principles, and for that reason all our code (at \nleast that's our goal) must be enough clean, neat, organized and documented to\nmake it understandable by every single developer working on Elcodi.   But the code should be self-explained!  Indeed. That makes reference to the code quality. Variables well named, code\nwell structured (not everything in the same line, for example), well designed\nblocks and classes and methods well named as well. Have you ever heard speak on\nthe context change problem? Clean Code should cover this topic as well.   Imagine that a developer is working with Elcodi as a dependency in his vendor\nfolder. As a developer, he should focus only in what is really important for\nhim, his business logic. The other code related to his work should be enough\nclear, easy and fast to comprehend in order to focus as less as possible the\ndeveloper.  And you know what? People is intended to understand better the human language\nthan the code itself. This means that if you can provide an easy comprehension\nlayer for anyone that only what to know something about a class or a method,\nthen why not? You're reducing this annoying cost of focus change.   With PHPDoc documentation, both in terms of class responsibility and method\ndefinition  With a great definition of method input and output  With an even better nomenclature of methods  Using normalization as much as possible  Using PSR standards   Of course, all non-code-related must be removed in order to no create visual\nnoise and to not introduce ambiguity.", 
            "title": "Clean Code"
        }, 
        {
            "location": "/book/philosophy/#real-pragmatism", 
            "text": "We assume that to reach a goal there are always many ways. Some of them are can\nbe considered as good ways and could be treated as such. That's because each\npossible implementation is the combination of a theoretical base and a set of\nexternal realities far from being idyllic, for example, time, requirements and \nresources.  In Elcodi we think that these unfavorable conditions are always present around\nus, so we have been working so far by simplifying and improving the user\nexperience, without forgetting about the complexity and the completeness of the\nfinal project.  What does it really means?   We want our code to be as much readable and understandable as possible  We fled from complex architectures, forgetting about these structures that can\nbe too difficult for most part of the developers  We are mainly focused on providing a grateful and kind experience. We want,\nand is one of our most important points, reduce and mitigate the pain when\nworking with E-commerce.  We are a Community-first project. This means that we are aware of how\ndifficult is starting with a new technology. We will there with you.   We work so hard to bring to the community the possibility to have a big voice.\nWe listen them everyday to concrete our roadmap, so they can actively\nparticipate to the progress of the project", 
            "title": "Real pragmatism"
        }, 
        {
            "location": "/book/philosophy/#community-first", 
            "text": "One of our virtues is that the project was born from the community, we exist\nbecause of the community and we strongly think that the community will be, at\nthe end, what will make Elcodi a successful project  Each developer interested in our project is (and will always be) a great\nopportunity for us to improve our work, so it worth spending some time helping\npeople with the project, evangelizing our point of view, our way of doing and\nsharing lot of knowledge and fun.  We spend part of our effort in creating new projects based in Elcodi, feeding\nthe community with new use cases, with new motivated developers on growing with\nour philosophy and bringing people new and stronger reasons to share this path\nwith us.", 
            "title": "Community first"
        }, 
        {
            "location": "/book/plugins/", 
            "text": "Plugins\n #\n\n\nCreate, install and manage several plugins in your Bamboo installation.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nWe want to introduce you what is a Plugin when we talk about Elcodi. Indeed,\nthis question has a very fast abstract answer that will, surely, give you some\nextra calmness.\n\n\nA Plugin is a Bundle.\n\n\nYes, when we talk about Plugins, we talk about Symfony Bundles, with a simple \nand pre-defined specification. And is this specification what we will show you\nproperly, in order to help you understanding existing plugins and composing new\nones.\n\n\nWhat is a Bundle?\n #\n\n\nLike any Bundle, a Plugin needs to have its own Bundle class. This is usually\nplaced in the root of the bundle, and should be called as much specifically as\npossible, in order to avoid collisions.\n\n\n\n\nEven if two bundles share the same name, the uniqueness of each Plugin is \ndefined by its namespace, so even in this scenario, your Elcodi installation\nwill work properly.\n\n\n\n\nLet's see an example of a bundle. We will work along this document with our\nfirst Plugin, the DisqusBundle.\n\n\nnamespace Elcodi\\Plugin\\DisqusBundle;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Component\\Plugin\\Interfaces\\PluginInterface;\n\n/**\n * Class ElcodiDisqusBundle\n */\nclass ElcodiDisqusBundle extends Bundle implements PluginInterface\n{\n    // ...\n}\n\n\n\n\nImplementing \nPluginInterface\n is the way the kernel has to identify if a bundle\nhas to be treated as a Plugin\n\n\nWhy plugins?\n #\n\n\nThat's one of the most important parts of our philosophy. We will give some \nreasons to have a plugin-driven design.\n\n\n\n\nBecause you will design decoupled from the core. This means that, if you\nupdate Elcodi and Bamboo with new features (remember, using semantic version),\nthere wont be the possibility to have conflicts. You only develop your own \nplugins, based on the master project.\n\n\nBecause you can share. If you overwrite some parts of the project proposing\nnew business logic, and if you take care about related documentation, then you\ncan share your work, and even sell it.\n\n\nBecause will help you with the development of the package. Your code will be\ncleaner and more testable... and this is always good news.\n\n\nBecause you will follow Elcodi style. All these proposed reasons is what makes\nElcodi a good project to work with. Following our structure will help this\necosystem to grow day by day, and this is what will make Elcodi a successful \nproject indeed.\n\n\n\n\nPlugin dependencies\n #\n\n\nAll plugins are extending the main project, but some of them have some \ndependencies. Remember that Elcodi has it's own bundle dependencies resolver.\nPlease, read careful this chapter in order to understand how to define properly\nthese dependencies.\n\n\nHow to Install dependent Bundles\n\n\nPlugin definition\n #\n\n\nThere is a very simple way to define a Plugin. What is the name of the plugin, \nwhat are the fields that will configure it, and some more information is what\nyou will have to place in the \nplugin.yml\n file.\n\n\n\n\nThis file must be placed in the root of the Bundle\n\n\n\n\nLet's see an example of how the DisqusPlugin is configured.\n\n\nplugin:\n    type: plugin\n    category: comments\n    name: Discuss\n    description: |\n        Disqus integration for your shop\n    fa_icon: comment-o\n    fields:\n        disqus_identifier:\n            type: text\n            label: elcodi_plugin.disqus.disqus_identifier\n        disqus_enabled_product:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_product\n        disqus_enabled_blog_post:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_blog_post\n\n\n\n\nEach definition is considered as a configuration element, and all these are\navailable.\n\n\n\n\ntype: You must define your Plugin as a simple plugin or as a template. Of \ncourse this value is required. Available values are \nplugin\n or \ntemplate\n.\n\n\ncategory: You can tag it as well using a specific category. Each category is\nmeant to be treated in a different specific way. Specific and useful values\nare \npayment\n, \nshipping\n and \nsocial\n. If none value is specified, then will\nnot belong to any category.\n\n\nname: The name of your plugin\n\n\nvisible: This plugin will be visible for its configuration. By default, this\nvalue is set as true.\n\n\nfa_icon: Icon used, following the \nAwesome Fonts\n \nformat\n\n\ndescription: Plugin description\n\n\nfields: Set of configurable fields\n\n\n\n\nPlugin fields\n #\n\n\nWhat is a field? Well, your plugins may require some values to be stored in\nyour database related to the plugin. For example, an \napi_public_key\n or a \nsimple \nusername\n.\n\n\nThese values are stored in a plain way, and because is important to make easy\nthe management of these values, Bamboo will provide automatically your Plugin\nconfiguration page, only by defining how these fields should be created. These\nare all possibilities\n\n\n\n\ntype: Type of the field. This value will be used as field type in form\n\n\nrequired: This field must be configured in order to use this plugin\n\n\ndata: The value of the field\n\n\nlabel: Label of the field (You can use translations)\n\n\noptions: Array of options, needed if your field is checkbox or radio.\n\n\nattr: Array of attributes\n\n\n\n\nLet's see an example. If our plugin require a text field called username...\n\n\nplugin:\n    type: plugin\n    category: social\n    name: Twitter\n    description: |\n        Twitter integration for your shop\n    fa_icon: twitter-o\n    fields:\n        username:\n            type: text\n            label: elcodi_plugin.twitter.username\n            required: true\n\n\n\n\nWith this example, your Bamboo installation will provide you a nice page with\na very simple way of defining the twitter username.\n\n\nA little bit later you will find the way of retrieving these values. \n\n\nDependency Injection\n #\n\n\nA plugin is a Bundle, remember? This means that you should define a set of \nservices in the same way you do when you create your amazing bundles.\n\n\nYou can follow the Elcodi way by reading some cookbooks in this documentation,\nso you will make sure that everybody will understand more easily what you're \ntrying to do.\n\n\n\n\nHow to install dependent Bundles\n\n\nExtensions\n\n\nSome Dependency Injection standards\n\n\n\n\nRemember to follow some of our philosophy. Small services and well defined.\nClean code is important. This part is the most important part of your Plugin.\nPreserve each service responsibility and be sure everyone will understand what\nis all services purpose.\n\n\nPlugin as a service\n #\n\n\nSometimes you need to inject your plugin, right? Well, you can do that as long\nas you can reach your plugin using the \nPluginRepository\n and you can define the\nresult content as a service.\n\n\nservices:\n\n    #\n    # Plugin\n    #\n    elcodi_plugin.disqus:\n        parent: elcodi.abstract_plugin\n        arguments:\n            - \nElcodi\\\\Plugin\\\\DisqusBundle\\\\ElcodiDisqusBundle\n\n\n\n\n\nYou need to be as specific as possible to avoid collisions between different \nbundles. Of course you can not determine that your Disqus plugin will be the \nonly one installable, so has no sense to name your plugin service \ndisqus\n, but\nmaybe something like that... \n{my_organization}_elcodi_plugin.disqus\n\n\nOnce you have your service, then you can do that.\n\n\nservices:\n\n    #\n    # Twig renderer\n    #\n    elcodi_plugin.disqus.renderer:\n        class: Elcodi\\Plugin\\DisqusBundle\\Templating\\TwigRenderer\n        calls:\n            - [setPlugin, [@elcodi_plugin.disqus]]\n\n\n\n\nIn your class, then you receive your plugin object (plugin entity). Let's see an\nexample about what this class allows you to manage.\n\n\nuse Elcodi\\Component\\Plugin\\Entity\\Plugin;\n\n/**\n * Class MyService\n */\nclass MyService\n{\n    /**\n     * @var Plugin\n     *\n     * Plugin\n     */\n    protected $plugin;\n\n    /**\n     * Construct\n     *\n     * @param Plugin $plugin Plugin\n     */\n    public function __construct(Plugin $plugin) \n    {\n        $this-\nplugin = $plugin;\n    }\n    /**\n     * Add Stripe payment method\n     *\n     * @param PaymentCollectionEvent $event Event\n     */\n    public function addStripePaymentMethod(PaymentCollectionEvent $event)\n    {\n        if ($this\n            -\nplugin\n            -\nisUsable([\n                'private_key',\n                'public_key',\n            ])\n        ) {\n            // I can do whatever I want here. My plugin is usable!\n        }\n    }\n}\n\n\n\n\nEach plugin has some interesting public methods. Let's see some of them\n\n\ngetConfigurationValue()\n #\n\n\nYou require a configuration element. Please, see the full list in the Plugin\ndefinition chapter.\n\n\n$pluginCategory = $this\n    -\nplugin\n    -\ngetConfigurationValue('category');\n\n\n\n\ngetFieldValue()\n #\n\n\nRemember our last example? We configured one field called username for our\nTwitter plugin, right? Well, let's get the username value by using this cool\nmethod.\n\n\n$username = $this\n    -\nplugin\n    -\ngetField('username');\n\n\n\n\ngetField()\n #\n\n\nSometimes you need to fetch all the field data, including it's definition and\nvalue. Then, you can use this method. You receive an array with all the data, \nand the value is always placed in the hash position with name \ndata\n.\n\n\n$usernameField = $this\n    -\nplugin\n    -\ngetField('username');\n\n$username = $usernameField['data'];\n\n\n\n\ngetFields()\n #\n\n\nIf you need all plugin's fields as an array, then you can call this public\nmethod. You receibe an array of fields, so you have to access the same way than\nbefore.\n\n\n$allFields = $this\n    -\nplugin\n    -\ngetFields();\n\n$username = $allFields['username']['data'];\n\n\n\n\ngetFieldValues()\n #\n\n\nYou can request as well all fields with their values using a simple key-value\nstructure, being the key the name of the field and the value, the value of the \nfield. If this is what you need, then use this method.\n\n\n$allValues = $this\n    -\nplugin\n    -\ngetFieldValues();\n\n$username = getFieldValues['username'];\n\n\n\n\nisUsable\n #\n\n\nYou can check if a Plugin is usable by checking that is enabled and that a set\nof defined fields are fulfilled. A field is fulfilled when is not required or\nis required and the field is not empty.\n\n\nIf you don't pass any field, then \nenabled\n field is checked.\n\n\n$isUsable = $this\n    -\nplugin\n    -\nisUsable(['username']);\n\n\n\n\nIn this example, and because the twitter plugin should not work unless the \nusername is set (username field is defined as required), then will return true\nonly if the plugin itself is enabled and the field username is not empty.\n\n\nguessIsUsable\n #\n\n\nWell, all this work can be done automatically, without need to define all\nfields. So if you use this method, then all fields will be checked, so a plugin\nwill be usable only if is usable using all plugin fields.\n\n\nThat means that all required fields defined in the plugin configuration must\nhave a value.\n\n\n$isUsable = $this\n    -\nplugin\n    -\ngessIsUsable();\n\n\n\n\nIn this example, and because our twitter plugin only have one single field and\nis required, the result will be exactly the same than the last piece of code.\n\n\nInstalling your Plugin\n #\n\n\nYou can do that using the command console by using the \nelcodi:plugins:load\n\ncommand. If you have configured your plugin the right way, then you should have\nyour Plugin configuration panel in the admin side.\n\n\nHow to Install a plugin\n\n\nAfter loading the plugin, of course, you need to add it in your AppKernel file.\nBecause some plugins have dependencies and because it's main mission is \noverwriting logic, you should instantiate them at the end of the class.\n\n\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\HttpKernel\\Kernel;\nuse Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface;\n\nuse Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends Kernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Returns an array of bundles to register.\n     *\n     * @return BundleInterface[] An array of bundle instances.\n     *\n     * @api\n     */\n    public function registerBundles()\n    {\n        $bundles = array(\n\n            /**\n             * All Symfony, Bamboo and Elcodi bundles\n             * with their dependencies\n             */\n\n            // ...\n\n            /**\n             * Elcodi Plugins\n             */\n            new My\\Elcodi\\Plugin(),\n            new My\\Second\\Elcodi\\Plugin(),\n        );\n\n        return $this\n            -\ngetBundleInstances(\n                $this,\n                $bundles\n            );\n    }\n}\n\n\n\n\nOverwriting model\n #\n\n\nOne of the main goals of a plugin is overwriting the model. Of course you will\nhave to overwrite your desired entities, and old ones will not be used anymore\nas the main entity (unless you extend them, of course).\n\n\nYou can take a look at these chapters in order to understand properly how easy\nis overwriting the Elcodi model.\n\n\nHow to implement an entity\n\n\nHow to overwrite an entity\n\n\nIf a plugin overwrites a new entity or creates new entities that depends on \nexisting ones, then these dependant bundles that own these entities become \ndependencies of the plugins itself. Ensure that they are defined as such.\n\n\nOverwriting services\n #\n\n\nLike model, service layer is overwritable by using the same philosophy than the\nSymfony way. You will find some nice information in the Symfony documentation\nabout how to overwrite any part of the bundle, and in some of our cookbooks.\n\n\nHow to Override any Part of a Bundle\n\n\nHow to overwrite a service\n\n\nOf course, you can overwrite some parameters\n\n\nHow to overwrite a parameter\n\n\nAdding configuration\n #\n\n\nOne of the main plugin responsibilities (and needs many times) is to add\nconfiguration values into the main project. This means that not only should be\nresponsible of adding it's own configuration but add configuration related to\nother bundles.\n\n\nThere is a very easy way of doing this, assuming that the bundle you need to\nconfigure is already a dependency of your plugin, or at least that your plugin\nis being loaded after the configurable bundle in the kernel file.\n\n\nYou only have to create a new file called \nexternal.yml\n inside the folder\n\n@MyPlugin/Resources/config/external.yml\n and add all the configuration there.\n\n\nThis file will be appended by a Compiler Pass into the master config file, so\nafter compiled, the container will take in account this data as well.\n\n\nAdding routes\n #\n\n\nAnother useful action you might need inside a Plugin is to add some routes in\nthe master routing file.\n\n\nIn fact, you don't need to modify the routing master file to add new routes. You\nonly need to create a new file called \nrouting.yml\n inside the folder\n\n@MyPlugin/Resources/config/routing.yml\n and after flushing the cache, your\nproject will automatically detect new routes.\n\n\nAdding listeners\n #\n\n\nPart of a plugin should be as well adding some new cool behavior to your\nproject, and the cleanest way of doing that is by adding some listeners to our\nevents.\n\n\nPlease, take a look at our event list.\n\n\nElcodi Events", 
            "title": "Plugins"
        }, 
        {
            "location": "/book/plugins/#plugins", 
            "text": "Create, install and manage several plugins in your Bamboo installation.   Component Repository  Bundle Repository   We want to introduce you what is a Plugin when we talk about Elcodi. Indeed,\nthis question has a very fast abstract answer that will, surely, give you some\nextra calmness.  A Plugin is a Bundle.  Yes, when we talk about Plugins, we talk about Symfony Bundles, with a simple \nand pre-defined specification. And is this specification what we will show you\nproperly, in order to help you understanding existing plugins and composing new\nones.", 
            "title": "Plugins"
        }, 
        {
            "location": "/book/plugins/#what-is-a-bundle", 
            "text": "Like any Bundle, a Plugin needs to have its own Bundle class. This is usually\nplaced in the root of the bundle, and should be called as much specifically as\npossible, in order to avoid collisions.   Even if two bundles share the same name, the uniqueness of each Plugin is \ndefined by its namespace, so even in this scenario, your Elcodi installation\nwill work properly.   Let's see an example of a bundle. We will work along this document with our\nfirst Plugin, the DisqusBundle.  namespace Elcodi\\Plugin\\DisqusBundle;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Component\\Plugin\\Interfaces\\PluginInterface;\n\n/**\n * Class ElcodiDisqusBundle\n */\nclass ElcodiDisqusBundle extends Bundle implements PluginInterface\n{\n    // ...\n}  Implementing  PluginInterface  is the way the kernel has to identify if a bundle\nhas to be treated as a Plugin", 
            "title": "What is a Bundle?"
        }, 
        {
            "location": "/book/plugins/#why-plugins", 
            "text": "That's one of the most important parts of our philosophy. We will give some \nreasons to have a plugin-driven design.   Because you will design decoupled from the core. This means that, if you\nupdate Elcodi and Bamboo with new features (remember, using semantic version),\nthere wont be the possibility to have conflicts. You only develop your own \nplugins, based on the master project.  Because you can share. If you overwrite some parts of the project proposing\nnew business logic, and if you take care about related documentation, then you\ncan share your work, and even sell it.  Because will help you with the development of the package. Your code will be\ncleaner and more testable... and this is always good news.  Because you will follow Elcodi style. All these proposed reasons is what makes\nElcodi a good project to work with. Following our structure will help this\necosystem to grow day by day, and this is what will make Elcodi a successful \nproject indeed.", 
            "title": "Why plugins?"
        }, 
        {
            "location": "/book/plugins/#plugin-dependencies", 
            "text": "All plugins are extending the main project, but some of them have some \ndependencies. Remember that Elcodi has it's own bundle dependencies resolver.\nPlease, read careful this chapter in order to understand how to define properly\nthese dependencies.  How to Install dependent Bundles", 
            "title": "Plugin dependencies"
        }, 
        {
            "location": "/book/plugins/#plugin-definition", 
            "text": "There is a very simple way to define a Plugin. What is the name of the plugin, \nwhat are the fields that will configure it, and some more information is what\nyou will have to place in the  plugin.yml  file.   This file must be placed in the root of the Bundle   Let's see an example of how the DisqusPlugin is configured.  plugin:\n    type: plugin\n    category: comments\n    name: Discuss\n    description: |\n        Disqus integration for your shop\n    fa_icon: comment-o\n    fields:\n        disqus_identifier:\n            type: text\n            label: elcodi_plugin.disqus.disqus_identifier\n        disqus_enabled_product:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_product\n        disqus_enabled_blog_post:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_blog_post  Each definition is considered as a configuration element, and all these are\navailable.   type: You must define your Plugin as a simple plugin or as a template. Of \ncourse this value is required. Available values are  plugin  or  template .  category: You can tag it as well using a specific category. Each category is\nmeant to be treated in a different specific way. Specific and useful values\nare  payment ,  shipping  and  social . If none value is specified, then will\nnot belong to any category.  name: The name of your plugin  visible: This plugin will be visible for its configuration. By default, this\nvalue is set as true.  fa_icon: Icon used, following the  Awesome Fonts  \nformat  description: Plugin description  fields: Set of configurable fields", 
            "title": "Plugin definition"
        }, 
        {
            "location": "/book/plugins/#plugin-fields", 
            "text": "What is a field? Well, your plugins may require some values to be stored in\nyour database related to the plugin. For example, an  api_public_key  or a \nsimple  username .  These values are stored in a plain way, and because is important to make easy\nthe management of these values, Bamboo will provide automatically your Plugin\nconfiguration page, only by defining how these fields should be created. These\nare all possibilities   type: Type of the field. This value will be used as field type in form  required: This field must be configured in order to use this plugin  data: The value of the field  label: Label of the field (You can use translations)  options: Array of options, needed if your field is checkbox or radio.  attr: Array of attributes   Let's see an example. If our plugin require a text field called username...  plugin:\n    type: plugin\n    category: social\n    name: Twitter\n    description: |\n        Twitter integration for your shop\n    fa_icon: twitter-o\n    fields:\n        username:\n            type: text\n            label: elcodi_plugin.twitter.username\n            required: true  With this example, your Bamboo installation will provide you a nice page with\na very simple way of defining the twitter username.  A little bit later you will find the way of retrieving these values.", 
            "title": "Plugin fields"
        }, 
        {
            "location": "/book/plugins/#dependency-injection", 
            "text": "A plugin is a Bundle, remember? This means that you should define a set of \nservices in the same way you do when you create your amazing bundles.  You can follow the Elcodi way by reading some cookbooks in this documentation,\nso you will make sure that everybody will understand more easily what you're \ntrying to do.   How to install dependent Bundles  Extensions  Some Dependency Injection standards   Remember to follow some of our philosophy. Small services and well defined.\nClean code is important. This part is the most important part of your Plugin.\nPreserve each service responsibility and be sure everyone will understand what\nis all services purpose.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/book/plugins/#plugin-as-a-service", 
            "text": "Sometimes you need to inject your plugin, right? Well, you can do that as long\nas you can reach your plugin using the  PluginRepository  and you can define the\nresult content as a service.  services:\n\n    #\n    # Plugin\n    #\n    elcodi_plugin.disqus:\n        parent: elcodi.abstract_plugin\n        arguments:\n            -  Elcodi\\\\Plugin\\\\DisqusBundle\\\\ElcodiDisqusBundle   You need to be as specific as possible to avoid collisions between different \nbundles. Of course you can not determine that your Disqus plugin will be the \nonly one installable, so has no sense to name your plugin service  disqus , but\nmaybe something like that...  {my_organization}_elcodi_plugin.disqus  Once you have your service, then you can do that.  services:\n\n    #\n    # Twig renderer\n    #\n    elcodi_plugin.disqus.renderer:\n        class: Elcodi\\Plugin\\DisqusBundle\\Templating\\TwigRenderer\n        calls:\n            - [setPlugin, [@elcodi_plugin.disqus]]  In your class, then you receive your plugin object (plugin entity). Let's see an\nexample about what this class allows you to manage.  use Elcodi\\Component\\Plugin\\Entity\\Plugin;\n\n/**\n * Class MyService\n */\nclass MyService\n{\n    /**\n     * @var Plugin\n     *\n     * Plugin\n     */\n    protected $plugin;\n\n    /**\n     * Construct\n     *\n     * @param Plugin $plugin Plugin\n     */\n    public function __construct(Plugin $plugin) \n    {\n        $this- plugin = $plugin;\n    }\n    /**\n     * Add Stripe payment method\n     *\n     * @param PaymentCollectionEvent $event Event\n     */\n    public function addStripePaymentMethod(PaymentCollectionEvent $event)\n    {\n        if ($this\n            - plugin\n            - isUsable([\n                'private_key',\n                'public_key',\n            ])\n        ) {\n            // I can do whatever I want here. My plugin is usable!\n        }\n    }\n}  Each plugin has some interesting public methods. Let's see some of them  getConfigurationValue()  #  You require a configuration element. Please, see the full list in the Plugin\ndefinition chapter.  $pluginCategory = $this\n    - plugin\n    - getConfigurationValue('category');  getFieldValue()  #  Remember our last example? We configured one field called username for our\nTwitter plugin, right? Well, let's get the username value by using this cool\nmethod.  $username = $this\n    - plugin\n    - getField('username');  getField()  #  Sometimes you need to fetch all the field data, including it's definition and\nvalue. Then, you can use this method. You receive an array with all the data, \nand the value is always placed in the hash position with name  data .  $usernameField = $this\n    - plugin\n    - getField('username');\n\n$username = $usernameField['data'];  getFields()  #  If you need all plugin's fields as an array, then you can call this public\nmethod. You receibe an array of fields, so you have to access the same way than\nbefore.  $allFields = $this\n    - plugin\n    - getFields();\n\n$username = $allFields['username']['data'];  getFieldValues()  #  You can request as well all fields with their values using a simple key-value\nstructure, being the key the name of the field and the value, the value of the \nfield. If this is what you need, then use this method.  $allValues = $this\n    - plugin\n    - getFieldValues();\n\n$username = getFieldValues['username'];  isUsable  #  You can check if a Plugin is usable by checking that is enabled and that a set\nof defined fields are fulfilled. A field is fulfilled when is not required or\nis required and the field is not empty.  If you don't pass any field, then  enabled  field is checked.  $isUsable = $this\n    - plugin\n    - isUsable(['username']);  In this example, and because the twitter plugin should not work unless the \nusername is set (username field is defined as required), then will return true\nonly if the plugin itself is enabled and the field username is not empty.  guessIsUsable  #  Well, all this work can be done automatically, without need to define all\nfields. So if you use this method, then all fields will be checked, so a plugin\nwill be usable only if is usable using all plugin fields.  That means that all required fields defined in the plugin configuration must\nhave a value.  $isUsable = $this\n    - plugin\n    - gessIsUsable();  In this example, and because our twitter plugin only have one single field and\nis required, the result will be exactly the same than the last piece of code.", 
            "title": "Plugin as a service"
        }, 
        {
            "location": "/book/plugins/#installing-your-plugin", 
            "text": "You can do that using the command console by using the  elcodi:plugins:load \ncommand. If you have configured your plugin the right way, then you should have\nyour Plugin configuration panel in the admin side.  How to Install a plugin  After loading the plugin, of course, you need to add it in your AppKernel file.\nBecause some plugins have dependencies and because it's main mission is \noverwriting logic, you should instantiate them at the end of the class.  use Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\HttpKernel\\Kernel;\nuse Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface;\n\nuse Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends Kernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Returns an array of bundles to register.\n     *\n     * @return BundleInterface[] An array of bundle instances.\n     *\n     * @api\n     */\n    public function registerBundles()\n    {\n        $bundles = array(\n\n            /**\n             * All Symfony, Bamboo and Elcodi bundles\n             * with their dependencies\n             */\n\n            // ...\n\n            /**\n             * Elcodi Plugins\n             */\n            new My\\Elcodi\\Plugin(),\n            new My\\Second\\Elcodi\\Plugin(),\n        );\n\n        return $this\n            - getBundleInstances(\n                $this,\n                $bundles\n            );\n    }\n}", 
            "title": "Installing your Plugin"
        }, 
        {
            "location": "/book/plugins/#overwriting-model", 
            "text": "One of the main goals of a plugin is overwriting the model. Of course you will\nhave to overwrite your desired entities, and old ones will not be used anymore\nas the main entity (unless you extend them, of course).  You can take a look at these chapters in order to understand properly how easy\nis overwriting the Elcodi model.  How to implement an entity  How to overwrite an entity  If a plugin overwrites a new entity or creates new entities that depends on \nexisting ones, then these dependant bundles that own these entities become \ndependencies of the plugins itself. Ensure that they are defined as such.", 
            "title": "Overwriting model"
        }, 
        {
            "location": "/book/plugins/#overwriting-services", 
            "text": "Like model, service layer is overwritable by using the same philosophy than the\nSymfony way. You will find some nice information in the Symfony documentation\nabout how to overwrite any part of the bundle, and in some of our cookbooks.  How to Override any Part of a Bundle  How to overwrite a service  Of course, you can overwrite some parameters  How to overwrite a parameter", 
            "title": "Overwriting services"
        }, 
        {
            "location": "/book/plugins/#adding-configuration", 
            "text": "One of the main plugin responsibilities (and needs many times) is to add\nconfiguration values into the main project. This means that not only should be\nresponsible of adding it's own configuration but add configuration related to\nother bundles.  There is a very easy way of doing this, assuming that the bundle you need to\nconfigure is already a dependency of your plugin, or at least that your plugin\nis being loaded after the configurable bundle in the kernel file.  You only have to create a new file called  external.yml  inside the folder @MyPlugin/Resources/config/external.yml  and add all the configuration there.  This file will be appended by a Compiler Pass into the master config file, so\nafter compiled, the container will take in account this data as well.", 
            "title": "Adding configuration"
        }, 
        {
            "location": "/book/plugins/#adding-routes", 
            "text": "Another useful action you might need inside a Plugin is to add some routes in\nthe master routing file.  In fact, you don't need to modify the routing master file to add new routes. You\nonly need to create a new file called  routing.yml  inside the folder @MyPlugin/Resources/config/routing.yml  and after flushing the cache, your\nproject will automatically detect new routes.", 
            "title": "Adding routes"
        }, 
        {
            "location": "/book/plugins/#adding-listeners", 
            "text": "Part of a plugin should be as well adding some new cool behavior to your\nproject, and the cleanest way of doing that is by adding some listeners to our\nevents.  Please, take a look at our event list.  Elcodi Events", 
            "title": "Adding listeners"
        }, 
        {
            "location": "/book/processes/", 
            "text": "Processes\n #\n\n\nIn this chapter you will find a set of Bamboo processes. A process is just a\npage loaded or a specific action from an already loaded page.\n\n\nEach entry of this chapter has the same predefined format, taking in account\nthat all links work having a clean Bamboo installation listening to\nhttp://localhost:8000\n\n\nGiven\n - Initial environment and requirements\n\n\nWhen\n - Our elemental action\n\n\nThen\n - Actions ocurred because of that previous actions. Sent emails and \nimportant dispatched events are described here as well.\n\n\nIn each scenario, we'll provide as well some nice sections for you to know a\nlittle bit more about it.\n\n\n\n\nEvents dispatched - Events dispatched by the symfony component or any Elcodi\ncomponents\n\n\nEmail sent - Emails sent by the application during this action\n\n\nRelated links - Interesting links to know a little bit more about the scenario\n\n\nNice improvements - Small tips about how to improve the scenario.\n\n\n\n\nLoad any page\n #\n\n\nAll pages have a common set of elements described as follows. All elements\nbelong to the application, so they are applicable to all web requests.\n\n\nGiven\n - As a user, no matter the credentials\n\n\nWhen\n - We want to visit any application page\n\n\nThen\n - These actions happen  \n\n\n\n\nRequest is handled by the Bamboo application, on top of the Symfony Framework,\nSymfony components and Elcodi components.\n\n\nThe user is loaded by using the session information\n\n\nThe user credentials are checked and analyzed in order to find authentication\nand authorization information.\n\n\nIf the user can visit the page, then the response is created and served to the\nuser.\n\n\nOtherwise, you'll receive a redirection to login page\n\n\nSome user related information is loaded from database\n\n\nSome language related information is loaded from database, taking in account\nthe user or using stored-in-session data\n\n\nSome currency information is loaded the same way than language\n\n\nThe request is processed\n\n\n\n\n\n\nRelated links\n\n\n\n\nHTTP Fundamentals\n\n\nSymfony Security\n\n\nSession Management\n\n\n\n\nLoad the home page\n #\n\n\nThe main page, or home page, is always treated as a simple category page, having\nthat the way of retrieving the products is by filtering by the field \ninHome\n.\n\n\nGiven\n - As a user, no matter the credentials\n\n\nWhen\n - We visit the home page, http://localhost:8000\n\n\nThen\n - We can see the N first products  \n\n\n\n\nLoad the product page\n #\n\n\nThe product page is one of the most important landing pages in the whole\ne-commerce project. You will find all product related information and all the\nneeded buttons for adding the product in your Cart.\n\n\nGiven\n - As a user, no matter the credentials\n\n\nWhen\n - We visit a product without variants page\n\nThen\n - All the product information is reached from the database and shown in\na single page. Because the product has no variants, you can add this product in\nyour cart by pushing the \nadd to cart\n button.\n\n\n\n\nRelated links\n\n\n\n\nProduct Architecture\n\n\n\n\nImprovements\n\n\n\n\nAs soon as your website has any search service (Like elasticsearch or Solr),\nall product-related data should be required from there instead of using\ndatabase. To do that, you should save all needed information in the search\nserver in order to avoid sql connection\n\n\n\n\nLoad the variants page\n #\n\n\nIn this case, the product we're loading has variants, so the product itself is\nonly the master of different product variations (see related links). The meaning\nof this page is the same than the product one, but in this case, we will load as\nwell all the variants information.\n\n\nOf course, each variant\n\n\nGiven\n - As a user, no matter the credentials\n\n\nWhen\n - We visit a product with variants page\n\nThen\n - All the product information is reached from the database and shown in\na single page. Each variant will provide you the information about adding it\ninto cart, considering each variant as a product with some defined values.\n\n\n\n\nRelated links\n\n\n\n\nProduct Architecture\n\n\n\n\nLoad the category page\n #\n\n\nJust a search page, filtering by categories\n\n\nGiven\n - As a user, no matter the credentials\n\n\nWhen\n - We want to see all products from a category, http://localhost:8000/category/women-shirts/1\n\n\nThen\n - This page has the same behavior than the home page, but filtering by\ncategory.\n\n\n\n\nRelated links\n\n\n\n\nProduct Architecture\n\n\n\n\nRegister\n #\n\n\nRegister a new user in the application.\n\n\nGiven\n - As a not logged non registered user\n\n\nWhen\n - We want to register, http://localhost:8000/register\n\n\nThen\n - once added our basic and needed information, and pressed the \n\nregister\n button, a new user is added into the database. Is important to know\nthat our stored password is never saved plain and decrypted. We use BCrypt for\nthat reason.\n\n\n\n\nEvents dispatched\n\n\n\n\nuser.register\n\n\ncustomer.register\n\n\n\n\nSent emails\n\n\n\n\nCustomer registered\n\n\n\n\nRelated links\n\n\n\n\nBcrypt in Wikipedia\n\n\nSecurity Bundle Configuration\n\n\n\n\nLogin\n #\n\n\nLogin in the application\n\n\nGiven\n - As a not logged non registered user\n\n\nWhen\n - We want to log in, http://localhost:8000/login\n\n\nThen\n - once added our basic and needed information, and pressed the \n\nlogin\n button, the system checks that given user exists in database and that\ngiven password and stored one is the same. If they are, then the user is\nauthenticated in current session and allowed to access into the private zone.\nOtherwise, the user is redirected to the same page with relevant errors.\n\n\n\n\nRelated links\n\n\n\n\nBcrypt in Wikipedia\n\n\nSecurity Bundle Configuration\n\n\n\n\nLogout\n #\n\n\nLogout from the application\n\n\nGiven\n - As a logged user\n\nWhen\n - We want to log out from the website, http://localhost:8000/logout\n\nThen\n - Once we decide to logout, we only need to remove the session\ncredentials and the Symfony Security Component will do the rest.\n\n\nRelated links\n\n\n\n\nSecurity Bundle Configuration", 
            "title": "Processes"
        }, 
        {
            "location": "/book/processes/#processes", 
            "text": "In this chapter you will find a set of Bamboo processes. A process is just a\npage loaded or a specific action from an already loaded page.  Each entry of this chapter has the same predefined format, taking in account\nthat all links work having a clean Bamboo installation listening to\nhttp://localhost:8000  Given  - Initial environment and requirements  When  - Our elemental action  Then  - Actions ocurred because of that previous actions. Sent emails and \nimportant dispatched events are described here as well.  In each scenario, we'll provide as well some nice sections for you to know a\nlittle bit more about it.   Events dispatched - Events dispatched by the symfony component or any Elcodi\ncomponents  Email sent - Emails sent by the application during this action  Related links - Interesting links to know a little bit more about the scenario  Nice improvements - Small tips about how to improve the scenario.", 
            "title": "Processes"
        }, 
        {
            "location": "/book/processes/#load-any-page", 
            "text": "All pages have a common set of elements described as follows. All elements\nbelong to the application, so they are applicable to all web requests.  Given  - As a user, no matter the credentials  When  - We want to visit any application page  Then  - These actions happen     Request is handled by the Bamboo application, on top of the Symfony Framework,\nSymfony components and Elcodi components.  The user is loaded by using the session information  The user credentials are checked and analyzed in order to find authentication\nand authorization information.  If the user can visit the page, then the response is created and served to the\nuser.  Otherwise, you'll receive a redirection to login page  Some user related information is loaded from database  Some language related information is loaded from database, taking in account\nthe user or using stored-in-session data  Some currency information is loaded the same way than language  The request is processed    Related links   HTTP Fundamentals  Symfony Security  Session Management", 
            "title": "Load any page"
        }, 
        {
            "location": "/book/processes/#load-the-home-page", 
            "text": "The main page, or home page, is always treated as a simple category page, having\nthat the way of retrieving the products is by filtering by the field  inHome .  Given  - As a user, no matter the credentials  When  - We visit the home page, http://localhost:8000  Then  - We can see the N first products", 
            "title": "Load the home page"
        }, 
        {
            "location": "/book/processes/#load-the-product-page", 
            "text": "The product page is one of the most important landing pages in the whole\ne-commerce project. You will find all product related information and all the\nneeded buttons for adding the product in your Cart.  Given  - As a user, no matter the credentials  When  - We visit a product without variants page Then  - All the product information is reached from the database and shown in\na single page. Because the product has no variants, you can add this product in\nyour cart by pushing the  add to cart  button.   Related links   Product Architecture   Improvements   As soon as your website has any search service (Like elasticsearch or Solr),\nall product-related data should be required from there instead of using\ndatabase. To do that, you should save all needed information in the search\nserver in order to avoid sql connection", 
            "title": "Load the product page"
        }, 
        {
            "location": "/book/processes/#load-the-variants-page", 
            "text": "In this case, the product we're loading has variants, so the product itself is\nonly the master of different product variations (see related links). The meaning\nof this page is the same than the product one, but in this case, we will load as\nwell all the variants information.  Of course, each variant  Given  - As a user, no matter the credentials  When  - We visit a product with variants page Then  - All the product information is reached from the database and shown in\na single page. Each variant will provide you the information about adding it\ninto cart, considering each variant as a product with some defined values.   Related links   Product Architecture", 
            "title": "Load the variants page"
        }, 
        {
            "location": "/book/processes/#load-the-category-page", 
            "text": "Just a search page, filtering by categories  Given  - As a user, no matter the credentials  When  - We want to see all products from a category, http://localhost:8000/category/women-shirts/1  Then  - This page has the same behavior than the home page, but filtering by\ncategory.   Related links   Product Architecture", 
            "title": "Load the category page"
        }, 
        {
            "location": "/book/processes/#register", 
            "text": "Register a new user in the application.  Given  - As a not logged non registered user  When  - We want to register, http://localhost:8000/register  Then  - once added our basic and needed information, and pressed the  register  button, a new user is added into the database. Is important to know\nthat our stored password is never saved plain and decrypted. We use BCrypt for\nthat reason.   Events dispatched   user.register  customer.register   Sent emails   Customer registered   Related links   Bcrypt in Wikipedia  Security Bundle Configuration", 
            "title": "Register"
        }, 
        {
            "location": "/book/processes/#login", 
            "text": "Login in the application  Given  - As a not logged non registered user  When  - We want to log in, http://localhost:8000/login  Then  - once added our basic and needed information, and pressed the  login  button, the system checks that given user exists in database and that\ngiven password and stored one is the same. If they are, then the user is\nauthenticated in current session and allowed to access into the private zone.\nOtherwise, the user is redirected to the same page with relevant errors.   Related links   Bcrypt in Wikipedia  Security Bundle Configuration", 
            "title": "Login"
        }, 
        {
            "location": "/book/processes/#logout", 
            "text": "Logout from the application  Given  - As a logged user When  - We want to log out from the website, http://localhost:8000/logout Then  - Once we decide to logout, we only need to remove the session\ncredentials and the Symfony Security Component will do the rest.  Related links   Security Bundle Configuration", 
            "title": "Logout"
        }, 
        {
            "location": "/book/product-architecture/", 
            "text": "Product Architecture\n #\n\n\nOne of the main blocks in Elcodi is it's Product architecture. We assume that\nall projects will need to handle with it's own Product model diagram, so we\npropose a single one, based on the most basic scenario and with an architecture\nwhere you will be able to modify the model as much as you need.\n\n\n\n\nPurchasable\n #\n\n\nBecause you should be able to add anything both a product or a variant in your\ncart, we created the interface \nPurchasable\n. A purchasable is an object (any)\nyou can add into your cart.\n\n\nIn Elcodi we have implemented two completed classes implementing this interface:\nProduct and Variant. Both implementations are part of the Product component, and\ncomposes all the needed structure to maintain all kind of products and\nvariations of this.\n\n\nProduct\n #\n\n\nThe main entity of this component. A product is what you are going to sell, no\nmatter what it is and not taking in account variations of this. For example, our\nproduct could be a simple T-shirt. No color, no size, just a simple T-shirt.\n\n\nEach product contains all information related to that element, like price, some\ndimensions (all of them optional, of course), a description and a name, a SKU,\nthe stock of that object, and some extra properties. All you need to make this \nelement unique enough.\n\n\nYou can create a new Product like this.\n\n\nuse Elcodi\\Component\\Product\\Entity\\Product;\n\n$product = new Product();\n$product\n    -\nsetSku('123456789')\n    -\nsetStock(4)\n    -\nsetName('Strawberry cake')\n    -\nsetDescription('This is a strawberry cake');\n\n\n\n\nOf course, the right way in Elcodi is always using factories instead of creating\nnew instances by hand.\n\n\n$product = $this\n    -\nproductFactory\n    -\ncreate()\n    -\nsetName('Strawberry cake')\n    -\nsetDescription('This is a strawberry cake');\n\n\n\n\nThis service should have this dependency injection definition\n\n\nservices:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product\n\n\n\n\nSome times our E-commerce implementation only requires this infrastructure. If\nyou sell for example single cakes, then each cake is a product, and that should\nbe enough. Don't over-engineer your domain and project too much.\n\n\nIn other cases, for example if your e-commerce is selling some retail, then each\nProduct will have some variations. Let's see what a variation is and how we can\nimplement it in Elcodi.\n\n\nVariant\n #\n\n\nA Variant is a simple variation of a Product. Returning to the example of\nT-shirts, maybe you want to sell the same T-shirt in several colors, several\nsizes and several logos behind it.\n\n\nOne option is having one single product per each combination, and that would be\na good approach indeed, but then you have no way of controlling all products\nthat belong to the same family. For example, if all variations have the same\nprice then you should add it several times in several instances. As soon as this\nprice changes, then you need to change it all around.\n\n\nBad choice, right?\n\n\nIf you have only one Product called T-shirt and you create the right structure\nfor maintaining some Attributes and some Values, then you can create several\nVariants, each one containing one or more Values. Because a Variant is a\nPurchasable as well, then you can add them as well in your Cart.\n\n\nFirst of all, let's see how to create a variant, assuming we have the previous\nproduct created.\n\n\nuse Elcodi\\Component\\Product\\Entity\\Product;\nuse Elcodi\\Component\\Product\\Entity\\Variant;\n\n$product = new Product();\n$product\n    -\nsetName('T-shirt, Dora the explorer')\n    -\nsetDescription('T-shirt of Dora');\n\n$variant = new Variant\n$variant\n    -\nsetSku('12341234')\n    -\nsetStock(10)\n    -\nsetName('Blue XL T-shirt with the logo')\n    -\nsetProduct($product);\n\n\n\n\nOf course, the right way in Elcodi is always using factories instead of creating\nnew instances by hand.\n\n\n$product = $this\n    -\nproductFactory\n    -\ncreate()\n    -\nsetName('T-shirt, Dora the explorer')\n    -\nsetDescription('T-shirt of Dora');\n\n$variant = $this\n    -\nvariantFactory\n    -\ncreate()\n    -\nsetSku('12341234')\n    -\nsetStock(10)\n    -\nsetName('Blue XL T-shirt with the logo')\n    -\nsetProduct($product);\n\n\n\n\nThis service should have this dependency injection definition\n\n\nservices:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product\n            - @elcodi.factory.variant\n\n\n\n\nIn fact, that code is not useful at all, so none of these variants have\nattributes. Next step, creating a map of configurations for these Variants.\n\n\nAttributes\n #\n\n\nA variant is composed by different attribute values. Let's check it out by using\nthe last example. T-shirt of Dora the explorer is available in colors blue, red\nand green. Each one can be purchased in several sizes: S, M and L.\n\n\nEach Variant is a Product and one of each attribute, called Value. So, there is\none Variant that will have internally the Value blue of the Attribute color, and\nthe Value S of the Attribute Size.\n\n\nAssuming the piece of code we did before about product and variant...\n\n\n$product = //;\n$variant = //;\n\n$attribute = $this\n    -\nattributeFactory\n    -\ncreate()\n    -\nsetName('size');\n\n$value = $this\n    -\nvalueFactory\n    -\ncreate()\n    -\nsetValue('S')\n    -\nsetAttribute($attribute);\n\n$variant-\nsetValue($value);\n\n\n\n\nAs you can see, the relation is done between the Attribute and the Value, but\nbecause one Value can only have one Attribute, then the relation is done as well\nbetween the Variant and the Attribute.\n\n\n$attribute = $variant\n    -\ngetValue()\n    -\ngetAttribute();\n\n\n\n\nManufacturer\n #\n\n\nA product (and because a Product is always the master piece of any purchasable)\ncan have a manufacturer. The relation is easy and simple indeed, so there is no\nmuch need of explaining how to work with this entity.\n\n\n$product = //;\n\n$manufacturer = $this\n    -\nmanufacturerFactory\n    -\ncreate()\n    -\nsetName('Levis');\n\n$product-\nsetManufacturer($manufacturer);\n\n\n\n\nCategories\n #\n\n\nThere is an entire chapter for that in Elcodi's book. Please, read it carefully\nin order to be able to work properly with categories in your project\n\n\n\n\nCategory Architecture", 
            "title": "Product architecture"
        }, 
        {
            "location": "/book/product-architecture/#product-architecture", 
            "text": "One of the main blocks in Elcodi is it's Product architecture. We assume that\nall projects will need to handle with it's own Product model diagram, so we\npropose a single one, based on the most basic scenario and with an architecture\nwhere you will be able to modify the model as much as you need.", 
            "title": "Product Architecture"
        }, 
        {
            "location": "/book/product-architecture/#purchasable", 
            "text": "Because you should be able to add anything both a product or a variant in your\ncart, we created the interface  Purchasable . A purchasable is an object (any)\nyou can add into your cart.  In Elcodi we have implemented two completed classes implementing this interface:\nProduct and Variant. Both implementations are part of the Product component, and\ncomposes all the needed structure to maintain all kind of products and\nvariations of this.", 
            "title": "Purchasable"
        }, 
        {
            "location": "/book/product-architecture/#product", 
            "text": "The main entity of this component. A product is what you are going to sell, no\nmatter what it is and not taking in account variations of this. For example, our\nproduct could be a simple T-shirt. No color, no size, just a simple T-shirt.  Each product contains all information related to that element, like price, some\ndimensions (all of them optional, of course), a description and a name, a SKU,\nthe stock of that object, and some extra properties. All you need to make this \nelement unique enough.  You can create a new Product like this.  use Elcodi\\Component\\Product\\Entity\\Product;\n\n$product = new Product();\n$product\n    - setSku('123456789')\n    - setStock(4)\n    - setName('Strawberry cake')\n    - setDescription('This is a strawberry cake');  Of course, the right way in Elcodi is always using factories instead of creating\nnew instances by hand.  $product = $this\n    - productFactory\n    - create()\n    - setName('Strawberry cake')\n    - setDescription('This is a strawberry cake');  This service should have this dependency injection definition  services:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product  Some times our E-commerce implementation only requires this infrastructure. If\nyou sell for example single cakes, then each cake is a product, and that should\nbe enough. Don't over-engineer your domain and project too much.  In other cases, for example if your e-commerce is selling some retail, then each\nProduct will have some variations. Let's see what a variation is and how we can\nimplement it in Elcodi.", 
            "title": "Product"
        }, 
        {
            "location": "/book/product-architecture/#variant", 
            "text": "A Variant is a simple variation of a Product. Returning to the example of\nT-shirts, maybe you want to sell the same T-shirt in several colors, several\nsizes and several logos behind it.  One option is having one single product per each combination, and that would be\na good approach indeed, but then you have no way of controlling all products\nthat belong to the same family. For example, if all variations have the same\nprice then you should add it several times in several instances. As soon as this\nprice changes, then you need to change it all around.  Bad choice, right?  If you have only one Product called T-shirt and you create the right structure\nfor maintaining some Attributes and some Values, then you can create several\nVariants, each one containing one or more Values. Because a Variant is a\nPurchasable as well, then you can add them as well in your Cart.  First of all, let's see how to create a variant, assuming we have the previous\nproduct created.  use Elcodi\\Component\\Product\\Entity\\Product;\nuse Elcodi\\Component\\Product\\Entity\\Variant;\n\n$product = new Product();\n$product\n    - setName('T-shirt, Dora the explorer')\n    - setDescription('T-shirt of Dora');\n\n$variant = new Variant\n$variant\n    - setSku('12341234')\n    - setStock(10)\n    - setName('Blue XL T-shirt with the logo')\n    - setProduct($product);  Of course, the right way in Elcodi is always using factories instead of creating\nnew instances by hand.  $product = $this\n    - productFactory\n    - create()\n    - setName('T-shirt, Dora the explorer')\n    - setDescription('T-shirt of Dora');\n\n$variant = $this\n    - variantFactory\n    - create()\n    - setSku('12341234')\n    - setStock(10)\n    - setName('Blue XL T-shirt with the logo')\n    - setProduct($product);  This service should have this dependency injection definition  services:\n    my_service:\n        class: My\\Service\\Namespace\n        arguments:\n            - @elcodi.factory.product\n            - @elcodi.factory.variant  In fact, that code is not useful at all, so none of these variants have\nattributes. Next step, creating a map of configurations for these Variants.", 
            "title": "Variant"
        }, 
        {
            "location": "/book/product-architecture/#attributes", 
            "text": "A variant is composed by different attribute values. Let's check it out by using\nthe last example. T-shirt of Dora the explorer is available in colors blue, red\nand green. Each one can be purchased in several sizes: S, M and L.  Each Variant is a Product and one of each attribute, called Value. So, there is\none Variant that will have internally the Value blue of the Attribute color, and\nthe Value S of the Attribute Size.  Assuming the piece of code we did before about product and variant...  $product = //;\n$variant = //;\n\n$attribute = $this\n    - attributeFactory\n    - create()\n    - setName('size');\n\n$value = $this\n    - valueFactory\n    - create()\n    - setValue('S')\n    - setAttribute($attribute);\n\n$variant- setValue($value);  As you can see, the relation is done between the Attribute and the Value, but\nbecause one Value can only have one Attribute, then the relation is done as well\nbetween the Variant and the Attribute.  $attribute = $variant\n    - getValue()\n    - getAttribute();", 
            "title": "Attributes"
        }, 
        {
            "location": "/book/product-architecture/#manufacturer", 
            "text": "A product (and because a Product is always the master piece of any purchasable)\ncan have a manufacturer. The relation is easy and simple indeed, so there is no\nmuch need of explaining how to work with this entity.  $product = //;\n\n$manufacturer = $this\n    - manufacturerFactory\n    - create()\n    - setName('Levis');\n\n$product- setManufacturer($manufacturer);", 
            "title": "Manufacturer"
        }, 
        {
            "location": "/book/product-architecture/#categories", 
            "text": "There is an entire chapter for that in Elcodi's book. Please, read it carefully\nin order to be able to work properly with categories in your project   Category Architecture", 
            "title": "Categories"
        }, 
        {
            "location": "/book/pull-requests/", 
            "text": "Pull Requests\n #\n\n\nElcodi is an Open Source project. This means that the community is a very\nimportant part of the development (in fact, maybe the most important), and \nbecause of that each feature must be properly documented in order to make each\naddition easy to understand and integrate.\n\n\nYou will find some information about how to create a pull request using github\nin their \n\nhelp article\n.\n\n\nBranch\n #\n\n\nThe name of the branch should be explicative enough for everyone interested in\nreviewing. Github is used to propose names like \npatch-1\n, so please, check the\nname before any Pull Request.\n\n\nYou can use as well our format, that will help us to catalog more quickly your\nwork.\n\n\nfeature/this-is-my-new-feature\nfix/fixes-this-thing\ntypo/fixes-this-typo\n\n\n\n\nCommits\n #\n\n\nEach branch can have as much commits as desired. But the question here is... how\nmany commits do I need in order to create an acceptable Pull Request? The answer\nis as many as you need, but taking into account the possible usage of the git\nrebase interactive tool.\n\n\nDevelopers are used to creating partial commits named \nWIP\n and pushing them to\ntemporary branches. That's a good strategy if you want to ensure your daily \nwork, but can be a bad idea if you use these commits for your Pull Request.\n\n\n6d78a7b WIP\n7843838 WIP\nd78dbaa tmp\nd7aa7df Some additions\n\n\n\n\nAs you can see here, these messages do not explain absolutely nothing about your\nwork, so please check your branches before any Pull Request.\n\n\nCommit description\n #\n\n\nHow should a commit description describe our changes? Well, you can follow this\nstructure to follow good practices.\n\n\nThis is a short description\n\nCloses #123\n\nThen, We can add a larger description, focused on showing the world what is this\ncommit about. Don't hesitate to add as much information as needed.\n\n* Finally, you can add some extra information using bullets\n* And more bullets\n* Related to this commit\n\n\n\n\nPR Description\n #\n\n\nAnytime a PR is created, you should describe a small description about all\nthings this set of commits are going to change. This is important because we\nshould understand in a simple way what is this PR about.\n\n\nSymfony introduced some time ago a small structure for providing some standard\ninformation about the PR.\n\n\n\n\n\n\n\n\nQ\n\n\nA\n\n\n\n\n\n\n\n\n\n\nBug fix?\n\n\nno\n\n\n\n\n\n\nNew feature?\n\n\nyes\n\n\n\n\n\n\nBC breaks?\n\n\nno\n\n\n\n\n\n\nDeprecations?\n\n\nno\n\n\n\n\n\n\nFixed tickets\n\n\n-\n\n\n\n\n\n\nLicense\n\n\nMIT\n\n\n\n\n\n\n\n\nMake sure that all your PRs start with this structure and with the right data", 
            "title": "Pull requests"
        }, 
        {
            "location": "/book/pull-requests/#pull-requests", 
            "text": "Elcodi is an Open Source project. This means that the community is a very\nimportant part of the development (in fact, maybe the most important), and \nbecause of that each feature must be properly documented in order to make each\naddition easy to understand and integrate.  You will find some information about how to create a pull request using github\nin their  help article .", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/book/pull-requests/#branch", 
            "text": "The name of the branch should be explicative enough for everyone interested in\nreviewing. Github is used to propose names like  patch-1 , so please, check the\nname before any Pull Request.  You can use as well our format, that will help us to catalog more quickly your\nwork.  feature/this-is-my-new-feature\nfix/fixes-this-thing\ntypo/fixes-this-typo", 
            "title": "Branch"
        }, 
        {
            "location": "/book/pull-requests/#commits", 
            "text": "Each branch can have as much commits as desired. But the question here is... how\nmany commits do I need in order to create an acceptable Pull Request? The answer\nis as many as you need, but taking into account the possible usage of the git\nrebase interactive tool.  Developers are used to creating partial commits named  WIP  and pushing them to\ntemporary branches. That's a good strategy if you want to ensure your daily \nwork, but can be a bad idea if you use these commits for your Pull Request.  6d78a7b WIP\n7843838 WIP\nd78dbaa tmp\nd7aa7df Some additions  As you can see here, these messages do not explain absolutely nothing about your\nwork, so please check your branches before any Pull Request.", 
            "title": "Commits"
        }, 
        {
            "location": "/book/pull-requests/#commit-description", 
            "text": "How should a commit description describe our changes? Well, you can follow this\nstructure to follow good practices.  This is a short description\n\nCloses #123\n\nThen, We can add a larger description, focused on showing the world what is this\ncommit about. Don't hesitate to add as much information as needed.\n\n* Finally, you can add some extra information using bullets\n* And more bullets\n* Related to this commit", 
            "title": "Commit description"
        }, 
        {
            "location": "/book/pull-requests/#pr-description", 
            "text": "Anytime a PR is created, you should describe a small description about all\nthings this set of commits are going to change. This is important because we\nshould understand in a simple way what is this PR about.  Symfony introduced some time ago a small structure for providing some standard\ninformation about the PR.     Q  A      Bug fix?  no    New feature?  yes    BC breaks?  no    Deprecations?  no    Fixed tickets  -    License  MIT     Make sure that all your PRs start with this structure and with the right data", 
            "title": "PR Description"
        }, 
        {
            "location": "/book/roadmap/", 
            "text": "Roadmap\n #\n\n\nIn Elcodi we've defined a very strict Roadmap definition. We will evolve as much\nas possible next years, but we will never forget old Elcodi and Bamboo\ninstallations, so our progress will be supplemented with tons of help and\nsupport for all our customers.\n\n\nDuring the minor versions, we encourage all installations to follow all updates\nin order to get new features, but all issues will be merged in the lowest branch\npossible.\n\n\nEach new tag will be properly documented and comunicated.\n\n\nv1.0\n #\n\n\n\n\nReleased the 22nd of September, 2015\n\n\nFirst stable version of Elcodi, from all previousBeta versions\n\n\nFirst stable version of Bamboo\n\n\nNew website of Elcodi\n\n\nNew documentation with basics of Elcodi\n\n\n\n\nv1.1\n #\n\n\n\n\nReleased the 1st of January, 2016\n\n\nProduct of products (Multiproduct) will be introduced and implemented.\n\n\nBetter integration with Continuous Integration systems\n\n\nRelated products interface\n\n\nNew shop template will be added as the default one.\n\n\nTemplate documentation will be added.\n\n\nDocumentation Metrics book chapter will be added.\n\n\nCode Coverage of all components and bundles over 50%\n\n\n\n\nv1.2\n #\n\n\n\n\nReleased the 1st of April, 2016\n\n\nSearch engine using ElasticSearch will be introduced here\n\n\nProduct API will be added\n\n\nUser API will be added\n\n\nCart API will be added\n\n\nSome Media improvements, like new media types\n\n\nNew shop template will be added\n\n\nBack panel documentation\n\n\nCode Coverage of all components and bundles over 60%\n\n\n\n\nv1.3\n #\n\n\n\n\nReleased the 1st of July, 2016\n\n\nMultistore. Switch between stores in the same installation\n\n\nShop API will be added\n\n\nNew shop template will be added\n\n\nNew tempates and plugins website with tons of cool new stuff for all Elcodi\nand Bamboo implementations\n\n\nCode Coverage of all components and bundles over 70%\n\n\n\n\nv2.0\n #\n\n\n\n\nReleased the 1st of October, 2016\n\n\nWe will remove all deprecated code\n\n\nBamboo will use Symfony3 and maybe new version of Doctrine\n\n\nUpdated all dependencies\n\n\nMarketplace\n\n\nElcodi community site will be created.\n\n\nUnknown bunch of new and cool stuff\n\n\nCode Coverage of all components and bundles over 80%", 
            "title": "Roadmap"
        }, 
        {
            "location": "/book/roadmap/#roadmap", 
            "text": "In Elcodi we've defined a very strict Roadmap definition. We will evolve as much\nas possible next years, but we will never forget old Elcodi and Bamboo\ninstallations, so our progress will be supplemented with tons of help and\nsupport for all our customers.  During the minor versions, we encourage all installations to follow all updates\nin order to get new features, but all issues will be merged in the lowest branch\npossible.  Each new tag will be properly documented and comunicated.  v1.0  #   Released the 22nd of September, 2015  First stable version of Elcodi, from all previousBeta versions  First stable version of Bamboo  New website of Elcodi  New documentation with basics of Elcodi   v1.1  #   Released the 1st of January, 2016  Product of products (Multiproduct) will be introduced and implemented.  Better integration with Continuous Integration systems  Related products interface  New shop template will be added as the default one.  Template documentation will be added.  Documentation Metrics book chapter will be added.  Code Coverage of all components and bundles over 50%   v1.2  #   Released the 1st of April, 2016  Search engine using ElasticSearch will be introduced here  Product API will be added  User API will be added  Cart API will be added  Some Media improvements, like new media types  New shop template will be added  Back panel documentation  Code Coverage of all components and bundles over 60%   v1.3  #   Released the 1st of July, 2016  Multistore. Switch between stores in the same installation  Shop API will be added  New shop template will be added  New tempates and plugins website with tons of cool new stuff for all Elcodi\nand Bamboo implementations  Code Coverage of all components and bundles over 70%   v2.0  #   Released the 1st of October, 2016  We will remove all deprecated code  Bamboo will use Symfony3 and maybe new version of Doctrine  Updated all dependencies  Marketplace  Elcodi community site will be created.  Unknown bunch of new and cool stuff  Code Coverage of all components and bundles over 80%", 
            "title": "Roadmap"
        }, 
        {
            "location": "/book/running-test-suite/", 
            "text": "Running Test Suite\n #\n\n\nBoth projects have a set of Unit, Functional and Behavioral tests. It is important\nto know how to run them all, and how to do that in a fast way\n\n\nelcodi/elcodi\n #\n\n\nRunning the test suite for elcodi/elcodi is simply one command:\n\n\nphp bin/phpunit\n\n\n\n\nElcodi tests are ran against folder \n/tmp/Elcodi\n, so a good practice in this\ncase is to ensure that accesses to this folder are fast enough. For this reason, we can\ncreate a \ntmpfs\n, a mounted file system stored in volatile memory instead of a \npersistent storage device.\n\n\nrm -Rf /tmp/Elcodi\nsudo mkdir /tmp/Elcodi\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Elcodi/\n\n\n\n\nWith this trick, your tests will run extremely faster than before.\n\n\nElcodi project uses as well a Testing Booster called\n\nFixturesBoosterBundle\n. This\nproject overwrites the Doctrine command \ndoctrine:fixtures:load\n with a boosted\nversion.\n\n\nIn order to avoid keeping state on a temporal database you may need to remove \ntemporal files generated by this booster on your tmp folder:\n\n\nrm -rf /tmp/*.backup.database\n\n\n\n\nIn addition to this it is required to flush the redis database:\n\n\nredis-cli flushall\n\n\n\n\nProblems can turn very cryptic if you are using an expired redis database.\n\n\nelcodi/bamboo\n #\n\n\nRunning the test suite for elcodi/bamboo is also simple:\n\n\nphp bin/behat\nphp bin/phpunit -c app/\n\n\n\n\nAs explained before, Bamboo tests also can be ran against a \ntmpfs\n unit.\n\n\nrm -Rf /tmp/Bamboo\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Bamboo\n\n\n\n\nYou can do the same with the cache folder, in order to make all reads really \nfaster.\n\n\nrm -Rf app/cache\nmkdir app/cache\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/cache\n\n\n\n\nIf you want to run a subset of the behat tests you can specify the tag as\nan option:\n\n\nphp bin/behat --tags=\nstore\n\n\n\n\n\nThis will only run the feature scenarios tagged with @store, e.g.:\n\n\n# bamboo/features/store/cart.feature\n@store @cart\nFeature: Store cart\n  In order to use the cart\n  As a visitor or logged user\n  I need to be able to add products into it and access the checkout\n\n  # ...\n\n\n\n\nA typical use case when to use this feature is when you want to\nrun only the tests that require javascript.", 
            "title": "Running test suite"
        }, 
        {
            "location": "/book/running-test-suite/#running-test-suite", 
            "text": "Both projects have a set of Unit, Functional and Behavioral tests. It is important\nto know how to run them all, and how to do that in a fast way", 
            "title": "Running Test Suite"
        }, 
        {
            "location": "/book/running-test-suite/#elcodielcodi", 
            "text": "Running the test suite for elcodi/elcodi is simply one command:  php bin/phpunit  Elcodi tests are ran against folder  /tmp/Elcodi , so a good practice in this\ncase is to ensure that accesses to this folder are fast enough. For this reason, we can\ncreate a  tmpfs , a mounted file system stored in volatile memory instead of a \npersistent storage device.  rm -Rf /tmp/Elcodi\nsudo mkdir /tmp/Elcodi\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Elcodi/  With this trick, your tests will run extremely faster than before.  Elcodi project uses as well a Testing Booster called FixturesBoosterBundle . This\nproject overwrites the Doctrine command  doctrine:fixtures:load  with a boosted\nversion.  In order to avoid keeping state on a temporal database you may need to remove \ntemporal files generated by this booster on your tmp folder:  rm -rf /tmp/*.backup.database  In addition to this it is required to flush the redis database:  redis-cli flushall  Problems can turn very cryptic if you are using an expired redis database.", 
            "title": "elcodi/elcodi"
        }, 
        {
            "location": "/book/running-test-suite/#elcodibamboo", 
            "text": "Running the test suite for elcodi/bamboo is also simple:  php bin/behat\nphp bin/phpunit -c app/  As explained before, Bamboo tests also can be ran against a  tmpfs  unit.  rm -Rf /tmp/Bamboo\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Bamboo  You can do the same with the cache folder, in order to make all reads really \nfaster.  rm -Rf app/cache\nmkdir app/cache\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/cache  If you want to run a subset of the behat tests you can specify the tag as\nan option:  php bin/behat --tags= store   This will only run the feature scenarios tagged with @store, e.g.:  # bamboo/features/store/cart.feature\n@store @cart\nFeature: Store cart\n  In order to use the cart\n  As a visitor or logged user\n  I need to be able to add products into it and access the checkout\n\n  # ...  A typical use case when to use this feature is when you want to\nrun only the tests that require javascript.", 
            "title": "elcodi/bamboo"
        }, 
        {
            "location": "/book/shipping/", 
            "text": "Shipping\n #\n\n\nBueno, ahora toca implementar un sistema de Shipping.\nSi has llegado a este punto significa que has podido trabajar en algunos de los\npuntos m\u00e1s interesantes de Elcodi, especialmente los relacionados con Cart y \nProduct.\n\n\nEn este apartado explicaremos todo lo relacionado con el Shipping en Elcodi. \nComo a\u00f1adir nuevos m\u00e9todos de env\u00edo de forma desacoplada o como cambiar los \nestados de env\u00edo de un Order ya creado.\n\n\nRequisites\n #\n\n\nPara entender este apartado es importante tener una serie de puntos bien\nasimilados, todos ellos referentes a algunos componentes de Symfony, as\u00ed como\nciertas pr\u00e1cticas de arquitectura.\n\n\nA continuaci\u00f3n te ofrecemos una serie de enlaces donde puedes informarte un poco\nm\u00e1s.\n\n\n\n\nPlugins\n\n\nDependency Injection Symfony Component\n\n\nEvent Dispatcher Symfony Component\n\n\nElcodi State Transition Machine Component\n\n\nFinite State Machine\n\n\n\n\nExample\n #\n\n\nImaginemos que queremos a\u00f1adir un sistema de shipping, cuyo \u00fanico m\u00e9todo se\nllama \nenv\u00edo gratis\n y es a\u00f1adido solo cuando el valor del Cart es superior a\nlos 30 euros y el usuario pertenece o a Barcelona o a Madrid. Esta l\u00f3gica de \nnegocio puede ser tan compleja como sea necesario, por lo que la vamos a \nesconder tras un m\u00e9todo llamado \nisCartSatisfied()\n.\n\n\nLo m\u00e1s normal es que se utilizen librer\u00edas externas de PHP para dichas \nintegraciones, por lo que toda la documentaci\u00f3n al respecto ser\u00e1 relativa a como\nimplementar utilizar dichas integraciones.\n\n\nCalling for Shipping methods\n #\n\n\nUno de los componentes de Elcodi es el de Shipping. Dicho componente tiene un\nsolo objetivo, y es proporcionar al proyecto una forma limpia y desacoplada de\na\u00f1adir opciones de env\u00edo al comprador.\n\n\nPara esto debemos tener acceso al Cart del comprador, pues este ser\u00e1 el objeto\ncon el que podremos determinar cuales de los m\u00e9todos de env\u00edo son accesibles.\n\n\nEn el momento en que nuestro sistema acepta que no habr\u00e1 m\u00e1s cambios de Cart (no\nda opci\u00f3n a a\u00f1adir m\u00e1s productos o coupones), y para recopilar todos los m\u00e9todos\nde env\u00edo accesibles, vamos a tener este trozo de c\u00f3digo.\n\n\n$cart = $this\n    -\ncontainer\n    -\nget(\nelcodi.wrapper.cart\n)\n    -\nget();\n\n$shippingMethods = $this\n    -\nget('elcodi.wrapper.shipping_methods')\n    -\nget($cart);\n\n\n\n\nInternamente, este trozo de c\u00f3digo lanza un evento llamado \n\n\"shipping.collect\"\n, encargado exclusivamente de\nrecolectar todos estos m\u00e9todos de env\u00edo.\n\n\nEs necesario decir que en este punto, el componente Event Dispatcher de Symfony\nno se est\u00e1 utilizando de forma estricta a su definici\u00f3n, pues s\u00e9 utiliza como \ncolector y no como evento. La diferencia es que un evento deber\u00eda ser inmutable\n(un evento pasa y no hay mucho que hacer, solo reaccionar con los event \nlisteners), pero en este caso, el objeto evento tiene un m\u00e9todo \nadd\n, por lo\nque, a\u00fan no importando realmente el orden de ejecuci\u00f3n de los listeners, se est\u00e1\nmodificando el propio evento. Un evento que cambia... esto es raro, verdad?\n\n\n\n\nImplement a collector\n\n\n\n\nPero bueno, el evento de recolecci\u00f3n es lanzado, y todos los Plugins que est\u00e1n\nescuchados son llamados a a\u00f1adir sus m\u00e9todos a partir del Cart proporcionado\npor el evento\n\n\nAdding new Shipping Methods\n #\n\n\nPara t\u00ed, programador, que quieres a\u00f1adir un m\u00e9todo de env\u00edo, este es tu sitio.\nRecuerdas el evento \n\"shipping.collect\"\n? Pues \nbien, debemos escucharlo para a\u00f1adir nuestras formas de env\u00edo.\n\n\nPara nuestro ejemplo, debemos considerar si nuestro Cart cumple las espectativas\nque nosotros queremos, y de ser as\u00ed, a\u00f1adir un nuevo sistema de env\u00edo gratuito.\n\n\nVeamos primero como podemos suscribirnos a este evento utilizando la misma forma\nen que nos suscribimos a cualquier otro evento.\n\n\nservices:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.easy_free_shipping.event_listener.shipping_collect:\n        class: Elcodi\\Plugin\\EasyFreeShipping\\EventListener\\ShippingCollectEventListener\n        tags:\n            - { name: kernel.event_listener, event: shipping.collect, method: addCustomShippingMethods }\n\n\n\n\nBien. En este Event Listener deberemos poner toda nuestra l\u00f3gica de negocio.\nVeamos un simple ejemplo de como podemos hacer dicha implementaci\u00f3n.\n\n\n\nuse Elcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface;\nuse Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Shipping\\Entity\\ShippingMethod;\nuse Elcodi\\Component\\Shipping\\Event\\ShippingCollectionEvent;\n\n/**\n * Class ShippingCollectEventListener\n */\nclass ShippingCollectEventListener\n{\n    /**\n     * Look for available shipping methods, by checking given event's cart\n     *\n     * @param ShippingCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomShippingMethods(ShippingCollectionEvent $event)\n    {\n        $defaultCurrency = // Default currency object\n        $cart = $event-\ngetCart();\n        if (!$this-\nisCartSatisfied($cart)) {\n\n            return;\n        }\n\n        $event\n            -\naddShippingMethod(new ShippingMethod(\n                'easy-free-shipping',\n                'Easy free shipping',\n                'Exclusive Free shipping',\n                'Send your order for free because yes!',\n                Money::create(0, $currency)\n            ));\n    }\n\n    /**\n     * Given Cart satisfies this Bundle needs\n     *\n     * @param CartInterface $cart Cart\n     *\n     * @return boolean Cart satisfies needs\n     */\n    private function isCartSatisfied(CartInterface $cart)\n    {\n        /**\n         * Place all your logic here\n         */\n\n        return $cartSatisfied;\n    }\n}\n\n\n\n\nDentro del m\u00e9todo \nisCartSatisfied()\n deber\u00edamos poner nuestra l\u00f3gica, pero \nrecordemos que no debemos poner nuestro foco en dicha implementaci\u00f3n.\n\n\n\n\nThis example is an abstract implementation. If such implementation comes from\na plugin, after adding all methods you should check the plugin availability.\nCheck the plugin documentation.\n\n\n\n\nAccessing collected methods\n #\n\n\nUna vez hemos recolectado todos nuestros m\u00e9todos de env\u00edo, podemos acceder a \nellos en nuestra p\u00e1gina para que el cliente pueda seleccionar cual de ellos es\nel que quiere utilizar. Veamos un ejemplo, partiendo con la premisa de que en \nnuestro controlador hemos devuelto todos los m\u00e9todos de env\u00edo en un array con\nnombre \nshippingMethods\n.\n\n\n{% if shippingMethods|length \n 0 %}\n\ndiv class=\nform form-checkout\n\n    {% set actualShippingMethod = cart.shippingMethod %}\n    \ndiv class=\ngrid grid-pad\n\n        \nh2\nShipping methods\n/h2\n\n        {% for shippingMethod in shippingMethods %}\n            {% if shippingMethod.id == actualShippingMethod %}\n                \ndiv\n{{ shippingMethod.carrierName }} - {{ shippingMethod.price|print_convert_money }}\n/div\n\n            {% else %}\n                \na href=\n{{ url(\nstore_checkout_shipping_method_apply\n, {\n                        'shippingMethod': shippingMethod.id\n                    }) }}\n\n                        {{ shippingMethod.carrierName }} - {{ shippingMethod.price|print_convert_money }}\n                    \n/a\n/div\n\n            {% endif %}\n        {% endfor %}\n    \n/div\n\n\n/div\n\n{% endif %}\n\n\n\n\nComo pod\u00e9is ver, en todo momento se tiene en cuenta el valor que hay en \n\ncart.shippingMethod\n. En \u00e9l, siempre tenemos referencia al id del m\u00e9todo de\nenv\u00edo que se haya seleccionado. En caso de que a\u00fan no se haya seleccionado \nning\u00fan m\u00e9todo de env\u00edo, cosa que pasar\u00e1 siempre al principio del proceso, todos\nlos tipos estar\u00e1n seleccionables. En caso contrario, se podr\u00e1 cambiar de m\u00e9todo\nseleccionando cualquier otro.\n\n\nOtra forma de acceder a los m\u00e9todos de env\u00edo directamente desde el template es\nutilizando la funci\u00f3n de twig\n\n\n{% set shippingMethods = elcodi_shipping_methods() %}\n\n\n\n\nPara seleccionar un m\u00e9todo de env\u00edo, podemos ver que tenemos disponible una url\ncuyo \u00fanico par\u00e1metro, requerido, es el id del m\u00e9todo de pago que queremos \nseleccionar.\n\n\nSelecting a shipping method\n #\n\n\nVeamos la implementaci\u00f3n que utiliza Elcodi para seleccionar un m\u00e9todo de env\u00edo\nespec\u00edfico.\n\n\n$shippingMethodId = $request\n    -\nquery\n    -\nget('shippingMethod');\n\n$cart = $this\n    -\ncontainer\n    -\nget(\nelcodi.wrapper.cart\n)\n    -\nget();\n\n$shippingMethods = $this\n    -\nget('elcodi.wrapper.shipping_methods')\n    -\ngetOneById($cart, $shippingMethodId);\n\nif ($shippingMethodObject instanceof ShippingMethod) {\n    $cart-\nsetShippingMethod($shippingMethod);\n    $this\n        -\nget('elcodi.object_manager.cart')\n        -\nflush($cart);\n}\n\nreturn $this-\nredirect(\n    $this-\ngenerateUrl('store_checkout_payment')\n);\n\n\n\n\nSencillo, conciso y r\u00e1pido. Como podemos ver, volvemos a utilizar el mismo \nm\u00e9todo para recolectar todos los m\u00e9todos de env\u00edo, pues en este caso, en lugar\nde devolverlos todos, solo devolvemos aquel con el id deseado.\n\n\nSi lo recibimos, quiere decir que existe y es v\u00e1lido para el cart utilizado. En\neste caso, sobreescribiremos la propiedad \nshippingMethod\n de cart y guardaremos\nel valor en base de datos. En caso contrario, b\u00e1sicamente, no hacemos nada.\n\n\nEn ambos casos, volvemos a la p\u00e1gina de pago, ejecutando otra vez el c\u00f3digo de\nvista anterior, aunque, posiblemente, con un resultado un poco distinto\n\n\nReloading Cart prices\n #\n\n\nDado que Elcodi tiene una forma de funcionar bastante desacoplada, no debemos \nhacer nada m\u00e1s para recalcular los precios. En el caso de que seleccione un\nm\u00e9todo de env\u00edo que a\u00f1ada un precio extra al precio final del Cart, \u00e9ste se \ncalcular\u00e1 solo durante los eventos de load del mismo, pues este proceso es \ncompletamente transparente para cualquier plugin que quiera a\u00f1adir m\u00e9todos de\nenv\u00edo.\n\n\nOrder shipping information\n #\n\n\nUna vez nuestro Order se ha transformado correctamente en un Order, deber\u00edamos\nser capaces de saber qu\u00e9 tipo de env\u00edo se utiliz\u00f3 y que precio tuvo en su \nmomento.\n\n\n$orderShippingMethod = $order-\ngetShippingMethod();\n$orderShippingAmount = $order-\ngetShippingAmount();\n\n\n\n\nShipping State Machine\n #\n\n\nAt this point, the order is ready to be shipped. Once starting these last steps\non this documentation, please take a look at the State Transition Machine \ndocumentation.\n\n\n\n\nState Transition Machine\n\n\n\n\nBamboo por defecto propone un diagrama de estados de env\u00edo como el que podemos\nver aqui.\n\n\n\n\n\n\n\n\nFrom\n\n\nAction\n\n\nTo\n\n\n\n\n\n\n\n\n\n\npreparing\n\n\norder ready\n\n\nprocessed\n\n\n\n\n\n\nprocessed\n\n\npicked up by carrier\n\n\nin delivery\n\n\n\n\n\n\nprocessed\n\n\npicked up on store\n\n\ndelivered\n\n\n\n\n\n\nin delivery\n\n\ndelivered\n\n\ndelivered\n\n\n\n\n\n\npreparing\n\n\ncancel\n\n\ncancelled\n\n\n\n\n\n\nprocessed\n\n\ncancel\n\n\ncancelled\n\n\n\n\n\n\nin delivery\n\n\ncancel\n\n\ncancelled\n\n\n\n\n\n\nin delivery\n\n\nreturn\n\n\nreturned\n\n\n\n\n\n\ndelivered\n\n\nreturn\n\n\nreturned\n\n\n\n\n\n\n\n\ny mediante el Container de Symfony tenemos acceso a algunos objetos espec\u00edficos\nde la m\u00e1quina de estados de Shipping.\n\n\n#\n# Order state machine for Shipping\n#\nelcodi.order_shipping_states_machine_builder:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineBuilder\n    arguments:\n        - @elcodi.factory.state_transition_machine\n        - %elcodi.order_shipping_states_machine_identifier%\n        - %elcodi.order_shipping_states_machine_states%\n        - %elcodi.order_shipping_states_machine_point_of_entry%\n\nelcodi.order.shipping_states_machine:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\Machine\n    factory:\n        - @elcodi.order_shipping_states_machine_builder\n        - compile\n\nelcodi.order_shipping_states_machine_manager:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineManager\n    arguments:\n        - @elcodi.order.shipping_states_machine\n        - @event_dispatcher\n        - @elcodi.factory.state_transition_machine_state_line\n\n\n\n\nUpdating the Shipping state\n #\n\n\nCon dicho acceso a la m\u00e1quina de estados de env\u00edo, podemos cambiar el order de\nestados utilizando el servicio \nelcodi.order_shipping_states_machine\n.\n\n\nVeamos un ejemplo de como avanzar a un estado \ndelivered\n teniendo en cuenta que\nnuestro Order est\u00e1 actualmente en el estado \nprocessed\n.\n\n\n$order = // Order instance;\n\n$stateLineStack = $this\n    -\nget('elcodi.order_shipping_states_machine_manager')\n    -\ntransition(\n        $order,\n        $order-\ngetShippingStateLineStack(),\n        'picked up on store',\n        'Order picked up on store'\n    );\n$order-\nsetShippingStateLineStack($stateLineStack);\n$this\n    -\nget('elcodi.object_manager.order')\n    -\nflush($order);\n\n\n\n\nSolo si dicha transici\u00f3n es posible todo funcionar\u00e1 debidamente. En caso \ncontrario las excepciones pertinentes saltar\u00e1n.", 
            "title": "Shipping"
        }, 
        {
            "location": "/book/shipping/#shipping", 
            "text": "Bueno, ahora toca implementar un sistema de Shipping.\nSi has llegado a este punto significa que has podido trabajar en algunos de los\npuntos m\u00e1s interesantes de Elcodi, especialmente los relacionados con Cart y \nProduct.  En este apartado explicaremos todo lo relacionado con el Shipping en Elcodi. \nComo a\u00f1adir nuevos m\u00e9todos de env\u00edo de forma desacoplada o como cambiar los \nestados de env\u00edo de un Order ya creado.", 
            "title": "Shipping"
        }, 
        {
            "location": "/book/shipping/#requisites", 
            "text": "Para entender este apartado es importante tener una serie de puntos bien\nasimilados, todos ellos referentes a algunos componentes de Symfony, as\u00ed como\nciertas pr\u00e1cticas de arquitectura.  A continuaci\u00f3n te ofrecemos una serie de enlaces donde puedes informarte un poco\nm\u00e1s.   Plugins  Dependency Injection Symfony Component  Event Dispatcher Symfony Component  Elcodi State Transition Machine Component  Finite State Machine", 
            "title": "Requisites"
        }, 
        {
            "location": "/book/shipping/#example", 
            "text": "Imaginemos que queremos a\u00f1adir un sistema de shipping, cuyo \u00fanico m\u00e9todo se\nllama  env\u00edo gratis  y es a\u00f1adido solo cuando el valor del Cart es superior a\nlos 30 euros y el usuario pertenece o a Barcelona o a Madrid. Esta l\u00f3gica de \nnegocio puede ser tan compleja como sea necesario, por lo que la vamos a \nesconder tras un m\u00e9todo llamado  isCartSatisfied() .  Lo m\u00e1s normal es que se utilizen librer\u00edas externas de PHP para dichas \nintegraciones, por lo que toda la documentaci\u00f3n al respecto ser\u00e1 relativa a como\nimplementar utilizar dichas integraciones.", 
            "title": "Example"
        }, 
        {
            "location": "/book/shipping/#calling-for-shipping-methods", 
            "text": "Uno de los componentes de Elcodi es el de Shipping. Dicho componente tiene un\nsolo objetivo, y es proporcionar al proyecto una forma limpia y desacoplada de\na\u00f1adir opciones de env\u00edo al comprador.  Para esto debemos tener acceso al Cart del comprador, pues este ser\u00e1 el objeto\ncon el que podremos determinar cuales de los m\u00e9todos de env\u00edo son accesibles.  En el momento en que nuestro sistema acepta que no habr\u00e1 m\u00e1s cambios de Cart (no\nda opci\u00f3n a a\u00f1adir m\u00e1s productos o coupones), y para recopilar todos los m\u00e9todos\nde env\u00edo accesibles, vamos a tener este trozo de c\u00f3digo.  $cart = $this\n    - container\n    - get( elcodi.wrapper.cart )\n    - get();\n\n$shippingMethods = $this\n    - get('elcodi.wrapper.shipping_methods')\n    - get($cart);  Internamente, este trozo de c\u00f3digo lanza un evento llamado  \"shipping.collect\" , encargado exclusivamente de\nrecolectar todos estos m\u00e9todos de env\u00edo.  Es necesario decir que en este punto, el componente Event Dispatcher de Symfony\nno se est\u00e1 utilizando de forma estricta a su definici\u00f3n, pues s\u00e9 utiliza como \ncolector y no como evento. La diferencia es que un evento deber\u00eda ser inmutable\n(un evento pasa y no hay mucho que hacer, solo reaccionar con los event \nlisteners), pero en este caso, el objeto evento tiene un m\u00e9todo  add , por lo\nque, a\u00fan no importando realmente el orden de ejecuci\u00f3n de los listeners, se est\u00e1\nmodificando el propio evento. Un evento que cambia... esto es raro, verdad?   Implement a collector   Pero bueno, el evento de recolecci\u00f3n es lanzado, y todos los Plugins que est\u00e1n\nescuchados son llamados a a\u00f1adir sus m\u00e9todos a partir del Cart proporcionado\npor el evento", 
            "title": "Calling for Shipping methods"
        }, 
        {
            "location": "/book/shipping/#adding-new-shipping-methods", 
            "text": "Para t\u00ed, programador, que quieres a\u00f1adir un m\u00e9todo de env\u00edo, este es tu sitio.\nRecuerdas el evento  \"shipping.collect\" ? Pues \nbien, debemos escucharlo para a\u00f1adir nuestras formas de env\u00edo.  Para nuestro ejemplo, debemos considerar si nuestro Cart cumple las espectativas\nque nosotros queremos, y de ser as\u00ed, a\u00f1adir un nuevo sistema de env\u00edo gratuito.  Veamos primero como podemos suscribirnos a este evento utilizando la misma forma\nen que nos suscribimos a cualquier otro evento.  services:\n\n    #\n    # Event Listeners\n    #\n    elcodi_plugin.easy_free_shipping.event_listener.shipping_collect:\n        class: Elcodi\\Plugin\\EasyFreeShipping\\EventListener\\ShippingCollectEventListener\n        tags:\n            - { name: kernel.event_listener, event: shipping.collect, method: addCustomShippingMethods }  Bien. En este Event Listener deberemos poner toda nuestra l\u00f3gica de negocio.\nVeamos un simple ejemplo de como podemos hacer dicha implementaci\u00f3n.  \nuse Elcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface;\nuse Elcodi\\Component\\Currency\\Entity\\Money;\nuse Elcodi\\Component\\Shipping\\Entity\\ShippingMethod;\nuse Elcodi\\Component\\Shipping\\Event\\ShippingCollectionEvent;\n\n/**\n * Class ShippingCollectEventListener\n */\nclass ShippingCollectEventListener\n{\n    /**\n     * Look for available shipping methods, by checking given event's cart\n     *\n     * @param ShippingCollectionEvent $event Event\n     *\n     * @return $this Self object\n     */\n    public function addCustomShippingMethods(ShippingCollectionEvent $event)\n    {\n        $defaultCurrency = // Default currency object\n        $cart = $event- getCart();\n        if (!$this- isCartSatisfied($cart)) {\n\n            return;\n        }\n\n        $event\n            - addShippingMethod(new ShippingMethod(\n                'easy-free-shipping',\n                'Easy free shipping',\n                'Exclusive Free shipping',\n                'Send your order for free because yes!',\n                Money::create(0, $currency)\n            ));\n    }\n\n    /**\n     * Given Cart satisfies this Bundle needs\n     *\n     * @param CartInterface $cart Cart\n     *\n     * @return boolean Cart satisfies needs\n     */\n    private function isCartSatisfied(CartInterface $cart)\n    {\n        /**\n         * Place all your logic here\n         */\n\n        return $cartSatisfied;\n    }\n}  Dentro del m\u00e9todo  isCartSatisfied()  deber\u00edamos poner nuestra l\u00f3gica, pero \nrecordemos que no debemos poner nuestro foco en dicha implementaci\u00f3n.   This example is an abstract implementation. If such implementation comes from\na plugin, after adding all methods you should check the plugin availability.\nCheck the plugin documentation.", 
            "title": "Adding new Shipping Methods"
        }, 
        {
            "location": "/book/shipping/#accessing-collected-methods", 
            "text": "Una vez hemos recolectado todos nuestros m\u00e9todos de env\u00edo, podemos acceder a \nellos en nuestra p\u00e1gina para que el cliente pueda seleccionar cual de ellos es\nel que quiere utilizar. Veamos un ejemplo, partiendo con la premisa de que en \nnuestro controlador hemos devuelto todos los m\u00e9todos de env\u00edo en un array con\nnombre  shippingMethods .  {% if shippingMethods|length   0 %} div class= form form-checkout \n    {% set actualShippingMethod = cart.shippingMethod %}\n     div class= grid grid-pad \n         h2 Shipping methods /h2 \n        {% for shippingMethod in shippingMethods %}\n            {% if shippingMethod.id == actualShippingMethod %}\n                 div {{ shippingMethod.carrierName }} - {{ shippingMethod.price|print_convert_money }} /div \n            {% else %}\n                 a href= {{ url( store_checkout_shipping_method_apply , {\n                        'shippingMethod': shippingMethod.id\n                    }) }} \n                        {{ shippingMethod.carrierName }} - {{ shippingMethod.price|print_convert_money }}\n                     /a /div \n            {% endif %}\n        {% endfor %}\n     /div  /div \n{% endif %}  Como pod\u00e9is ver, en todo momento se tiene en cuenta el valor que hay en  cart.shippingMethod . En \u00e9l, siempre tenemos referencia al id del m\u00e9todo de\nenv\u00edo que se haya seleccionado. En caso de que a\u00fan no se haya seleccionado \nning\u00fan m\u00e9todo de env\u00edo, cosa que pasar\u00e1 siempre al principio del proceso, todos\nlos tipos estar\u00e1n seleccionables. En caso contrario, se podr\u00e1 cambiar de m\u00e9todo\nseleccionando cualquier otro.  Otra forma de acceder a los m\u00e9todos de env\u00edo directamente desde el template es\nutilizando la funci\u00f3n de twig  {% set shippingMethods = elcodi_shipping_methods() %}  Para seleccionar un m\u00e9todo de env\u00edo, podemos ver que tenemos disponible una url\ncuyo \u00fanico par\u00e1metro, requerido, es el id del m\u00e9todo de pago que queremos \nseleccionar.", 
            "title": "Accessing collected methods"
        }, 
        {
            "location": "/book/shipping/#selecting-a-shipping-method", 
            "text": "Veamos la implementaci\u00f3n que utiliza Elcodi para seleccionar un m\u00e9todo de env\u00edo\nespec\u00edfico.  $shippingMethodId = $request\n    - query\n    - get('shippingMethod');\n\n$cart = $this\n    - container\n    - get( elcodi.wrapper.cart )\n    - get();\n\n$shippingMethods = $this\n    - get('elcodi.wrapper.shipping_methods')\n    - getOneById($cart, $shippingMethodId);\n\nif ($shippingMethodObject instanceof ShippingMethod) {\n    $cart- setShippingMethod($shippingMethod);\n    $this\n        - get('elcodi.object_manager.cart')\n        - flush($cart);\n}\n\nreturn $this- redirect(\n    $this- generateUrl('store_checkout_payment')\n);  Sencillo, conciso y r\u00e1pido. Como podemos ver, volvemos a utilizar el mismo \nm\u00e9todo para recolectar todos los m\u00e9todos de env\u00edo, pues en este caso, en lugar\nde devolverlos todos, solo devolvemos aquel con el id deseado.  Si lo recibimos, quiere decir que existe y es v\u00e1lido para el cart utilizado. En\neste caso, sobreescribiremos la propiedad  shippingMethod  de cart y guardaremos\nel valor en base de datos. En caso contrario, b\u00e1sicamente, no hacemos nada.  En ambos casos, volvemos a la p\u00e1gina de pago, ejecutando otra vez el c\u00f3digo de\nvista anterior, aunque, posiblemente, con un resultado un poco distinto", 
            "title": "Selecting a shipping method"
        }, 
        {
            "location": "/book/shipping/#reloading-cart-prices", 
            "text": "Dado que Elcodi tiene una forma de funcionar bastante desacoplada, no debemos \nhacer nada m\u00e1s para recalcular los precios. En el caso de que seleccione un\nm\u00e9todo de env\u00edo que a\u00f1ada un precio extra al precio final del Cart, \u00e9ste se \ncalcular\u00e1 solo durante los eventos de load del mismo, pues este proceso es \ncompletamente transparente para cualquier plugin que quiera a\u00f1adir m\u00e9todos de\nenv\u00edo.", 
            "title": "Reloading Cart prices"
        }, 
        {
            "location": "/book/shipping/#order-shipping-information", 
            "text": "Una vez nuestro Order se ha transformado correctamente en un Order, deber\u00edamos\nser capaces de saber qu\u00e9 tipo de env\u00edo se utiliz\u00f3 y que precio tuvo en su \nmomento.  $orderShippingMethod = $order- getShippingMethod();\n$orderShippingAmount = $order- getShippingAmount();", 
            "title": "Order shipping information"
        }, 
        {
            "location": "/book/shipping/#shipping-state-machine", 
            "text": "At this point, the order is ready to be shipped. Once starting these last steps\non this documentation, please take a look at the State Transition Machine \ndocumentation.   State Transition Machine   Bamboo por defecto propone un diagrama de estados de env\u00edo como el que podemos\nver aqui.     From  Action  To      preparing  order ready  processed    processed  picked up by carrier  in delivery    processed  picked up on store  delivered    in delivery  delivered  delivered    preparing  cancel  cancelled    processed  cancel  cancelled    in delivery  cancel  cancelled    in delivery  return  returned    delivered  return  returned     y mediante el Container de Symfony tenemos acceso a algunos objetos espec\u00edficos\nde la m\u00e1quina de estados de Shipping.  #\n# Order state machine for Shipping\n#\nelcodi.order_shipping_states_machine_builder:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineBuilder\n    arguments:\n        - @elcodi.factory.state_transition_machine\n        - %elcodi.order_shipping_states_machine_identifier%\n        - %elcodi.order_shipping_states_machine_states%\n        - %elcodi.order_shipping_states_machine_point_of_entry%\n\nelcodi.order.shipping_states_machine:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\Machine\n    factory:\n        - @elcodi.order_shipping_states_machine_builder\n        - compile\n\nelcodi.order_shipping_states_machine_manager:\n    class: Elcodi\\Component\\StateTransitionMachine\\Machine\\MachineManager\n    arguments:\n        - @elcodi.order.shipping_states_machine\n        - @event_dispatcher\n        - @elcodi.factory.state_transition_machine_state_line", 
            "title": "Shipping State Machine"
        }, 
        {
            "location": "/book/shipping/#updating-the-shipping-state", 
            "text": "Con dicho acceso a la m\u00e1quina de estados de env\u00edo, podemos cambiar el order de\nestados utilizando el servicio  elcodi.order_shipping_states_machine .  Veamos un ejemplo de como avanzar a un estado  delivered  teniendo en cuenta que\nnuestro Order est\u00e1 actualmente en el estado  processed .  $order = // Order instance;\n\n$stateLineStack = $this\n    - get('elcodi.order_shipping_states_machine_manager')\n    - transition(\n        $order,\n        $order- getShippingStateLineStack(),\n        'picked up on store',\n        'Order picked up on store'\n    );\n$order- setShippingStateLineStack($stateLineStack);\n$this\n    - get('elcodi.object_manager.order')\n    - flush($order);  Solo si dicha transici\u00f3n es posible todo funcionar\u00e1 debidamente. En caso \ncontrario las excepciones pertinentes saltar\u00e1n.", 
            "title": "Updating the Shipping state"
        }, 
        {
            "location": "/book/standards/", 
            "text": "Elcodi Standards\n #\n\n\nWe have noticed that everyone has a different way of developing. In our team, \nsome people place the braces at the end of the class definition, while other\npeople place them in a new line.\n\n\nIs anyone wrong? Absolutely not, even PHP has standards since long time\nago, and besides anyone should also be able to work the way they want.\n\n\nBut in Elcodi we have some standards for our code.\n\n\nPackages Structure\n #\n\n\nA component must be treated as a simple PHP library. This means that it must be\nframework agnostic. At the beginning, Elcodi was a set of Bundles, divided by\nconcerns or boundaries, and implemented as a single Symfony-framework Bundle.\n\n\nThis was the root of some disagreements, and of course, like every single\nimplementation of Open Source, but we noticed that there was an opinion repeated\nonce and again by some users.\n\n\n\n\nThis project is Framework dependent.\n\n\n\n\nWe thought that being a Symfony dependent project was a good idea, but we had to \ndecide what to be dependent on. Finally, we decided that Elcodi had to be\ncoupled to Symfony components and Doctrine library, so we had to split between\nsimple PHP libraries (Components) and Symfony Framework adaptations of these\nlibraries (Bundles).\n\n\nComponent Structure\n #\n\n\nAs we have said before, a component is just a PHP library. Think about it, we could use the Cart\nclasses in our own project, far from Symfony Framework, and because we don't \nwant all the Framework dependencies inside our \nvendor/\n folder, maybe we should\nonly require the classes and their dependencies.\n\n\nThis is what a component is. Just classes.\n\n\nSo inside a component you will find a simple categorization of objects. All \ncomponents follow the same structure.\n\n\nCart\n  |\n  |- Entity\n  |    |- Interfaces\n  |    |    |- CartInterface.php\n  |    |- Abstracts\n  |    |    |- AbstractCart.php\n  |    |- Cart.php\n  |\n  |- Factory\n  |    |- CartFactory.php\n  |\n  |- Repository\n  |    |- CartRepository.php\n  |\n  |- Services\n  |    |- CartManager.php\n  |\n  |- Wrapper\n  |    |- CartWrapper.php\n  |\n  |- Transformer\n  |    |- CartOrderTransformer.php\n  |\n  |- Event\n  |    |- OnOrderCreatedEvent.php\n  |\n  |- EventListener\n  |    |- CartEventListener.php\n  |\n  |- EventDispatcher\n  |    |- CartEventDispatcher.php\n  |\n  |- Controller\n  |    |- ImageUploadController.php\n  |\n  |- Command\n       |- SitemapProfileCommand.php\n\n\n\n\nThis is just a sample of how a Component is structured, and how you should \nstructure your project if you want to follow our way of doing things.\n\n\n\n\nThis does not mean that this one is the best way of structuring your code, or\ndoes not mean that there is not another way of doing it. Is just our\nimplementation and the one we suggest you.\n\n\n\n\nClasses Standards\n #\n\n\nIn order to create homogeneous code, we've defined a set of rules when creating\nand naming classes.\n\n\nAbstracts\n #\n\n\nMaybe is not the best standard, but we strongly believe that the name of a class\nshould explain its mission as much as possible. Because this\nis an OpenSource project we must take care about all different skilled \ndevelopers so the name of an abstract class, even if it is redundant, will have\nthe word \nAbstract\n at the end of the name.\n\n\nabstract class AbstractFactory\n{\n}\n\n\n\n\nFurthermore, any abstract class will be placed in a folder called \nAbstracts/\n,\nto make them easier to find.\n\n\n\\Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory\n\n\n\n\n\n\nThe namespace must be Abstracts instead of Abstract because Abstract is a PHP\nreserved keyword\n\n\n\n\nTraits\n #\n\n\nSame as Abstract classes. All Traits will have the word \nTrait\n at the end of \nthe name\n\n\ntrait DateTimeTrait\n{\n}\n\n\n\n\nFurthermore, any trait will be placed in a folder called \nTraits/\n, to make them \neasier to find.\n\n\n\\Elcodi\\Component\\Core\\Entity\\Traits\\DateTimeTrait\n\n\n\n\n\n\nThe namespace must be Traits instead of Trait because Trait is a PHP reserved \nkeyword\n\n\n\n\nThere is a limitation in the definition of Traits in PHP, and it is that\nthere is a collision problem of namespaces. Because they are virtually \ncopy/pasted to the final class, you can have some problems if you work with\nnamespaces inside the Trait classes.\n\n\nThe way of solving this is never using use statements in a Trait, and always \nusing all the namespace when referencing a PHP namespace.\n\n\ntrait PriceTrait\n{\n    /**\n     * @var \\Elcodi\\Component\\Currency\\Entity\\Interfaces\\CurrencyInterface\n     *\n     * Currency for the amounts stored in this entity\n     */\n    protected $productCurrency;\n\n\n\n\nInterfaces\n #\n\n\nSame as Abstract classes. All Interfaces will have the word \nInterface\n at the \nend of the name\n\n\ninterface OrderInterface\n{\n}\n\n\n\n\nFurthermore, any interface will be placed in a folder called \nInterfaces/\n, to \nmake them easier to find.\n\n\n\\Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface\n\n\n\n\n\n\nThe namespace must be Interfaces instead of Interface because Interface is a \nPHP reserved keyword\n\n\n\n\nBundles\n #\n\n\nEach Bundle should avoid the magic of auto-discovering, placed in the class\n\nSymfony\\Component\\HttpKernel\\Bundle\\Bundle\n.\n\n\nYes, we're talking about these methods:\n\n\n\n\ngetContainerExtension()\n\n\nregisterCommands()\n\n\n\n\nIn order to forget about magic there, and to clearly define our Bundles, we will\nalways overwrite these methods, returning specifically the data is intended to\nreturn, even if methods are empty.\n\n\nuse Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\ElcodiCoreExtension;\n\n/**\n * ElcodiCoreBundle Bundle\n *\n * This is the core of the suite.\n * All available bundles in this suite could have this bundle as a main\n * dependency.\n */\nclass ElcodiCoreBundle extends Bundle\n{\n    /**\n     * Returns the bundle's container extension.\n     *\n     * @return ExtensionInterface The container extension\n     */\n    public function getContainerExtension()\n    {\n        return new ElcodiCoreExtension();\n    }\n\n    /**\n     * Register Commands.\n     *\n     * Disabled as commands are registered as services\n     *\n     * @param Application $application An Application instance\n     */\n    public function registerCommands(Application $application)\n    {\n        return;\n    }\n}\n\n\n\n\nDependency Injection\n #\n\n\nWe care as well on how Elcodi services are defined in the Symfony \nDependency Injection container, in order to make easier for the final user to\nremember the name of the service given the namespace of the class.\n\n\nFirst of all what you need to know is that all services in Elcodi ecosystem \nstart with \nelcodi.\n.\n\n\nFor example\n\n\nelcodi.event_dispatcher.cart\nelcodi.manager.cart\n\n\n\n\nWe have structured all definitions in two, three or four levels.\n\n\nTwo levels services\n #\n\n\nElcodi specific and most important services in Elcodi ecosystem. These services\ncannot be grouped by any kind of \nnamespace\n because they are not an \nimplementation of any family.\n\n\nelcodi.languages\nelcodi.languages_iso\nelcodi.languages_iso_array\nelcodi.locale\n\n\n\n\nThree levels services\n #\n\n\nMost of services will have three levels of definition. Let's analyze previous\nexamples:\n\n\nelcodi.event_dispatcher.cart\n\n\n\n\nFirst level\n is always \nelcodi\n. This will help you identifying all Elcodi's\ndefinition spectre.\n\n\nSecond level\n is the group or the final meaning of such service. For example,\nin this example our service will be an EventDispatcher.\nWe have some examples of different kind of services in our project\n\n\nelcodi.event_dispatcher.cart\nelcodi.event_listener.address_clone_update_carts\nelcodi.manager.cart\nelcodi.wrapper.cart\nelcodi.factory.cart\nelcodi.repository.cart\nelcodi.object_manager.cart\nelcodi.director.cart\nelcodi.transformer.cart_order\n\n\n\n\nThird level\n is the name of given type. In last example we were creating, for\nexample, the cart factory, or the cart event dispatcher. This last element has\nnothing to do with the name of the component, and must be extremely related with\nthe content of the class.\n\n\nSmall classes and methods\n #\n\n\nEach class should be small enough to contain specific information. Remember to\nuse small methods (no more than 20 lines) and to take care of their complexity.\nThe more complex a method is, the harder to understand what is all\nabout.\n\n\nPHPDoc\n #\n\n\nThis is an important part of the project.\n\n\nAll methods must be explained for humans. Some people think that the code should\nbe self-explanatory, and we agree on that. This doesn't mean that all people \nshould read the code to understand what a method is intended for.\n\n\nPretending them to understand our method by its code is to prevent them to focus \non their own business logic, and can hinder development speed.\n\n\nAll methods must follow these rules as well, related to PHP Doc format\n\n\n/**\n * This is my detailed description about what my code is intended for\n * I can use as many lines as possible.\n * I repeat, as many lines as possible.\n *\n * @param MyObject $myObject My object description\n * @param string   $info     Some information\n * @param integer  $number   Some number\n *\n * @return Factory Description of the result\n *\n * @throws AnException Scenario when this exception is thrown\n */\n\n\n\n\nUsing this kind of blocks there are some tips we all need to take into account.\n\n\n\n\nThere is a space between all blocks\n\n\nThe order is: Description, Params, Return and Exceptions\n\n\nAll params should be aligned as shown in the example\n\n\nNever use @inheritBlock. It is not useful at all and makes the\ncomprehension of the code so difficult\n\n\n\n\nTools\n #\n\n\nWe provide you a way of converting your way of programming to ours. Why don't \nyou use these tools?\n\n\nPHP-CS-Fixer\n #\n\n\n\n\n(Github repository)[https://github.com/FriendsOfPHP/PHP-CS-Fixer]\n\n\n\n\nThis library analyzes all the PHP source and tries to fix coding standards \nissues, using a custom definition set in the root of the project.\n\n\n?php\n\nreturn Symfony\\CS\\Config\\Config::create()\n    // use SYMFONY_LEVEL:\n    -\nlevel(Symfony\\CS\\FixerInterface::SYMFONY_LEVEL)\n    // and extra fixers:\n    -\nfixers(array(\n        'concat_with_spaces',\n        'multiline_spaces_before_semicolon',\n        'short_array_syntax',\n        '-remove_lines_between_uses'\n    ))\n    -\nfinder(\n        Symfony\\CS\\Finder\\DefaultFinder::create()\n            -\nin('src/')\n    )\n;\n\n\n\n\nThis library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows\n\n\nphp bin/php-cs-fixer fix\n\n\n\n\nBecause the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.\n\n\nPHP-Formatter\n #\n\n\n\n\n(Github repository)[https://github.com/mmoreram/php-formatter]\n\n\n\n\nAnother simple php formatter. This one will just format your class headers, \nsetting the project headers in your PHP classes, and will sort all use statements in\norder to comply with a given specification.\n\n\nThis library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows:\n\n\nphp bin/php-formatter formatter:use:sort src/\nphp bin/php-formatter formatter:header:fix src/\n\n\n\n\nBecause the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.", 
            "title": "Standards"
        }, 
        {
            "location": "/book/standards/#elcodi-standards", 
            "text": "We have noticed that everyone has a different way of developing. In our team, \nsome people place the braces at the end of the class definition, while other\npeople place them in a new line.  Is anyone wrong? Absolutely not, even PHP has standards since long time\nago, and besides anyone should also be able to work the way they want.  But in Elcodi we have some standards for our code.", 
            "title": "Elcodi Standards"
        }, 
        {
            "location": "/book/standards/#packages-structure", 
            "text": "A component must be treated as a simple PHP library. This means that it must be\nframework agnostic. At the beginning, Elcodi was a set of Bundles, divided by\nconcerns or boundaries, and implemented as a single Symfony-framework Bundle.  This was the root of some disagreements, and of course, like every single\nimplementation of Open Source, but we noticed that there was an opinion repeated\nonce and again by some users.   This project is Framework dependent.   We thought that being a Symfony dependent project was a good idea, but we had to \ndecide what to be dependent on. Finally, we decided that Elcodi had to be\ncoupled to Symfony components and Doctrine library, so we had to split between\nsimple PHP libraries (Components) and Symfony Framework adaptations of these\nlibraries (Bundles).", 
            "title": "Packages Structure"
        }, 
        {
            "location": "/book/standards/#component-structure", 
            "text": "As we have said before, a component is just a PHP library. Think about it, we could use the Cart\nclasses in our own project, far from Symfony Framework, and because we don't \nwant all the Framework dependencies inside our  vendor/  folder, maybe we should\nonly require the classes and their dependencies.  This is what a component is. Just classes.  So inside a component you will find a simple categorization of objects. All \ncomponents follow the same structure.  Cart\n  |\n  |- Entity\n  |    |- Interfaces\n  |    |    |- CartInterface.php\n  |    |- Abstracts\n  |    |    |- AbstractCart.php\n  |    |- Cart.php\n  |\n  |- Factory\n  |    |- CartFactory.php\n  |\n  |- Repository\n  |    |- CartRepository.php\n  |\n  |- Services\n  |    |- CartManager.php\n  |\n  |- Wrapper\n  |    |- CartWrapper.php\n  |\n  |- Transformer\n  |    |- CartOrderTransformer.php\n  |\n  |- Event\n  |    |- OnOrderCreatedEvent.php\n  |\n  |- EventListener\n  |    |- CartEventListener.php\n  |\n  |- EventDispatcher\n  |    |- CartEventDispatcher.php\n  |\n  |- Controller\n  |    |- ImageUploadController.php\n  |\n  |- Command\n       |- SitemapProfileCommand.php  This is just a sample of how a Component is structured, and how you should \nstructure your project if you want to follow our way of doing things.   This does not mean that this one is the best way of structuring your code, or\ndoes not mean that there is not another way of doing it. Is just our\nimplementation and the one we suggest you.", 
            "title": "Component Structure"
        }, 
        {
            "location": "/book/standards/#classes-standards", 
            "text": "In order to create homogeneous code, we've defined a set of rules when creating\nand naming classes.  Abstracts  #  Maybe is not the best standard, but we strongly believe that the name of a class\nshould explain its mission as much as possible. Because this\nis an OpenSource project we must take care about all different skilled \ndevelopers so the name of an abstract class, even if it is redundant, will have\nthe word  Abstract  at the end of the name.  abstract class AbstractFactory\n{\n}  Furthermore, any abstract class will be placed in a folder called  Abstracts/ ,\nto make them easier to find.  \\Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory   The namespace must be Abstracts instead of Abstract because Abstract is a PHP\nreserved keyword   Traits  #  Same as Abstract classes. All Traits will have the word  Trait  at the end of \nthe name  trait DateTimeTrait\n{\n}  Furthermore, any trait will be placed in a folder called  Traits/ , to make them \neasier to find.  \\Elcodi\\Component\\Core\\Entity\\Traits\\DateTimeTrait   The namespace must be Traits instead of Trait because Trait is a PHP reserved \nkeyword   There is a limitation in the definition of Traits in PHP, and it is that\nthere is a collision problem of namespaces. Because they are virtually \ncopy/pasted to the final class, you can have some problems if you work with\nnamespaces inside the Trait classes.  The way of solving this is never using use statements in a Trait, and always \nusing all the namespace when referencing a PHP namespace.  trait PriceTrait\n{\n    /**\n     * @var \\Elcodi\\Component\\Currency\\Entity\\Interfaces\\CurrencyInterface\n     *\n     * Currency for the amounts stored in this entity\n     */\n    protected $productCurrency;  Interfaces  #  Same as Abstract classes. All Interfaces will have the word  Interface  at the \nend of the name  interface OrderInterface\n{\n}  Furthermore, any interface will be placed in a folder called  Interfaces/ , to \nmake them easier to find.  \\Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface   The namespace must be Interfaces instead of Interface because Interface is a \nPHP reserved keyword   Bundles  #  Each Bundle should avoid the magic of auto-discovering, placed in the class Symfony\\Component\\HttpKernel\\Bundle\\Bundle .  Yes, we're talking about these methods:   getContainerExtension()  registerCommands()   In order to forget about magic there, and to clearly define our Bundles, we will\nalways overwrite these methods, returning specifically the data is intended to\nreturn, even if methods are empty.  use Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\ElcodiCoreExtension;\n\n/**\n * ElcodiCoreBundle Bundle\n *\n * This is the core of the suite.\n * All available bundles in this suite could have this bundle as a main\n * dependency.\n */\nclass ElcodiCoreBundle extends Bundle\n{\n    /**\n     * Returns the bundle's container extension.\n     *\n     * @return ExtensionInterface The container extension\n     */\n    public function getContainerExtension()\n    {\n        return new ElcodiCoreExtension();\n    }\n\n    /**\n     * Register Commands.\n     *\n     * Disabled as commands are registered as services\n     *\n     * @param Application $application An Application instance\n     */\n    public function registerCommands(Application $application)\n    {\n        return;\n    }\n}", 
            "title": "Classes Standards"
        }, 
        {
            "location": "/book/standards/#dependency-injection", 
            "text": "We care as well on how Elcodi services are defined in the Symfony \nDependency Injection container, in order to make easier for the final user to\nremember the name of the service given the namespace of the class.  First of all what you need to know is that all services in Elcodi ecosystem \nstart with  elcodi. .  For example  elcodi.event_dispatcher.cart\nelcodi.manager.cart  We have structured all definitions in two, three or four levels.  Two levels services  #  Elcodi specific and most important services in Elcodi ecosystem. These services\ncannot be grouped by any kind of  namespace  because they are not an \nimplementation of any family.  elcodi.languages\nelcodi.languages_iso\nelcodi.languages_iso_array\nelcodi.locale  Three levels services  #  Most of services will have three levels of definition. Let's analyze previous\nexamples:  elcodi.event_dispatcher.cart  First level  is always  elcodi . This will help you identifying all Elcodi's\ndefinition spectre.  Second level  is the group or the final meaning of such service. For example,\nin this example our service will be an EventDispatcher.\nWe have some examples of different kind of services in our project  elcodi.event_dispatcher.cart\nelcodi.event_listener.address_clone_update_carts\nelcodi.manager.cart\nelcodi.wrapper.cart\nelcodi.factory.cart\nelcodi.repository.cart\nelcodi.object_manager.cart\nelcodi.director.cart\nelcodi.transformer.cart_order  Third level  is the name of given type. In last example we were creating, for\nexample, the cart factory, or the cart event dispatcher. This last element has\nnothing to do with the name of the component, and must be extremely related with\nthe content of the class.  Small classes and methods  #  Each class should be small enough to contain specific information. Remember to\nuse small methods (no more than 20 lines) and to take care of their complexity.\nThe more complex a method is, the harder to understand what is all\nabout.  PHPDoc  #  This is an important part of the project.  All methods must be explained for humans. Some people think that the code should\nbe self-explanatory, and we agree on that. This doesn't mean that all people \nshould read the code to understand what a method is intended for.  Pretending them to understand our method by its code is to prevent them to focus \non their own business logic, and can hinder development speed.  All methods must follow these rules as well, related to PHP Doc format  /**\n * This is my detailed description about what my code is intended for\n * I can use as many lines as possible.\n * I repeat, as many lines as possible.\n *\n * @param MyObject $myObject My object description\n * @param string   $info     Some information\n * @param integer  $number   Some number\n *\n * @return Factory Description of the result\n *\n * @throws AnException Scenario when this exception is thrown\n */  Using this kind of blocks there are some tips we all need to take into account.   There is a space between all blocks  The order is: Description, Params, Return and Exceptions  All params should be aligned as shown in the example  Never use @inheritBlock. It is not useful at all and makes the\ncomprehension of the code so difficult", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/book/standards/#tools", 
            "text": "We provide you a way of converting your way of programming to ours. Why don't \nyou use these tools?  PHP-CS-Fixer  #   (Github repository)[https://github.com/FriendsOfPHP/PHP-CS-Fixer]   This library analyzes all the PHP source and tries to fix coding standards \nissues, using a custom definition set in the root of the project.  ?php\n\nreturn Symfony\\CS\\Config\\Config::create()\n    // use SYMFONY_LEVEL:\n    - level(Symfony\\CS\\FixerInterface::SYMFONY_LEVEL)\n    // and extra fixers:\n    - fixers(array(\n        'concat_with_spaces',\n        'multiline_spaces_before_semicolon',\n        'short_array_syntax',\n        '-remove_lines_between_uses'\n    ))\n    - finder(\n        Symfony\\CS\\Finder\\DefaultFinder::create()\n            - in('src/')\n    )\n;  This library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows  php bin/php-cs-fixer fix  Because the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.  PHP-Formatter  #   (Github repository)[https://github.com/mmoreram/php-formatter]   Another simple php formatter. This one will just format your class headers, \nsetting the project headers in your PHP classes, and will sort all use statements in\norder to comply with a given specification.  This library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows:  php bin/php-formatter formatter:use:sort src/\nphp bin/php-formatter formatter:header:fix src/  Because the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.", 
            "title": "Tools"
        }, 
        {
            "location": "/book/templates/", 
            "text": "Templates\n #", 
            "title": "Templates"
        }, 
        {
            "location": "/book/templates/#templates", 
            "text": "", 
            "title": "Templates"
        }, 
        {
            "location": "/book/translate-elcodi/", 
            "text": "Translate Elcodi\n #\n\n\nElcodi is a worldwide project, and should be understandable by any interested\ndeveloper or final user. Because of that, we want to care about all languages\nand translations.\n\n\nBut how you can do it?\n\n\nTranslation Server\n #\n\n\nElcodi works with a project called\n\nTranslation Server\n. This\nproject provides you a small set of console commands that will enable you to\ncheck better how complete is translations for each defined language.\n\n\nCheck the documentation of that project in the same repository.\n\n\nListing resources\n #\n\n\nFirst of all you should check all Elcodi's translation resources. In these\nresources we include translations from our Bamboo project, including both Admin\npanel and our default Front template. We actually include some of our default\nPlugins.\n\n\nTo have the complete list of all these resources, you can use the console.\n\n\n$ php app/console translation:list-resources\n\nDirectories list :\n    - %kernel.root_dir%/../src/Elcodi/Admin/CoreBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Store/CoreBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Common/CommonBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/GoogleAnalyticsBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/PinterestBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/ProductCsvBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StoreSetupWizardBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/DisqusBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/TwitterBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/FacebookBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StoreTemplateBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/PaypalWebCheckoutBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/FreePaymentBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StripeBundle/Resources/translations\ndone!\n\n\n\n\nLanguages\n #\n\n\nElcodi works with a preset of languages. These languages are defined in a file\ncalled \n.translation.yml\n.\nIn this file, Elcodi defines the base of all languages we will work with. If\nyour language is not included, please send a Pull Request in order to add it as\nsoon as possible.\n\n\nEnglish is the main language, so the percentage of it should be complete.\nYou can check how translated is each language by using the translation-server\nconsole command.\n\n\n$ bin/translation-server translation:server:view\n\n[Trans Server] Command started at Mon, 02 Nov 2015 17:24:36 +0100\n[Trans Server] Translations for [en] is 100% completed. 0 missing\n[Trans Server] Translations for [de] is 99.57% completed. 4 missing\n[Trans Server] Translations for [ca] is 99.57% completed. 4 missing\n[Trans Server] Translations for [es] is 99.57% completed. 4 missing\n[Trans Server] Translations for [fr] is 78.36% completed. 203 missing\n[Trans Server] Translations for [it] is 76.44% completed. 221 missing\n[Trans Server] Translations for [fi] is 76.23% completed. 223 missing\n[Trans Server] Translations for [nl] is 0% completed. 938 missing\n[Trans Server] Translations for [eo] is 0% completed. 938 missing\n[Trans Server] Translations for [gl] is 0% completed. 938 missing\n[Trans Server] Translations for [eu] is 0% completed. 938 missing\n[Trans Server] Command finished in 1439 milliseconds\n[Trans Server] Max memory used: 17301504 bytes\n\n\n\n\n\nCompleting translations\n #\n\n\nAdding some translations to an existent language is so simple. Of course, as you\nhave done since now, you can check the file where the translation is missing\n(can be so difficult or tricky) and add your translation. In Bamboo this process\nwill be much easier because all our translation files are sorted alphabetically,\nbut even that, maybe you only want to add some translations in your language, no\nmatter where the translation is placed.\n\n\nIn that case, we have a very simple way of adding \nrandom\n translations in your\nlanguage by using as well a translation-server console command.\n\n\n$ bin/translation-server translation:server:add\n\n[Trans Server] Command started at Mon, 02 Nov 2015 17:43:42 +0100\n[Trans Server] Language : fr\n[Trans Server] Key : admin.identity.section.logo.description\n[Trans Server] Original : Here you can add an image with your logo. Please use the maximum quality posible.\n[Trans Server] Translation : \n\n\n\n\nTo know a little bit more about all the possibilities this command brings you, \nread its \ndocumentation\n\n\nAdding translations\n #\n\n\nThe easiest way of adding a new language from the scratch is by copying the\nenglish translation files to your language. By using this method, you will only\nhave to overwrite the original value to the translated one.\n\n\nAnyway, if your language is inserted as a Bamboo language in the\n\n.translation.yml\n file, you can just use the previous command \n\ntranslation:server:add\n and forget about how internal files are disposed.", 
            "title": "Translate elcodi"
        }, 
        {
            "location": "/book/translate-elcodi/#translate-elcodi", 
            "text": "Elcodi is a worldwide project, and should be understandable by any interested\ndeveloper or final user. Because of that, we want to care about all languages\nand translations.  But how you can do it?", 
            "title": "Translate Elcodi"
        }, 
        {
            "location": "/book/translate-elcodi/#translation-server", 
            "text": "Elcodi works with a project called Translation Server . This\nproject provides you a small set of console commands that will enable you to\ncheck better how complete is translations for each defined language.  Check the documentation of that project in the same repository.", 
            "title": "Translation Server"
        }, 
        {
            "location": "/book/translate-elcodi/#listing-resources", 
            "text": "First of all you should check all Elcodi's translation resources. In these\nresources we include translations from our Bamboo project, including both Admin\npanel and our default Front template. We actually include some of our default\nPlugins.  To have the complete list of all these resources, you can use the console.  $ php app/console translation:list-resources\n\nDirectories list :\n    - %kernel.root_dir%/../src/Elcodi/Admin/CoreBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Store/CoreBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Common/CommonBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/GoogleAnalyticsBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/PinterestBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/ProductCsvBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StoreSetupWizardBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/DisqusBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/TwitterBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/FacebookBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StoreTemplateBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/PaypalWebCheckoutBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/FreePaymentBundle/Resources/translations\n    - %kernel.root_dir%/../src/Elcodi/Plugin/StripeBundle/Resources/translations\ndone!", 
            "title": "Listing resources"
        }, 
        {
            "location": "/book/translate-elcodi/#languages", 
            "text": "Elcodi works with a preset of languages. These languages are defined in a file\ncalled  .translation.yml .\nIn this file, Elcodi defines the base of all languages we will work with. If\nyour language is not included, please send a Pull Request in order to add it as\nsoon as possible.  English is the main language, so the percentage of it should be complete.\nYou can check how translated is each language by using the translation-server\nconsole command.  $ bin/translation-server translation:server:view\n\n[Trans Server] Command started at Mon, 02 Nov 2015 17:24:36 +0100\n[Trans Server] Translations for [en] is 100% completed. 0 missing\n[Trans Server] Translations for [de] is 99.57% completed. 4 missing\n[Trans Server] Translations for [ca] is 99.57% completed. 4 missing\n[Trans Server] Translations for [es] is 99.57% completed. 4 missing\n[Trans Server] Translations for [fr] is 78.36% completed. 203 missing\n[Trans Server] Translations for [it] is 76.44% completed. 221 missing\n[Trans Server] Translations for [fi] is 76.23% completed. 223 missing\n[Trans Server] Translations for [nl] is 0% completed. 938 missing\n[Trans Server] Translations for [eo] is 0% completed. 938 missing\n[Trans Server] Translations for [gl] is 0% completed. 938 missing\n[Trans Server] Translations for [eu] is 0% completed. 938 missing\n[Trans Server] Command finished in 1439 milliseconds\n[Trans Server] Max memory used: 17301504 bytes", 
            "title": "Languages"
        }, 
        {
            "location": "/book/translate-elcodi/#completing-translations", 
            "text": "Adding some translations to an existent language is so simple. Of course, as you\nhave done since now, you can check the file where the translation is missing\n(can be so difficult or tricky) and add your translation. In Bamboo this process\nwill be much easier because all our translation files are sorted alphabetically,\nbut even that, maybe you only want to add some translations in your language, no\nmatter where the translation is placed.  In that case, we have a very simple way of adding  random  translations in your\nlanguage by using as well a translation-server console command.  $ bin/translation-server translation:server:add\n\n[Trans Server] Command started at Mon, 02 Nov 2015 17:43:42 +0100\n[Trans Server] Language : fr\n[Trans Server] Key : admin.identity.section.logo.description\n[Trans Server] Original : Here you can add an image with your logo. Please use the maximum quality posible.\n[Trans Server] Translation :   To know a little bit more about all the possibilities this command brings you, \nread its  documentation", 
            "title": "Completing translations"
        }, 
        {
            "location": "/book/translate-elcodi/#adding-translations", 
            "text": "The easiest way of adding a new language from the scratch is by copying the\nenglish translation files to your language. By using this method, you will only\nhave to overwrite the original value to the translated one.  Anyway, if your language is inserted as a Bamboo language in the .translation.yml  file, you can just use the previous command  translation:server:add  and forget about how internal files are disposed.", 
            "title": "Adding translations"
        }, 
        {
            "location": "/book/vagrant-quick-start/", 
            "text": "Vagrant Quick Start\n #\n\n\nBamboo also offer the possibility to try it in a fast way using \nVagrant\n.\n\n\nVagrant is a tool based on \nVirtualBox\n used to reproduce the same environment and share\nit with the team, so if you want start building your next ecommerce from bamboo, the VM will give your team a warranty\nabout the environment.\n\n\nBamboo also uses the \nAnsible\n \nprovisioner\n\nto help you configuring the environment correctly, so you don't need to configure it everytime you need to recreate\nthe virtual machine.\n\n\nRequirements\n #\n\n\n\n\ndownload\n and install VirtualBox\n\n\ndownload\n and install Vagrant\n\n\ninstall\n Ansible\n\n\n\n\nUsage\n #\n\n\nIts usage is simple and is based on three commands:\n\n\n$ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant up\n\n\n\n\nThe output you'll see is the \nprovisioning\n system, it will give you an \"ok\" when completed.\n\n\nIf it doesn't finish correctly don't worry, just use the \nvagrant provision\n to restart\nthe provisioning process.\n\n\nOnce completed you'll be able to access to your bamboo store at http://10.10.10.10/app_dev.php/\n\n\nIt's not public, 10.10.10.10 is just the address if your local machine.\n\n\n\n\nIf you need to change it, destroy the machine and change the IP in the Vagrantfile.\n\n\n\n\nWell, now that you have your local bamboo store you can work on local files and them will\nbe synced with the same files on the virtual machine.\n\n\nWhen you complete your changes run a\n\n\n$ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant suspend\n\n\n\n\nto shut down the virtual machine leaving changes\nuntouched, and to restart it the day after just do a\n\n\n$ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant resume\n\n\n\n\nIf you do something wrong with the environment don't worry, it's a virtual machine so won't affect\nyour local environment, if something goes wrong you can always do a \nvagrant destroy\n to destroy\nthe virtual machine and after recreate it using \nvagrant up\n.\n\n\n\n\nAttention:\n the vagrant up will take time because recreates everytime the virtual machine and\nrun the provisioning, so do it only when necessary.\n\n\n\n\nSSH Access\n #\n\n\nIf you need to access to the environment (for cron jobs, daemon processes, etc...), Vagrant gives\nthe possibility to access with a simple command:\n\n\n$ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant ssh", 
            "title": "Vagrant quick start"
        }, 
        {
            "location": "/book/vagrant-quick-start/#vagrant-quick-start", 
            "text": "Bamboo also offer the possibility to try it in a fast way using  Vagrant .  Vagrant is a tool based on  VirtualBox  used to reproduce the same environment and share\nit with the team, so if you want start building your next ecommerce from bamboo, the VM will give your team a warranty\nabout the environment.  Bamboo also uses the  Ansible   provisioner \nto help you configuring the environment correctly, so you don't need to configure it everytime you need to recreate\nthe virtual machine.", 
            "title": "Vagrant Quick Start"
        }, 
        {
            "location": "/book/vagrant-quick-start/#requirements", 
            "text": "download  and install VirtualBox  download  and install Vagrant  install  Ansible", 
            "title": "Requirements"
        }, 
        {
            "location": "/book/vagrant-quick-start/#usage", 
            "text": "Its usage is simple and is based on three commands:  $ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant up  The output you'll see is the  provisioning  system, it will give you an \"ok\" when completed.  If it doesn't finish correctly don't worry, just use the  vagrant provision  to restart\nthe provisioning process.  Once completed you'll be able to access to your bamboo store at http://10.10.10.10/app_dev.php/  It's not public, 10.10.10.10 is just the address if your local machine.   If you need to change it, destroy the machine and change the IP in the Vagrantfile.   Well, now that you have your local bamboo store you can work on local files and them will\nbe synced with the same files on the virtual machine.  When you complete your changes run a  $ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant suspend  to shut down the virtual machine leaving changes\nuntouched, and to restart it the day after just do a  $ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant resume  If you do something wrong with the environment don't worry, it's a virtual machine so won't affect\nyour local environment, if something goes wrong you can always do a  vagrant destroy  to destroy\nthe virtual machine and after recreate it using  vagrant up .   Attention:  the vagrant up will take time because recreates everytime the virtual machine and\nrun the provisioning, so do it only when necessary.", 
            "title": "Usage"
        }, 
        {
            "location": "/book/vagrant-quick-start/#ssh-access", 
            "text": "If you need to access to the environment (for cron jobs, daemon processes, etc...), Vagrant gives\nthe possibility to access with a simple command:  $ cd /path/to/your/bamboo\n$ cd vagrant\n$ vagrant ssh", 
            "title": "SSH Access"
        }, 
        {
            "location": "/book/what-is-elcodi/", 
            "text": "What is Elcodi\n #\n\n\nWelcome to Elcodi.\n\n\nIn this chapter we aim to explain you some basic internals about Elcodi and some\nnice reasons about how this tool can be really useful if you're interested in\nE-commerce and Symfony.\n\n\nElcodi is a project born in Barcelona in the year 2014 as an open source\nproject. At the beginning was born as an alternative of other existent projects\nnon-based on Symfony, to create in a very efficient and fast way E-commerce \nprojects. After some months it became a nice and cool option in the Symfony\necosystem.\n\n\nThe main goal of the project is propose a complete base to the final user\n(developer) for building e-commerce projects, following some patterns and\nthoughts, born to satisfy the developer and bring him a very painless, efficient\nand fast working experience.\n\n\n\n\nInstall Elcodi\n\n\n\n\nWhen we talk about Elcodi as a complete developing tool, we don't mean that we\nprovide all external implementations, integrations and bridges, but the project\nitself is a platform and is thought to make all the community participant,\ncreating these integrations, using a great Plugin definition and implementation,\nand feeding the ecosystem in a very healthy way.\n\n\n\n\nPlugins\n\n\n\n\nElcodi proposes a set of common features, specially implemented to provide a\nbasic solution for all E-commerce implementation. Basic doesn't mean\ninsufficient nor incomplete, but essential.\n\n\n\n\nFeatures\n\n\nProcesses\n\n\n\n\nOf couse, in Elcodi, apart from offering all this technological material, we\nwant to provide our experience when implementing new feature in our code, adding\nour way of working and our methodologies. This working method is based in a very\npragmatic thought, fleeing ephemeral and transient theories, and focusing on \nwhat is interesting in terms of developer and community.\n\n\nWe thought it important that your experience as a member, department or company\nshould be enough to make interesting and positive the fact of working with\nElcodi, so we have created a set of basic principles that we have as a project.\n\n\n\n\nPhilosophy\n\n\nPragmatic Driven Development\n\n\n\n\nWe highly recommend you to install Elcodi, and try it, ask us and enjoy with\nthe experience of working with a young community, excited and willing to change\nthe way people is intended to work with concepts like Cart, Product or even\nPayment Platform. No more pain!\n\n\nElcodi is a living style and we encourage you to join us, being part of our\ncommunity and learning best practices, techniques and patterns existing in\nSymfony.", 
            "title": "What is elcodi"
        }, 
        {
            "location": "/book/what-is-elcodi/#what-is-elcodi", 
            "text": "Welcome to Elcodi.  In this chapter we aim to explain you some basic internals about Elcodi and some\nnice reasons about how this tool can be really useful if you're interested in\nE-commerce and Symfony.  Elcodi is a project born in Barcelona in the year 2014 as an open source\nproject. At the beginning was born as an alternative of other existent projects\nnon-based on Symfony, to create in a very efficient and fast way E-commerce \nprojects. After some months it became a nice and cool option in the Symfony\necosystem.  The main goal of the project is propose a complete base to the final user\n(developer) for building e-commerce projects, following some patterns and\nthoughts, born to satisfy the developer and bring him a very painless, efficient\nand fast working experience.   Install Elcodi   When we talk about Elcodi as a complete developing tool, we don't mean that we\nprovide all external implementations, integrations and bridges, but the project\nitself is a platform and is thought to make all the community participant,\ncreating these integrations, using a great Plugin definition and implementation,\nand feeding the ecosystem in a very healthy way.   Plugins   Elcodi proposes a set of common features, specially implemented to provide a\nbasic solution for all E-commerce implementation. Basic doesn't mean\ninsufficient nor incomplete, but essential.   Features  Processes   Of couse, in Elcodi, apart from offering all this technological material, we\nwant to provide our experience when implementing new feature in our code, adding\nour way of working and our methodologies. This working method is based in a very\npragmatic thought, fleeing ephemeral and transient theories, and focusing on \nwhat is interesting in terms of developer and community.  We thought it important that your experience as a member, department or company\nshould be enough to make interesting and positive the fact of working with\nElcodi, so we have created a set of basic principles that we have as a project.   Philosophy  Pragmatic Driven Development   We highly recommend you to install Elcodi, and try it, ask us and enjoy with\nthe experience of working with a young community, excited and willing to change\nthe way people is intended to work with concepts like Cart, Product or even\nPayment Platform. No more pain!  Elcodi is a living style and we encourage you to join us, being part of our\ncommunity and learning best practices, techniques and patterns existing in\nSymfony.", 
            "title": "What is Elcodi"
        }, 
        {
            "location": "/book/why-elcodi/", 
            "text": "Why Elcodi\n #\n\n\nIn this chapter we will show you how Elcodi can fulfill your project needs, by\nexplaining you our strength and weakness, and by listing you some points you\ncan explain to the business department.\n\n\nStrength\n #\n\n\n\n\nThe project is Symfony based. This can be hard at the beginning if your team\nis not ready for Symfony, but is a great opportunity for your company to start\ngrowing as a technological company by using the spectacular framework.\n\n\nThe project started with one single focus: to solve the E-commerce problem by\nusing a simple but complex base. Simple because is easy to understand, complex\nbecause you can do as many implementations as you need, as much complex as you\ndesire.\n\n\nThe project is created and accurately maintained by developers for developers. \nThis means that our focus is not only de business layer, but the technical layer\nas well. Part of Elcodi team come from many exit cases of the E-commerce world,\nso we cover both parts pretty good.\n\n\nThe project is developer friendly, so E-commerce projects will not a pain \nanymore.\n\n\nThe project follows a scalable architecture. Your development resources will\nnot increment at all with the time. This means less time and more money to spend\nin your own domain (what really matters)\n\n\nThe project is built on top of open source, so the community will support you\nin all your problems and doubts.\n\n\nThe project have been free from the beginning and until the end, using a very\nopen \nMIT license\n\n\nThe project is alive. This means that will become better day by day, using\na very strict \nversioning model\n. Every 2 months a new\nrelease will be proposed by the core team and discussed with the community.\n\n\nYou company will acquire a community-based culture. You will find that being\nside by side with that community allow you to grow healthy and hand by hand with\nlast trendings.\n\n\nThe project's company, Elcodi Networks, is focused only in making the project\nbigger day by day, providing exclusive open source support. You'll never be\nalone.\n\n\nThe project's documentation is alive as well. It will be improved by us and\ntranslated to as many languages as needed.\n\n\nWe will take care about improving the core, improving the documentation and\nfixing all bugs encountered by our core team, as well as managing all bugs fixed\nby the community\n\n\nWe are other projects friendly. Many integrations with other projects will be\navailable for you! We will fight hard for that!\n\n\nElcodi core team is ready for you to join them. Say hello in\n\nGitter's Elcodi room\n and let them helping you\nwith your project!\n\n\n\n\nWeaknesses\n #\n\n\n\n\nThe project is young. This means that we've been working so hard on our core\nand philosophy. This means as well that we have the power to do everything as we\nwish and as good as we can.\n\n\nThe project's community is not big enough. Well, which one was big at the \nbeginning?\n\n\nThe project's plugin and template repository is not big enough. This base will \ngrow with the time, so this is only about making the project bigger and bigger,\nand the repository will automatically grow with us", 
            "title": "Why elcodi"
        }, 
        {
            "location": "/book/why-elcodi/#why-elcodi", 
            "text": "In this chapter we will show you how Elcodi can fulfill your project needs, by\nexplaining you our strength and weakness, and by listing you some points you\ncan explain to the business department.", 
            "title": "Why Elcodi"
        }, 
        {
            "location": "/book/why-elcodi/#strength", 
            "text": "The project is Symfony based. This can be hard at the beginning if your team\nis not ready for Symfony, but is a great opportunity for your company to start\ngrowing as a technological company by using the spectacular framework.  The project started with one single focus: to solve the E-commerce problem by\nusing a simple but complex base. Simple because is easy to understand, complex\nbecause you can do as many implementations as you need, as much complex as you\ndesire.  The project is created and accurately maintained by developers for developers. \nThis means that our focus is not only de business layer, but the technical layer\nas well. Part of Elcodi team come from many exit cases of the E-commerce world,\nso we cover both parts pretty good.  The project is developer friendly, so E-commerce projects will not a pain \nanymore.  The project follows a scalable architecture. Your development resources will\nnot increment at all with the time. This means less time and more money to spend\nin your own domain (what really matters)  The project is built on top of open source, so the community will support you\nin all your problems and doubts.  The project have been free from the beginning and until the end, using a very\nopen  MIT license  The project is alive. This means that will become better day by day, using\na very strict  versioning model . Every 2 months a new\nrelease will be proposed by the core team and discussed with the community.  You company will acquire a community-based culture. You will find that being\nside by side with that community allow you to grow healthy and hand by hand with\nlast trendings.  The project's company, Elcodi Networks, is focused only in making the project\nbigger day by day, providing exclusive open source support. You'll never be\nalone.  The project's documentation is alive as well. It will be improved by us and\ntranslated to as many languages as needed.  We will take care about improving the core, improving the documentation and\nfixing all bugs encountered by our core team, as well as managing all bugs fixed\nby the community  We are other projects friendly. Many integrations with other projects will be\navailable for you! We will fight hard for that!  Elcodi core team is ready for you to join them. Say hello in Gitter's Elcodi room  and let them helping you\nwith your project!", 
            "title": "Strength"
        }, 
        {
            "location": "/book/why-elcodi/#weaknesses", 
            "text": "The project is young. This means that we've been working so hard on our core\nand philosophy. This means as well that we have the power to do everything as we\nwish and as good as we can.  The project's community is not big enough. Well, which one was big at the \nbeginning?  The project's plugin and template repository is not big enough. This base will \ngrow with the time, so this is only about making the project bigger and bigger,\nand the repository will automatically grow with us", 
            "title": "Weaknesses"
        }, 
        {
            "location": "/cookbook/", 
            "text": "Cookbook\n #\n\n\nThe Elcodi Cookbook is a set of recipes related to Elcodi development flow and\nthe Bamboo implementation. Each one solves a specific problem or a specific\nscenario and follows this format.\n\n\nScenario - Scenario where this cookbook has sense\nProblem - What we need to do?\nSolution - Solve it that way!\nRelated links - Set of internal and external related links\n\n\nImplementation\n #\n\n\n\n\nHow to Implement an Entity\n\n\nHow to Implement a Factory\n\n\nHow to Implement a Repository\n\n\nHow to Implement a Form Type\n\n\nHow to Implement a Controller or a Command\n\n\nHow to Implement a Collector\n\n\n\n\nInstallation\n #\n\n\n\n\nHow to Install Dependent Bundles\n\n\nHow to Install a Plugin\n\n\n\n\nUsage\n #\n\n\n\n\nHow to Use Referrer Domain\n\n\nHow to Use Elcodi Watermark\n\n\n\n\nOverwrite Elcodi \n Bamboo\n #\n\n\n\n\nHow to Overwrite a Parameter\n\n\nHow to Overwrite an Entity\n\n\nHow to Overwrite a Service\n\n\n\n\nAdapters\n #\n\n\n\n\nHow to add a new Currency Rates Populator adapter\n\n\nHow to add a new Image Resize adapter\n\n\nHow to add a new Metric Bucket adapter\n\n\nHow to add a new Location Provider adapter\n\n\nHow to add a new Location Populator adapter\n\n\nHow to add a new Location Loader adapter\n\n\nHow to add a new Related Purchasables Provider adapter\n\n\n\n\nAsk your cookbook\n #\n\n\nOf course, we cannot think about all problems a project can produce. And this is\nbecause there are a lot of possible scenarios you fill find yourself lost and\nwith some helping needs.\n\n\nDon't worry. Do you need how to do something that is not documented yet? Ask us\nand we will take care of all these things:\n\n\n\n\nHelping you with that problem on Gitter. Please, join us at\n\nelcodi/elcodi room\n and ask us whatever you\nneed.\n\n\nAdding the cookbook entry with the \"How to...\" text\n\n\nIf the problem is common, we will create a new blog post explaining the\nsolution\n\n\n\n\nAdd your cookbook entry\n #\n\n\nHave you solved something interesting? Then, we are interested in knowing what\ndid you solve and how did you do that.\n\n\nYou can propose your new material by following the\n\nPull Request Book chapter\n. If you need some help\nabout how to do that, we can improve as well this chapter in order to make it\nmore clear and easy.", 
            "title": "Home"
        }, 
        {
            "location": "/cookbook/#cookbook", 
            "text": "The Elcodi Cookbook is a set of recipes related to Elcodi development flow and\nthe Bamboo implementation. Each one solves a specific problem or a specific\nscenario and follows this format.  Scenario - Scenario where this cookbook has sense\nProblem - What we need to do?\nSolution - Solve it that way!\nRelated links - Set of internal and external related links  Implementation  #   How to Implement an Entity  How to Implement a Factory  How to Implement a Repository  How to Implement a Form Type  How to Implement a Controller or a Command  How to Implement a Collector   Installation  #   How to Install Dependent Bundles  How to Install a Plugin   Usage  #   How to Use Referrer Domain  How to Use Elcodi Watermark   Overwrite Elcodi   Bamboo  #   How to Overwrite a Parameter  How to Overwrite an Entity  How to Overwrite a Service   Adapters  #   How to add a new Currency Rates Populator adapter  How to add a new Image Resize adapter  How to add a new Metric Bucket adapter  How to add a new Location Provider adapter  How to add a new Location Populator adapter  How to add a new Location Loader adapter  How to add a new Related Purchasables Provider adapter", 
            "title": "Cookbook"
        }, 
        {
            "location": "/cookbook/#ask-your-cookbook", 
            "text": "Of course, we cannot think about all problems a project can produce. And this is\nbecause there are a lot of possible scenarios you fill find yourself lost and\nwith some helping needs.  Don't worry. Do you need how to do something that is not documented yet? Ask us\nand we will take care of all these things:   Helping you with that problem on Gitter. Please, join us at elcodi/elcodi room  and ask us whatever you\nneed.  Adding the cookbook entry with the \"How to...\" text  If the problem is common, we will create a new blog post explaining the\nsolution", 
            "title": "Ask your cookbook"
        }, 
        {
            "location": "/cookbook/#add-your-cookbook-entry", 
            "text": "Have you solved something interesting? Then, we are interested in knowing what\ndid you solve and how did you do that.  You can propose your new material by following the Pull Request Book chapter . If you need some help\nabout how to do that, we can improve as well this chapter in order to make it\nmore clear and easy.", 
            "title": "Add your cookbook entry"
        }, 
        {
            "location": "/cookbook/installation/install-a-plugin/", 
            "text": "How to Install a plugin\n #\n\n\nTo read about plugins, please read all the \n\nPlugins Chapter\n of our book.\n\n\nTo install a plugin, you must treat it as a simple third party bundle.\n\n\n\n\nAdd the plugin (bundle) in your composer dependencies\n\n\nUpdate your dependencies by using \ncomposer update\n\n\nAdd the bundle in your kernel\n\n\n\n\nBut because a Plugin is not only a Bundle, this is not enough. Bamboo offers you\na very easy way of updating the information of your plugins by using a command.\nIt only takes 2 seconds!\n\n\nphp app/console elcodi:plugins:load\n\n\n\n\nYour already loaded plugin data will not be updated unless some plugin has \nchanged its configuration structure. Please pay attention to your dependencies\nversions.\n\n\nAfter this command, your will be able to manage your plugins through your admin\npanel.", 
            "title": "Install a plugin"
        }, 
        {
            "location": "/cookbook/installation/install-a-plugin/#how-to-install-a-plugin", 
            "text": "To read about plugins, please read all the  Plugins Chapter  of our book.  To install a plugin, you must treat it as a simple third party bundle.   Add the plugin (bundle) in your composer dependencies  Update your dependencies by using  composer update  Add the bundle in your kernel   But because a Plugin is not only a Bundle, this is not enough. Bamboo offers you\na very easy way of updating the information of your plugins by using a command.\nIt only takes 2 seconds!  php app/console elcodi:plugins:load  Your already loaded plugin data will not be updated unless some plugin has \nchanged its configuration structure. Please pay attention to your dependencies\nversions.  After this command, your will be able to manage your plugins through your admin\npanel.", 
            "title": "How to Install a plugin"
        }, 
        {
            "location": "/cookbook/installation/install-dependent-bundles/", 
            "text": "How to Install dependent Bundles\n #\n\n\nThis chapter is not only to show how to install a Dependent Bundle in Elcodi \nenvironment, but to show how to do it properly.\n\n\nPackage dependencies\n #\n\n\nAll Bundles in Elcodi follow the same installation strategy than Symfony \nstandard packages. Elcodi uses composer for package dependencies, so each\nstandalone Elcodi repository comes with a properly configured \ncomposer.json\n \nfile.\n\n\nBut when we talk about Bundles in Symfony, defining the dependencies in the\ncomposer file is not enough. The Kernel will instance only the Bundles you\ndefine in \nAppKernel.php\n file, ignoring the real dependencies this Bundle has.\n\n\nSo, regarding this real problem, Elcodi has developed some business logic in\norder to solve this problem.\n\n\nFirst of all, let's take a look at a simple Symfony Bundle class.\n\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle\n{\n}\n\n\n\n\nMaybe this Bundle needs the instantiation of another bundle (previously added in\nthe composer definition), but is not defined anywhere. So... let's do that.\n\n\nThe first step is to define a set of Bundle namespaces that must be instanced\nbefore this Bundle.\n\n\nAll dependent Bundles will be instanced before this Bundle. This is because a\nBundle should be able to override another Bundle definition, and Symfony has in\nmost cases a \nLast defined wins\n strategy.\n\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\nuse Elcodi\\Bundle\\CoreBundle\\Interfaces\\DependentBundleInterface;\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle implements DependentBundleInterface\n{\n    /**\n     * Create instance of current bundle, and return dependent bundle namespaces\n     *\n     * @return array Bundle instances\n     */\n    public static function getBundleDependencies()\n    {\n        return [\n            'Elcodi\\Bundle\\UserBundle\\ElcodiUserBundle',\n            'Elcodi\\Bundle\\ProductBundle\\ElcodiProductBundle',\n            'Elcodi\\Bundle\\CurrencyBundle\\ElcodiCurrencyBundle',\n            'Elcodi\\Bundle\\StateTransitionMachineBundle\\ElcodiStateTransitionMachineBundle',\n            'Elcodi\\Bundle\\ShippingBundle\\ElcodiShippingBundle',\n            'Elcodi\\Bundle\\ConfigurationBundle\\ElcodiConfigurationBundle',\n            'Elcodi\\Bundle\\CoreBundle\\ElcodiCoreBundle',\n        ];\n    }\n}\n\n\n\n\nSo, what else? Is that enough?\n\n\nThen, in order to make it happen, we must use a specific method in our \n\nAppKernel\n class, using a Trait provided by \nElcodiCoreBundle\n.\n\n\nuse Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\nuse Elcodi\\Bundle\\TestCommonBundle\\Functional\\Abstracts\\AbstractElcodiKernel;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends AbstractElcodiKernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Register application bundles\n     *\n     * @return array Array of bundles instances\n     */\n    public function registerBundles()\n    {\n        return $this-\ngetBundleInstances([\n            '\\Elcodi\\Bundle\\CartBundle\\ElcodiCartBundle',\n        ]);\n    }\n}\n\n\n\n\nAnd that's it. Your kernel will instance your \nElcodiCartBundle\n bundle and all\nits dependencies.\n\n\n\n\nThis method will work as well, even if the Bundle has no dependencies or is\nnot extending DependentBundleInterface.\n\n\n\n\nUsing dependencies in your project\n #\n\n\nIf you want to use this classes and methods in your Symfony project, you don't \nreally need to instance \nElcodiCoreBundle\n because you will not need any kind\nof Dependency Injection definition.\n\n\nYou only need to add \nelcodi/core-bundle\n in your package requirements and then\nuse the Interface and the Trait as is shown in this CookBook entry.", 
            "title": "Install dependent bundles"
        }, 
        {
            "location": "/cookbook/installation/install-dependent-bundles/#how-to-install-dependent-bundles", 
            "text": "This chapter is not only to show how to install a Dependent Bundle in Elcodi \nenvironment, but to show how to do it properly.  Package dependencies  #  All Bundles in Elcodi follow the same installation strategy than Symfony \nstandard packages. Elcodi uses composer for package dependencies, so each\nstandalone Elcodi repository comes with a properly configured  composer.json  \nfile.  But when we talk about Bundles in Symfony, defining the dependencies in the\ncomposer file is not enough. The Kernel will instance only the Bundles you\ndefine in  AppKernel.php  file, ignoring the real dependencies this Bundle has.  So, regarding this real problem, Elcodi has developed some business logic in\norder to solve this problem.  First of all, let's take a look at a simple Symfony Bundle class.  /**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle\n{\n}  Maybe this Bundle needs the instantiation of another bundle (previously added in\nthe composer definition), but is not defined anywhere. So... let's do that.  The first step is to define a set of Bundle namespaces that must be instanced\nbefore this Bundle.  All dependent Bundles will be instanced before this Bundle. This is because a\nBundle should be able to override another Bundle definition, and Symfony has in\nmost cases a  Last defined wins  strategy.  use Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\nuse Elcodi\\Bundle\\CoreBundle\\Interfaces\\DependentBundleInterface;\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle implements DependentBundleInterface\n{\n    /**\n     * Create instance of current bundle, and return dependent bundle namespaces\n     *\n     * @return array Bundle instances\n     */\n    public static function getBundleDependencies()\n    {\n        return [\n            'Elcodi\\Bundle\\UserBundle\\ElcodiUserBundle',\n            'Elcodi\\Bundle\\ProductBundle\\ElcodiProductBundle',\n            'Elcodi\\Bundle\\CurrencyBundle\\ElcodiCurrencyBundle',\n            'Elcodi\\Bundle\\StateTransitionMachineBundle\\ElcodiStateTransitionMachineBundle',\n            'Elcodi\\Bundle\\ShippingBundle\\ElcodiShippingBundle',\n            'Elcodi\\Bundle\\ConfigurationBundle\\ElcodiConfigurationBundle',\n            'Elcodi\\Bundle\\CoreBundle\\ElcodiCoreBundle',\n        ];\n    }\n}  So, what else? Is that enough?  Then, in order to make it happen, we must use a specific method in our  AppKernel  class, using a Trait provided by  ElcodiCoreBundle .  use Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\nuse Elcodi\\Bundle\\TestCommonBundle\\Functional\\Abstracts\\AbstractElcodiKernel;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends AbstractElcodiKernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Register application bundles\n     *\n     * @return array Array of bundles instances\n     */\n    public function registerBundles()\n    {\n        return $this- getBundleInstances([\n            '\\Elcodi\\Bundle\\CartBundle\\ElcodiCartBundle',\n        ]);\n    }\n}  And that's it. Your kernel will instance your  ElcodiCartBundle  bundle and all\nits dependencies.   This method will work as well, even if the Bundle has no dependencies or is\nnot extending DependentBundleInterface.   Using dependencies in your project  #  If you want to use this classes and methods in your Symfony project, you don't \nreally need to instance  ElcodiCoreBundle  because you will not need any kind\nof Dependency Injection definition.  You only need to add  elcodi/core-bundle  in your package requirements and then\nuse the Interface and the Trait as is shown in this CookBook entry.", 
            "title": "How to Install dependent Bundles"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-parameter/", 
            "text": "How to Overwrite a Parameter\n #\n\n\nYou can overwrite Elcodi by using the file \napp/config/config_local.yml\n. This\nfile is loaded at the end of the \napp/config/config.yml\n file, allowing final \nusers to add custom elements, overriding all project definitions.\n\n\nWhy you should use \nconfig_local.yml\n file?\n\n\nWell, this file will never be improved nor evolved, so even if you pull into \nyour project last Elcodi versions, you will never have conflicts in that file.\n\n\nLet's see an example\n\n\n# app/config/config_local.yml\nparameters:\n    database_host: 10.0.0.1\n\nelcodi_currency:\n    currency:\n        default_currency: EUR\n        session_field_name: currency_id", 
            "title": "Overwrite a parameter"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-parameter/#how-to-overwrite-a-parameter", 
            "text": "You can overwrite Elcodi by using the file  app/config/config_local.yml . This\nfile is loaded at the end of the  app/config/config.yml  file, allowing final \nusers to add custom elements, overriding all project definitions.  Why you should use  config_local.yml  file?  Well, this file will never be improved nor evolved, so even if you pull into \nyour project last Elcodi versions, you will never have conflicts in that file.  Let's see an example  # app/config/config_local.yml\nparameters:\n    database_host: 10.0.0.1\n\nelcodi_currency:\n    currency:\n        default_currency: EUR\n        session_field_name: currency_id", 
            "title": "How to Overwrite a Parameter"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/", 
            "text": "How to overwrite a service\n #\n\n\nThe Elcodi's default service layer is kindly proposed by the project in order to\nprovide you a simple business logic, documented, and with all capabilities to be\nmodified, overwritten and changed as much as needed.\n\n\nScenario\n #\n\n\nImagine your E-commerce needs have evolved a lot, and your business needs grow\nday by day. Your Cart is not Elcodi's cart anymore and you need to change a \nlittle bit\n\n\nYour Product needs an extra flag called \npromoted\n, in order to assign an extra\npromotional value from 0 to 1, and used when products are required for \npagination. Your Product, based on Elcodi's one, should have this new field.\n\n\nSolution\n #\n\n\nTo overwrite a service you must create a new class in your project, extend the \nmain service and overwrite the methods you need to overwrite.\n\n\nuse Elcodi\\Component\\Cart\\Services\\CartManager;\n\n/**\n * New cart manager\n */\nclass NewCartManager extends CartManager\n{\n    /**\n     * Adds cartLine to Cart\n     *\n     * This method dispatches all Cart Check and Load events\n     * It should NOT be used to add a Purchasable to a Cart,\n     * by manually passing a newly crafted CartLine, since\n     * no product duplication check is performed: in that\n     * case CartManager::addProduct should be used\n     *\n     * @param CartInterface     $cart     Cart\n     * @param CartLineInterface $cartLine Cart line\n     *\n     * @return $this Self object\n     */\n    protected function addLine(\n        CartInterface $cart,\n        CartLineInterface $cartLine\n    ) {\n\n        // My own addLine implementation\n    }\n}\n\n\n\n\nFinally we need to let the project know that this new implementation is the one\nwe really want to use in our project. For this reason, we should redefine this\nservice in our \nconfig.yml\n file, and overwrite the main service implementation.\n\n\nservices:\n\n    elcodi.manager.cart:\n        cart: My\\New\\Bundle\\Services\\NewCartManager\n        arguments:\n            ...\n\n\n\n\nHaving done that, all the project will use your \nelcodi.manager.cart\n \nimplementation instead of the default one.", 
            "title": "Overwrite a service"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/#how-to-overwrite-a-service", 
            "text": "The Elcodi's default service layer is kindly proposed by the project in order to\nprovide you a simple business logic, documented, and with all capabilities to be\nmodified, overwritten and changed as much as needed.", 
            "title": "How to overwrite a service"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/#scenario", 
            "text": "Imagine your E-commerce needs have evolved a lot, and your business needs grow\nday by day. Your Cart is not Elcodi's cart anymore and you need to change a \nlittle bit  Your Product needs an extra flag called  promoted , in order to assign an extra\npromotional value from 0 to 1, and used when products are required for \npagination. Your Product, based on Elcodi's one, should have this new field.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/#solution", 
            "text": "To overwrite a service you must create a new class in your project, extend the \nmain service and overwrite the methods you need to overwrite.  use Elcodi\\Component\\Cart\\Services\\CartManager;\n\n/**\n * New cart manager\n */\nclass NewCartManager extends CartManager\n{\n    /**\n     * Adds cartLine to Cart\n     *\n     * This method dispatches all Cart Check and Load events\n     * It should NOT be used to add a Purchasable to a Cart,\n     * by manually passing a newly crafted CartLine, since\n     * no product duplication check is performed: in that\n     * case CartManager::addProduct should be used\n     *\n     * @param CartInterface     $cart     Cart\n     * @param CartLineInterface $cartLine Cart line\n     *\n     * @return $this Self object\n     */\n    protected function addLine(\n        CartInterface $cart,\n        CartLineInterface $cartLine\n    ) {\n\n        // My own addLine implementation\n    }\n}  Finally we need to let the project know that this new implementation is the one\nwe really want to use in our project. For this reason, we should redefine this\nservice in our  config.yml  file, and overwrite the main service implementation.  services:\n\n    elcodi.manager.cart:\n        cart: My\\New\\Bundle\\Services\\NewCartManager\n        arguments:\n            ...  Having done that, all the project will use your  elcodi.manager.cart  \nimplementation instead of the default one.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-an-entity/", 
            "text": "How to Overwrite an Entity\n #\n\n\nEach project is completely different, right? Elcodi is just one approach to an\nspecific e-commerce problem, but one of our goals is to provide a way for\noverwriting absolutely everything.\n\n\nScenario\n #\n\n\nYour E-commerce installation is great, but the Product implementation that \nElcodi proposes to you as a base is not enough for your model requirements.\n\n\nYour Product needs an extra flag called \npromoted\n, in order to assign an extra\npromotional value from 0 to 1, and used when products are required for \npagination. Your Product, based on Elcodi's one, should have this new field.\n\n\nSolution\n #\n\n\nThe solution is very easy. From this moment your Product implementation will be \nthe one used in your project, instead of the old one. This means that you will\nbe able to extend it as much as you want without modifying the old one, just\nextending or re-implementing it.\n\n\nExtending or Implementing\n #\n\n\nEach entity has its own interface. It means that if you want to build your own\n\nProduct\n, for example, your new implementation will need to implement the \nexisting ProductInterface, in that case, \n\nElcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface\n.\n\n\nuse Elcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface;\n\n/**\n * New Product implementation\n */\nclass NewProduct implements ProductInterface\n{\n    ...\n}    \n\n\n\n\nThis is useful when you really want to implement another Product completely \ndifferent than the old one, but with same specification.\n\n\nYou can also create a new entity extending the default Product implementation (at \nthis point your new entity will be implementing this interface by default). The \nadvantage is that you don't need to implement all the methods of the interface, \nbut just overwrite those that you want to change.\n\n\nPerfect if you only need to extend it.\n\n\nuse Elcodi\\Component\\Product\\Entity\\Product;\n\n/**\n * New Product implementation\n */\nclass NewProduct extends Product\n{\n    /**\n     * @var boolean\n     *\n     * Promoted value\n     */\n    protected $promoted;\n\n     /**\n      * Get promoted value\n      *\n      * @return float Promoted value\n      */\n     public function getPromoted()\n     {\n        return $this-\npromoted;\n     }\n\n     /**\n      * Set promoted value\n      *\n      * @param float $promoted Promoted value\n      *\n      * @return $this Self object\n      */\n     public function setPromoted($promoted)\n     {\n        $this-\npromoted = $promoted;\n\n        return $this;\n     }\n}    \n\n\n\n\nBoth ways are valid depending on your implementation needs, but given our needs,\nwe will use this one.\n\n\nUsing this new implementation\n #\n\n\nOnce your new entity is implemented, you need to tell your application\nabout your new implementation.\n\n\nElcodi works with a project called \n\nSimpleDoctrineMapping\n. This\nlibrary enables each bundle to specify how its entities must be treated inside\nthe Symfony installation, instead of letting Doctrine decide this stuff using \n\nauto_mapping=true\n.\n\n\nEach Elcodi Bundle uses this library, so you can overwrite this information \nthrough each Bundle configuration. Let's see how ProductBundle allows the user to\ndefine this information by exposing its configuration.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: Elcodi\\Component\\Product\\Entity\\Product\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiProductBundle/Resources/config/doctrine/Product.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n\n\n\nIf you don't define anything, then these values are injected as default \nconfiguration values in ProductBundle, so this is the way of overwriting the \ndefinition to start using our new Product implementation.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n\n\n\n\nAnd that's enough.\n\n\nChanging the mapping file\n #\n\n\nOnce you have changed your entity, or just using the default entity \nimplementation, maybe you want to change the way the entity is mapped in your\ndatabase.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.yml'\n\n\n\n\nIn Elcodi we are actually using \nyml\n files for such definition, but you can use\nboth \nyml\n and \nxml\n files.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.xml'\n\n\n\n\nThe result will be the same, and the system will detect the file extension.\n\n\nOverwriting the mapping file\n #\n\n\nOnce you need to overwrite the mapping file, you need to do it completely. \nDoctrine implementation does not allow overwriting a mapping file, so you need\nto copy/paste the old one and modify as you wish.\n\n\nIn fact, this is the best option. As long as you don't use anymore the mapping \nfile proposed by Elcodi, then you should take the control of all the mapping \nfile.\n\n\nUsing another Entity Manager\n #\n\n\nBy default, all entities are managed by the default entity manager. You can \nchange this behavior just overwriting this configuration value. The selected \nentity manager must exist in your Doctrine ORM definition.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.yml'\n            # Doctrine manager name\n            manager: another_entity_manager\n\n\n\n\nTake into account that related entities should share the same entity manager. \nFor example, in this example, because \nProduct\n is related to \nCategory\n, it \nwould be not possible to have both tables managed separately by two different \nmanagers.\n\n\nDisabling an Entity\n #\n\n\nMaybe you want to disable a specific entity. The most used strategy would be not\nto use this entity, even if the table is created, but we strongly think that \nyour model must be considered an essential part of your implementation, so you \ncan disable an entity with a single line.\n\n\nelcodi_product:\n\n    mapping:\n        product:\n            enabled: false", 
            "title": "Overwrite an entity"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-an-entity/#how-to-overwrite-an-entity", 
            "text": "Each project is completely different, right? Elcodi is just one approach to an\nspecific e-commerce problem, but one of our goals is to provide a way for\noverwriting absolutely everything.", 
            "title": "How to Overwrite an Entity"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-an-entity/#scenario", 
            "text": "Your E-commerce installation is great, but the Product implementation that \nElcodi proposes to you as a base is not enough for your model requirements.  Your Product needs an extra flag called  promoted , in order to assign an extra\npromotional value from 0 to 1, and used when products are required for \npagination. Your Product, based on Elcodi's one, should have this new field.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-an-entity/#solution", 
            "text": "The solution is very easy. From this moment your Product implementation will be \nthe one used in your project, instead of the old one. This means that you will\nbe able to extend it as much as you want without modifying the old one, just\nextending or re-implementing it.  Extending or Implementing  #  Each entity has its own interface. It means that if you want to build your own Product , for example, your new implementation will need to implement the \nexisting ProductInterface, in that case,  Elcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface .  use Elcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface;\n\n/**\n * New Product implementation\n */\nclass NewProduct implements ProductInterface\n{\n    ...\n}      This is useful when you really want to implement another Product completely \ndifferent than the old one, but with same specification.  You can also create a new entity extending the default Product implementation (at \nthis point your new entity will be implementing this interface by default). The \nadvantage is that you don't need to implement all the methods of the interface, \nbut just overwrite those that you want to change.  Perfect if you only need to extend it.  use Elcodi\\Component\\Product\\Entity\\Product;\n\n/**\n * New Product implementation\n */\nclass NewProduct extends Product\n{\n    /**\n     * @var boolean\n     *\n     * Promoted value\n     */\n    protected $promoted;\n\n     /**\n      * Get promoted value\n      *\n      * @return float Promoted value\n      */\n     public function getPromoted()\n     {\n        return $this- promoted;\n     }\n\n     /**\n      * Set promoted value\n      *\n      * @param float $promoted Promoted value\n      *\n      * @return $this Self object\n      */\n     public function setPromoted($promoted)\n     {\n        $this- promoted = $promoted;\n\n        return $this;\n     }\n}      Both ways are valid depending on your implementation needs, but given our needs,\nwe will use this one.  Using this new implementation  #  Once your new entity is implemented, you need to tell your application\nabout your new implementation.  Elcodi works with a project called  SimpleDoctrineMapping . This\nlibrary enables each bundle to specify how its entities must be treated inside\nthe Symfony installation, instead of letting Doctrine decide this stuff using  auto_mapping=true .  Each Elcodi Bundle uses this library, so you can overwrite this information \nthrough each Bundle configuration. Let's see how ProductBundle allows the user to\ndefine this information by exposing its configuration.  elcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: Elcodi\\Component\\Product\\Entity\\Product\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiProductBundle/Resources/config/doctrine/Product.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true  If you don't define anything, then these values are injected as default \nconfiguration values in ProductBundle, so this is the way of overwriting the \ndefinition to start using our new Product implementation.  elcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct  And that's enough.  Changing the mapping file  #  Once you have changed your entity, or just using the default entity \nimplementation, maybe you want to change the way the entity is mapped in your\ndatabase.  elcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.yml'  In Elcodi we are actually using  yml  files for such definition, but you can use\nboth  yml  and  xml  files.  elcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.xml'  The result will be the same, and the system will detect the file extension.  Overwriting the mapping file  #  Once you need to overwrite the mapping file, you need to do it completely. \nDoctrine implementation does not allow overwriting a mapping file, so you need\nto copy/paste the old one and modify as you wish.  In fact, this is the best option. As long as you don't use anymore the mapping \nfile proposed by Elcodi, then you should take the control of all the mapping \nfile.  Using another Entity Manager  #  By default, all entities are managed by the default entity manager. You can \nchange this behavior just overwriting this configuration value. The selected \nentity manager must exist in your Doctrine ORM definition.  elcodi_product:\n\n    mapping:\n        product:\n            # Product entity implementing ProductInterface\n            class: My\\New\\Bundle\\Entity\\NewProduct\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Product.orm.yml'\n            # Doctrine manager name\n            manager: another_entity_manager  Take into account that related entities should share the same entity manager. \nFor example, in this example, because  Product  is related to  Category , it \nwould be not possible to have both tables managed separately by two different \nmanagers.  Disabling an Entity  #  Maybe you want to disable a specific entity. The most used strategy would be not\nto use this entity, even if the table is created, but we strongly think that \nyour model must be considered an essential part of your implementation, so you \ncan disable an entity with a single line.  elcodi_product:\n\n    mapping:\n        product:\n            enabled: false", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/deprecation/deprecate-a-method/", 
            "text": "How to deprecate a method\n #", 
            "title": "Deprecate a method"
        }, 
        {
            "location": "/cookbook/deprecation/deprecate-a-method/#how-to-deprecate-a-method", 
            "text": "", 
            "title": "How to deprecate a method"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/", 
            "text": "How to add a new Currency Rates Populator adapter\n #\n\n\nBamboo works with several currencies at the same time. This happens when your\nshop work with different countries.\n\n\nScenario\n #\n\n\nBecause you have several currencies, but all products are defined using one\ncurrency, you need to know the equivalence value between them all.\n\n\nThe point is that there are a lot of services that provide this information, and\nmaybe you want to use one specific, non implemented yet or even your own\ncurrency rates server.\n\n\nSolution\n #\n\n\nYou can create a new adapter for Currency Rates populator. By default, Elcodi\nimplementation works with the Yahoo Finance provider. This adapter can be easily\nreplaced by creating a new class implementing \n\nCurrencyExchangeRatesProviderAdapterInterface\n.\n\n\nnamespace Elcodi\\Component\\Currency\\Adapter\\CurrencyExchangeRatesProvider\\Interfaces;\n\n/**\n * Interface CurrencyExchangeRatesProviderAdapterInterface\n */\ninterface CurrencyExchangeRatesProviderAdapterInterface\n{\n    /**\n     * Get the latest exchange rates.\n     *\n     * This method will take in account always that the base currency is USD,\n     * and the result must complain this format.\n     *\n     * [\n     *      \nEUR\n =\n \n1,78342784\n,\n     *      \nYEN\n =\n \n0,67438268\n,\n     *      ...\n     * ]\n     *\n     * @return array exchange rates\n     */\n    public function getExchangeRates();\n}\n\n\n\n\nThen, you need to define your class as a service.\n\n\nservices:\n\n    #\n    # My currency rates adapter\n    #\n    my_currency_rates_adapter:\n        class: My\\Currency\\Rates\\Adapter\n\n\n\n\nAnd finally you need to expose your adapter implementation as the used by the \nframework when loading your currency rates. You can do that by configuring the\nCurrencyBundle and setting your new service id.\n\n\nelcodi_currency:\n    rates_provider:\n        client: my_currency_rates_adapter\n\n\n\n\nNow you can use your new implementation by populating your currencies through\nthe command line.\n\n\n$ php app/console elcodi:exchangerates:populate\n\n\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.currency_exchange_rate_adapter\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nCurrency Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_currency:\n    rates_provider:\n        adapter: elcodi.currency_exchange_rate_adapter.yahoo_finances\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have \nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nYahoo Finances Adapter\n #\n\n\n\n\nNamespace - Elcodi\\Component\\Currency\\Adapter\\CurrencyExchangeRatesProvider\\YahooFinanceProviderAdapter\n\n\nDI name - \nelcodi.currency_exchange_rate_adapter.yahoo_finances\n\n\n\n\nThis extension doesn't need any extra installation", 
            "title": "Currency rates populator"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/#how-to-add-a-new-currency-rates-populator-adapter", 
            "text": "Bamboo works with several currencies at the same time. This happens when your\nshop work with different countries.", 
            "title": "How to add a new Currency Rates Populator adapter"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/#scenario", 
            "text": "Because you have several currencies, but all products are defined using one\ncurrency, you need to know the equivalence value between them all.  The point is that there are a lot of services that provide this information, and\nmaybe you want to use one specific, non implemented yet or even your own\ncurrency rates server.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/#solution", 
            "text": "You can create a new adapter for Currency Rates populator. By default, Elcodi\nimplementation works with the Yahoo Finance provider. This adapter can be easily\nreplaced by creating a new class implementing  CurrencyExchangeRatesProviderAdapterInterface .  namespace Elcodi\\Component\\Currency\\Adapter\\CurrencyExchangeRatesProvider\\Interfaces;\n\n/**\n * Interface CurrencyExchangeRatesProviderAdapterInterface\n */\ninterface CurrencyExchangeRatesProviderAdapterInterface\n{\n    /**\n     * Get the latest exchange rates.\n     *\n     * This method will take in account always that the base currency is USD,\n     * and the result must complain this format.\n     *\n     * [\n     *       EUR  =   1,78342784 ,\n     *       YEN  =   0,67438268 ,\n     *      ...\n     * ]\n     *\n     * @return array exchange rates\n     */\n    public function getExchangeRates();\n}  Then, you need to define your class as a service.  services:\n\n    #\n    # My currency rates adapter\n    #\n    my_currency_rates_adapter:\n        class: My\\Currency\\Rates\\Adapter  And finally you need to expose your adapter implementation as the used by the \nframework when loading your currency rates. You can do that by configuring the\nCurrencyBundle and setting your new service id.  elcodi_currency:\n    rates_provider:\n        client: my_currency_rates_adapter  Now you can use your new implementation by populating your currencies through\nthe command line.  $ php app/console elcodi:exchangerates:populate", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.currency_exchange_rate_adapter .  If you want to change the adapter, the only thing you must do is overwrite the\nCurrency Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_currency:\n    rates_provider:\n        adapter: elcodi.currency_exchange_rate_adapter.yahoo_finances", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/currency-rates-populator/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have \nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Yahoo Finances Adapter  #   Namespace - Elcodi\\Component\\Currency\\Adapter\\CurrencyExchangeRatesProvider\\YahooFinanceProviderAdapter  DI name -  elcodi.currency_exchange_rate_adapter.yahoo_finances   This extension doesn't need any extra installation", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/", 
            "text": "How to add a new Image Resize adapter\n #\n\n\nElcodi is served with a simple but very useful built-in image server. One of\nthe most important actions this server is intended for is resizing images.\n\n\nScenario\n #\n\n\nYou need your application to be deployed to a server with PHP GD, but you want\nto use another image resize engine, for example an external API.\n\n\nElcodi provides you a set of limited adapters for image resizing, so we should\nimplement this new adapter. Elcodi provides you a simple, fast and amazing way\nto do it without many pain\n\n\nSolution\n #\n\n\nYou can create your own image resize engine by adding a new adapter. By default,\nElcodi is built with an implementation using the PHP GD Extension (you will\nprobably find this extension already installed with your regular PHP\ndistribution). This adapter can be easily replaced by creating a new class\nimplementing \nCurrencyExchangeRatesProviderAdapterInterface\n.\n\n\n?php\n\nnamespace Elcodi\\Component\\Media\\Adapter\\Resizer\\Interfaces;\n\nuse Elcodi\\Component\\Media\\ElcodiMediaImageResizeTypes;\n\n/**\n * Interface ResizerAdapterInterface\n */\ninterface ResizeAdapterInterface\n{\n    /**\n     * Interface for resize implementations\n     *\n     * @param string  $imageData Image Data\n     * @param integer $height    Height value\n     * @param integer $width     Width value\n     * @param integer $type      Type\n     *\n     * @return string Resized image data\n     */\n    public function resize(\n        $imageData,\n        $height,\n        $width,\n        $type = ElcodiMediaImageResizeTypes::FORCE_MEASURES\n    );\n}\n\n\n\n\nThen, you need to define your class as a service.\n\n\nservices:\n\n    #\n    # My image resizer adapter\n    #\n    my_image_resizer_adapter:\n        class: My\\Image\\Resizer\\Adapter\n\n\n\n\nAnd finally you need to expose your adapter implementation as the used by the\nframework when resizing an existing image. You can do that by configuring the\nMediaBundle and setting your new service id.\n\n\nelcodi_media:\n    images:\n        resize:\n            client: my_image_resizer_adapter\n\n\n\n\nNow, everytime an image needs to be resized, you will see your new adapter in\naction.\n\n\nResize types\n #\n\n\nElcodi resize adapter must complain 6 different resize types. Each type is\ndefined using the constants placed in \nElcodiMediaImageResizeTypes\n.\n\n\nnamespace Elcodi\\Component\\Media;\n\n/**\n * Class ElcodiMediaImageResizeTypes\n */\nfinal class ElcodiMediaImageResizeTypes\n{\n    /**\n     * @var integer\n     *\n     * Do not resize the image\n     */\n    const NO_RESIZE = 0;\n\n    /**\n     * @var integer\n     *\n     * Resize mode FORCE_MEASURES sets the image to the desired size.\n     * DOES NOT preserve original aspect ratio.\n     * Best for fixed size images like banners\n     */\n    const FORCE_MEASURES = 1;\n\n    /**\n     * @var integer\n     *\n     * Resize mode INSET sets the image to the desired size.\n     * Preserves original aspect ratio so it might not fill the box.\n     * Best for large thumbnails\n     */\n    const INSET = 2;\n\n    /**\n     * @var integer\n     *\n     * Resize mode INSET_FILL_WHITE sets the image to the desired size.\n     * Preserves original aspect ratio and adds white color to the background in order to fill the box.\n     * Best for small thumbnails\n     */\n    const INSET_FILL_WHITE = 3;\n\n    /**\n     * @var integer\n     *\n     * Outbound resizing\n     */\n    const OUTBOUNDS_FILL_WHITE = 4;\n\n    /**\n     * @var integer\n     *\n     * Resize mode 5 sets the image to the desired size.\n     * Preserves original aspect ratio and crops image for only get this area.\n     */\n    const OUTBOUND_CROP = 5;\n}\n\n\n\n\nAs you can see in the adapter interface, by default this resize must force\nmeasures.\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.media_resize_adapter\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nMedia Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_media:\n    image:\n        resize:\n            adapter: elcodi.media_resize_adapter.gd\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nGD Extension Adapter\n #\n\n\n\n\nNamespace - Elcodi\\Component\\Media\\Adapter\\Resizer\\GDResizeAdapter\n\n\nDI name - \nelcodi.media_resize_adapter.gd\n\n\n\n\nThis extension doesn't need any extra installation\n\n\nImagemagick Adapter\n #\n\n\n\n\nNamespace - Elcodi\\Component\\Media\\Adapter\\Resizer\\ImageMagickResizeAdapter\n\n\nDI name - \nelcodi.media_resize_adapter.imagemagick\n\n\n\n\nFor more info just visit their \ninstallation page\n\n\n\n\nOn the installation step you will be asked to provide the Imagick installation\npath. Ensure to configure the parameter imagick_convert_bin_path right\n\n\n\n\nThis adapter may need some configuration. This is the reference. Feel free to\noverwrite these values in your project.\n\n\nelcodi_media:\n    image:\n        resize:\n            converter_bin_path: /usr/bin/convert\n            converter_default_profile: /usr/share/color/icc/colord/sRGB.icc", 
            "title": "Image resize"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#how-to-add-a-new-image-resize-adapter", 
            "text": "Elcodi is served with a simple but very useful built-in image server. One of\nthe most important actions this server is intended for is resizing images.", 
            "title": "How to add a new Image Resize adapter"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#scenario", 
            "text": "You need your application to be deployed to a server with PHP GD, but you want\nto use another image resize engine, for example an external API.  Elcodi provides you a set of limited adapters for image resizing, so we should\nimplement this new adapter. Elcodi provides you a simple, fast and amazing way\nto do it without many pain", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#solution", 
            "text": "You can create your own image resize engine by adding a new adapter. By default,\nElcodi is built with an implementation using the PHP GD Extension (you will\nprobably find this extension already installed with your regular PHP\ndistribution). This adapter can be easily replaced by creating a new class\nimplementing  CurrencyExchangeRatesProviderAdapterInterface .  ?php\n\nnamespace Elcodi\\Component\\Media\\Adapter\\Resizer\\Interfaces;\n\nuse Elcodi\\Component\\Media\\ElcodiMediaImageResizeTypes;\n\n/**\n * Interface ResizerAdapterInterface\n */\ninterface ResizeAdapterInterface\n{\n    /**\n     * Interface for resize implementations\n     *\n     * @param string  $imageData Image Data\n     * @param integer $height    Height value\n     * @param integer $width     Width value\n     * @param integer $type      Type\n     *\n     * @return string Resized image data\n     */\n    public function resize(\n        $imageData,\n        $height,\n        $width,\n        $type = ElcodiMediaImageResizeTypes::FORCE_MEASURES\n    );\n}  Then, you need to define your class as a service.  services:\n\n    #\n    # My image resizer adapter\n    #\n    my_image_resizer_adapter:\n        class: My\\Image\\Resizer\\Adapter  And finally you need to expose your adapter implementation as the used by the\nframework when resizing an existing image. You can do that by configuring the\nMediaBundle and setting your new service id.  elcodi_media:\n    images:\n        resize:\n            client: my_image_resizer_adapter  Now, everytime an image needs to be resized, you will see your new adapter in\naction.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#resize-types", 
            "text": "Elcodi resize adapter must complain 6 different resize types. Each type is\ndefined using the constants placed in  ElcodiMediaImageResizeTypes .  namespace Elcodi\\Component\\Media;\n\n/**\n * Class ElcodiMediaImageResizeTypes\n */\nfinal class ElcodiMediaImageResizeTypes\n{\n    /**\n     * @var integer\n     *\n     * Do not resize the image\n     */\n    const NO_RESIZE = 0;\n\n    /**\n     * @var integer\n     *\n     * Resize mode FORCE_MEASURES sets the image to the desired size.\n     * DOES NOT preserve original aspect ratio.\n     * Best for fixed size images like banners\n     */\n    const FORCE_MEASURES = 1;\n\n    /**\n     * @var integer\n     *\n     * Resize mode INSET sets the image to the desired size.\n     * Preserves original aspect ratio so it might not fill the box.\n     * Best for large thumbnails\n     */\n    const INSET = 2;\n\n    /**\n     * @var integer\n     *\n     * Resize mode INSET_FILL_WHITE sets the image to the desired size.\n     * Preserves original aspect ratio and adds white color to the background in order to fill the box.\n     * Best for small thumbnails\n     */\n    const INSET_FILL_WHITE = 3;\n\n    /**\n     * @var integer\n     *\n     * Outbound resizing\n     */\n    const OUTBOUNDS_FILL_WHITE = 4;\n\n    /**\n     * @var integer\n     *\n     * Resize mode 5 sets the image to the desired size.\n     * Preserves original aspect ratio and crops image for only get this area.\n     */\n    const OUTBOUND_CROP = 5;\n}  As you can see in the adapter interface, by default this resize must force\nmeasures.", 
            "title": "Resize types"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.media_resize_adapter .  If you want to change the adapter, the only thing you must do is overwrite the\nMedia Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_media:\n    image:\n        resize:\n            adapter: elcodi.media_resize_adapter.gd", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/image-resize/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  GD Extension Adapter  #   Namespace - Elcodi\\Component\\Media\\Adapter\\Resizer\\GDResizeAdapter  DI name -  elcodi.media_resize_adapter.gd   This extension doesn't need any extra installation  Imagemagick Adapter  #   Namespace - Elcodi\\Component\\Media\\Adapter\\Resizer\\ImageMagickResizeAdapter  DI name -  elcodi.media_resize_adapter.imagemagick   For more info just visit their  installation page   On the installation step you will be asked to provide the Imagick installation\npath. Ensure to configure the parameter imagick_convert_bin_path right   This adapter may need some configuration. This is the reference. Feel free to\noverwrite these values in your project.  elcodi_media:\n    image:\n        resize:\n            converter_bin_path: /usr/bin/convert\n            converter_default_profile: /usr/share/color/icc/colord/sRGB.icc", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/", 
            "text": "How to add a new Location Loader adapter\n #\n\n\nElcodi uses by default the Github implementaton, retrieving data from some a\nGithub repository.\n\n\nScenario\n #\n\n\nYou are using another implementation for Locations. This means that your\ndatabase structure is not the same as Elcodi proposes. Then, if you still want\nto use this feature for fast location loading, then you must implement your own\nloader adapter.\n\n\nSolution\n #\n\n\nFor your own adapter implementation you only need to know where your actual data\nis stored. The adapter itself is only a class that implements interface\n\nElcodi\\Component\\Geo\\Adapter\\LocationLoader\\GithubLocationLoaderAdapter\n.\n\n\nnamespace Elcodi\\Component\\Geo\\Adapter\\LocationLoader\\Interfaces;\n\n/**\n * Interface LocationLoaderAdapterInterface\n */\ninterface LocationLoaderAdapterInterface\n{\n    /**\n     * Given a country name, return the sql to be loaded\n     *\n     * @param string $countryName Country name\n     *\n     * @return string Sql to be loaded\n     */\n    public function getSqlForCountry($countryName);\n}\n\n\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.location_loader\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_geo:\n    location:\n        loader_adapter: elcodi.location_loader_adapter.github\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nGithub Loader Adapter\n #\n\n\nUses Github repository\n\nelcodi/LocationDumps\n, and actually\nonly some countries have been pre-generated.\n\n\n\n\nNamespace - Elcodi\\Component\\Geo\\Adapter\\LocationLoader\\GithubLocationLoaderAdapter\n\n\nDI name - \nelcodi.location_loader_adapter.github\n\n\n\n\nCountries generated:\n\n \nAndorra - AD\n\n\n \nAustria - AT\n\n\n \nBelgium - BE\n\n\n \nSwitzerland - CH\n\n\n \nGermany - AD\n\n\n \nDenmark - DK\n\n\n \nSpain - ES\n\n\n \nFinland - FI\n\n\n \nFrance - FR\n\n\n \nUnited Kingdom - GB\n\n\n \nItaly - IT\n\n\n \nPoland - PL\n\n\nIf you generate your country and is not in this list or is not updated, then\ndon't hesitate to create a PR and ping us", 
            "title": "Location loader"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/#how-to-add-a-new-location-loader-adapter", 
            "text": "Elcodi uses by default the Github implementaton, retrieving data from some a\nGithub repository.", 
            "title": "How to add a new Location Loader adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/#scenario", 
            "text": "You are using another implementation for Locations. This means that your\ndatabase structure is not the same as Elcodi proposes. Then, if you still want\nto use this feature for fast location loading, then you must implement your own\nloader adapter.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/#solution", 
            "text": "For your own adapter implementation you only need to know where your actual data\nis stored. The adapter itself is only a class that implements interface Elcodi\\Component\\Geo\\Adapter\\LocationLoader\\GithubLocationLoaderAdapter .  namespace Elcodi\\Component\\Geo\\Adapter\\LocationLoader\\Interfaces;\n\n/**\n * Interface LocationLoaderAdapterInterface\n */\ninterface LocationLoaderAdapterInterface\n{\n    /**\n     * Given a country name, return the sql to be loaded\n     *\n     * @param string $countryName Country name\n     *\n     * @return string Sql to be loaded\n     */\n    public function getSqlForCountry($countryName);\n}", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.location_loader .  If you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_geo:\n    location:\n        loader_adapter: elcodi.location_loader_adapter.github", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-loader/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Github Loader Adapter  #  Uses Github repository elcodi/LocationDumps , and actually\nonly some countries have been pre-generated.   Namespace - Elcodi\\Component\\Geo\\Adapter\\LocationLoader\\GithubLocationLoaderAdapter  DI name -  elcodi.location_loader_adapter.github   Countries generated:   Andorra - AD    Austria - AT    Belgium - BE    Switzerland - CH    Germany - AD    Denmark - DK    Spain - ES    Finland - FI    France - FR    United Kingdom - GB    Italy - IT    Poland - PL  If you generate your country and is not in this list or is not updated, then\ndon't hesitate to create a PR and ping us", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/", 
            "text": "How to add a new Location Populator adapter\n #\n\n\nBy default Elcodi uses an external website called\n\nGeonames\n. This website proposes some data files with\ncountry location references. This data is treated, organized and inserted as\nentities in our Doctrine infrastructure.\n\n\nThis adapter just takes this data from that service and populates that country.\n\n\nScenario\n #\n\n\nYou have your own location server, for example, a non-free service that proposes\nyou this structure in a more precise way.\n\n\nSolution\n #\n\n\nYou can create your own adapter for that. You just need to implement a simple\nInterface, with one single method. That easy.\n\n\nnamespace Elcodi\\Component\\Geo\\Adapter\\LocationPopulator\\Interfaces;\n\nuse Elcodi\\Component\\Geo\\Entity\\Interfaces\\LocationInterface;\n\n/**\n * Interface PopulatorInterface\n */\ninterface LocationPopulatorAdapterInterface\n{\n    /**\n     * Populate a country\n     *\n     * @param string $countryCode Country Code\n     *\n     * @return LocationInterface Root location\n     */\n    public function populate($countryCode);\n}\n\n\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.location_populator\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_geo:\n    location:\n        populator_adapter: elcodi.location_populator_adapter.geonames\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nGeonames Populator Adapter\n #\n\n\n\n\nNamespace - Elcodi\\Component\\Geo\\Adapter\\LocationPopulator\\GeonamesLocationPopulatorAdapter\n\n\nDI name - \nelcodi.location_populator_adapter.geonames", 
            "title": "Location populator"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/#how-to-add-a-new-location-populator-adapter", 
            "text": "By default Elcodi uses an external website called Geonames . This website proposes some data files with\ncountry location references. This data is treated, organized and inserted as\nentities in our Doctrine infrastructure.  This adapter just takes this data from that service and populates that country.", 
            "title": "How to add a new Location Populator adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/#scenario", 
            "text": "You have your own location server, for example, a non-free service that proposes\nyou this structure in a more precise way.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/#solution", 
            "text": "You can create your own adapter for that. You just need to implement a simple\nInterface, with one single method. That easy.  namespace Elcodi\\Component\\Geo\\Adapter\\LocationPopulator\\Interfaces;\n\nuse Elcodi\\Component\\Geo\\Entity\\Interfaces\\LocationInterface;\n\n/**\n * Interface PopulatorInterface\n */\ninterface LocationPopulatorAdapterInterface\n{\n    /**\n     * Populate a country\n     *\n     * @param string $countryCode Country Code\n     *\n     * @return LocationInterface Root location\n     */\n    public function populate($countryCode);\n}", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.location_populator .  If you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_geo:\n    location:\n        populator_adapter: elcodi.location_populator_adapter.geonames", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-populator/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Geonames Populator Adapter  #   Namespace - Elcodi\\Component\\Geo\\Adapter\\LocationPopulator\\GeonamesLocationPopulatorAdapter  DI name -  elcodi.location_populator_adapter.geonames", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/", 
            "text": "How to add a new Location Provider adapter\n #\n\n\nOne of the most important parts in an Ecommerce is the way Locations and all\nGeo information is treated. In order to simplify the way Elcodi offers this\nfeature, you will be able to work with a nice Location structure using two\ndifferent accessing approaches.\n\n\nScenario\n #\n\n\nYour Location structure has changed, or the way you access to the data. Maybe\nthis scenario is not common at all, because Elcodi covers the most important and\nused ways of accessing, but you have your own particular way.\n\n\nSolution\n #\n\n\nImplementing an interface is the way you will be able to expose your way and not\nbreaking any external implementation. You'll see that implementable interface\noffers some accessible methods, all of them specified properly in order to make\nimplementation easy to understand. This interface as well uses complex value\nobjects, so there's no margin of error there.\n\n\nnamespace Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\Interfaces;\n\nuse Elcodi\\Component\\Geo\\ValueObject\\LocationData;\n\n/**\n * Interface LocationProviderAdapterInterface\n */\ninterface LocationProviderAdapterInterface\n{\n    /**\n     * Get all the root locations.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getRootLocations();\n\n    /**\n     * Get the children given a location id.\n     *\n     * @param string $id The location Id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getChildren($id);\n\n    /**\n     * Get the parents given a location id.\n     *\n     * @param string $id The location Id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getParents($id);\n\n    /**\n     * Get the full location info given it's id.\n     *\n     * @param string $id The location id.\n     *\n     * @return LocationData Location info\n     */\n    public function getLocation($id);\n\n    /**\n     * Get the hierarchy given a location sorted from root to the given\n     * location.\n     *\n     * @param string $id The location id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getHierarchy($id);\n\n    /**\n     * Checks if the first received id is contained between the rest of ids\n     * received as second parameter\n     *\n     * @param string $id  The location Id\n     * @param array  $ids The location Ids\n     *\n     * @return boolean Location is container\n     */\n    public function in($id, array $ids);\n}\n\n\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.location_provider\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_geo:\n    location:\n        provider_adapter: elcodi.location_provider_adapter.service\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nService Provider Adapter\n #\n\n\nThis adapter uses a single service to make calls. This is useful for centralized\nsystems. Easy and simple.\n\n\n\n\nNamespace - Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\LocationServiceProviderAdapter\n\n\nDI name - \nlcodi.location_provider_adapter.service\n\n\n\n\nAPI Provider Adapter\n #\n\n\nThis adapter offers the same data but using a simple API infrastructure. This is\nuseful, for example, if you work with several projects at the same time, so you\nonly need one location database, shared by all websites.\n\n\n\n\nNamespace - Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\LocationApiProviderAdapter\n\n\nDI name - \nlcodi.location_provider_adapter.api\n\n\n\n\nYou can actually use an external location host. By default, this value is null,\nso make sure you define properly this value in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_geo:\n    location:\n        api_host: ~", 
            "title": "Location provider"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/#how-to-add-a-new-location-provider-adapter", 
            "text": "One of the most important parts in an Ecommerce is the way Locations and all\nGeo information is treated. In order to simplify the way Elcodi offers this\nfeature, you will be able to work with a nice Location structure using two\ndifferent accessing approaches.", 
            "title": "How to add a new Location Provider adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/#scenario", 
            "text": "Your Location structure has changed, or the way you access to the data. Maybe\nthis scenario is not common at all, because Elcodi covers the most important and\nused ways of accessing, but you have your own particular way.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/#solution", 
            "text": "Implementing an interface is the way you will be able to expose your way and not\nbreaking any external implementation. You'll see that implementable interface\noffers some accessible methods, all of them specified properly in order to make\nimplementation easy to understand. This interface as well uses complex value\nobjects, so there's no margin of error there.  namespace Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\Interfaces;\n\nuse Elcodi\\Component\\Geo\\ValueObject\\LocationData;\n\n/**\n * Interface LocationProviderAdapterInterface\n */\ninterface LocationProviderAdapterInterface\n{\n    /**\n     * Get all the root locations.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getRootLocations();\n\n    /**\n     * Get the children given a location id.\n     *\n     * @param string $id The location Id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getChildren($id);\n\n    /**\n     * Get the parents given a location id.\n     *\n     * @param string $id The location Id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getParents($id);\n\n    /**\n     * Get the full location info given it's id.\n     *\n     * @param string $id The location id.\n     *\n     * @return LocationData Location info\n     */\n    public function getLocation($id);\n\n    /**\n     * Get the hierarchy given a location sorted from root to the given\n     * location.\n     *\n     * @param string $id The location id.\n     *\n     * @return LocationData[] Collection of locations\n     */\n    public function getHierarchy($id);\n\n    /**\n     * Checks if the first received id is contained between the rest of ids\n     * received as second parameter\n     *\n     * @param string $id  The location Id\n     * @param array  $ids The location Ids\n     *\n     * @return boolean Location is container\n     */\n    public function in($id, array $ids);\n}", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.location_provider .  If you want to change the adapter, the only thing you must do is overwrite the\nGeo Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_geo:\n    location:\n        provider_adapter: elcodi.location_provider_adapter.service", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/location-provider/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Service Provider Adapter  #  This adapter uses a single service to make calls. This is useful for centralized\nsystems. Easy and simple.   Namespace - Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\LocationServiceProviderAdapter  DI name -  lcodi.location_provider_adapter.service   API Provider Adapter  #  This adapter offers the same data but using a simple API infrastructure. This is\nuseful, for example, if you work with several projects at the same time, so you\nonly need one location database, shared by all websites.   Namespace - Elcodi\\Component\\Geo\\Adapter\\LocationProvider\\LocationApiProviderAdapter  DI name -  lcodi.location_provider_adapter.api   You can actually use an external location host. By default, this value is null,\nso make sure you define properly this value in your /app/config/config_local.yml  file.  elcodi_geo:\n    location:\n        api_host: ~", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/", 
            "text": "How to add a new Metric Bucket adapter\u00a1\n #\n\n\nBy default, Elcodi provides one Metric Bucket implementation, based on Redis.\nYou can read more information about this in the\n\nBook Metrics Chapter\n. This feature has been implemented\nusing Adapters as well, so you could implement your own.\n\n\nScenario\n #\n\n\nYou have your store installed in third party environment. Bad news... Redis is\nnot installed and you cannot install it even if you want it. This scenario is\nvery common, so you should be able to use Metrics as well, even without Redis.\n\n\nSolution\n #\n\n\nWell, first of all you should think about where to place your metric cache. A\nbucket is nothing but a cache layer for your metrics. Each metric entry is a\ndatabase entry as well, but because only working with Doctrine would be so hard\nfor your server and user, we work with a cache layer.\n\n\nThis cache implementation should be able to build results in a very fast way, so\nthis is the reason why default implementation uses Redis.\n\n\nAbstractMetricsBucket\n #\n\n\nLike every other adapters implementations, there is an Interface for that.\nRemember that an abstract class can work as an interface as well if you define\nmethods as abstract.\n\n\nAbstractMetricsBucket is your class if you want to create a new adapter for\nthat.\n\n\nnamespace Elcodi\\Component\\Metric\\Core\\Bucket\\Abstracts;\n\nuse Elcodi\\Component\\Metric\\Core\\Entity\\Interfaces\\EntryInterface;\n\n/**\n * Class AbstractMetricsBucket\n */\nabstract class AbstractMetricsBucket\n{\n    /**\n     * Add Metric into Bucket\n     *\n     * @param EntryInterface $entry Entry\n     *\n     * @return $this Self Object\n     */\n    abstract public function add(EntryInterface $entry);\n\n    /**\n     * Get number of unique beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of hits\n     */\n    abstract public function getBeaconsUnique($token, $event, array $dates);\n\n    /**\n     * Get the total of beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of beacons, given an event and dates\n     */\n    abstract public function getBeaconsTotal($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Accumulation of event and given dates\n     */\n    abstract public function getAccumulation($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * [\n     *      \nvalue3\n: 24,\n     *      \nvalue7\n: 13,\n     *      \nvalue8\n: 9,\n     * ]\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return array Distribution with totals\n     */\n    abstract public function getDistributions($token, $event, array $dates);\n}\n\n\n\n\nThis class provides you some helpers as well, related to how cache keys should\nbe built in order to avoid collisions inside the bucket\n\n\n/**\n * Create key given an entry\n *\n * @param string $token Event\n * @param string $event Token\n * @param string $date  Date\n *\n * @return string key\n */\nprotected function generateEntryKey($token, $event, $date)\n{\n    return\n        $this-\nnormalizeForKey($token) .\n        '.' .\n        $this-\nnormalizeForKey($event) .\n        '.' .\n        $this-\nnormalizeForKey($date);\n}\n\n/**\n * Normalize string for key format\n *\n * @param string $string String\n *\n * @return string String normalized\n */\npublic function normalizeForKey($string)\n{\n    return str_replace('.', '_', $string);\n}\n\n\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.metrics_bucket\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nMetric Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_metric:\n    bucket:\n        client: elcodi.redis_metrics_bucket\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nRedis Bucket Adapter\n #\n\n\n\n\nNamespace - Elcodi\\Component\\Metric\\Core\\Bucket\\RedisMetricsBucket\n\n\nDI name - \nelcodi.redis_metrics_bucket\n\n\n\n\nThis extension doesn't need any extra installation. If redis-server is not\ninstalled, then nothing happens. If it is, then will work properly.", 
            "title": "Metric bucket"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#how-to-add-a-new-metric-bucket-adapter", 
            "text": "By default, Elcodi provides one Metric Bucket implementation, based on Redis.\nYou can read more information about this in the Book Metrics Chapter . This feature has been implemented\nusing Adapters as well, so you could implement your own.", 
            "title": "How to add a new Metric Bucket adapter\u00a1"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#scenario", 
            "text": "You have your store installed in third party environment. Bad news... Redis is\nnot installed and you cannot install it even if you want it. This scenario is\nvery common, so you should be able to use Metrics as well, even without Redis.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#solution", 
            "text": "Well, first of all you should think about where to place your metric cache. A\nbucket is nothing but a cache layer for your metrics. Each metric entry is a\ndatabase entry as well, but because only working with Doctrine would be so hard\nfor your server and user, we work with a cache layer.  This cache implementation should be able to build results in a very fast way, so\nthis is the reason why default implementation uses Redis.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#abstractmetricsbucket", 
            "text": "Like every other adapters implementations, there is an Interface for that.\nRemember that an abstract class can work as an interface as well if you define\nmethods as abstract.  AbstractMetricsBucket is your class if you want to create a new adapter for\nthat.  namespace Elcodi\\Component\\Metric\\Core\\Bucket\\Abstracts;\n\nuse Elcodi\\Component\\Metric\\Core\\Entity\\Interfaces\\EntryInterface;\n\n/**\n * Class AbstractMetricsBucket\n */\nabstract class AbstractMetricsBucket\n{\n    /**\n     * Add Metric into Bucket\n     *\n     * @param EntryInterface $entry Entry\n     *\n     * @return $this Self Object\n     */\n    abstract public function add(EntryInterface $entry);\n\n    /**\n     * Get number of unique beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of hits\n     */\n    abstract public function getBeaconsUnique($token, $event, array $dates);\n\n    /**\n     * Get the total of beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of beacons, given an event and dates\n     */\n    abstract public function getBeaconsTotal($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Accumulation of event and given dates\n     */\n    abstract public function getAccumulation($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * [\n     *       value3 : 24,\n     *       value7 : 13,\n     *       value8 : 9,\n     * ]\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return array Distribution with totals\n     */\n    abstract public function getDistributions($token, $event, array $dates);\n}  This class provides you some helpers as well, related to how cache keys should\nbe built in order to avoid collisions inside the bucket  /**\n * Create key given an entry\n *\n * @param string $token Event\n * @param string $event Token\n * @param string $date  Date\n *\n * @return string key\n */\nprotected function generateEntryKey($token, $event, $date)\n{\n    return\n        $this- normalizeForKey($token) .\n        '.' .\n        $this- normalizeForKey($event) .\n        '.' .\n        $this- normalizeForKey($date);\n}\n\n/**\n * Normalize string for key format\n *\n * @param string $string String\n *\n * @return string String normalized\n */\npublic function normalizeForKey($string)\n{\n    return str_replace('.', '_', $string);\n}", 
            "title": "AbstractMetricsBucket"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.metrics_bucket .  If you want to change the adapter, the only thing you must do is overwrite the\nMetric Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_metric:\n    bucket:\n        client: elcodi.redis_metrics_bucket", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/metric-bucket/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Redis Bucket Adapter  #   Namespace - Elcodi\\Component\\Metric\\Core\\Bucket\\RedisMetricsBucket  DI name -  elcodi.redis_metrics_bucket   This extension doesn't need any extra installation. If redis-server is not\ninstalled, then nothing happens. If it is, then will work properly.", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/", 
            "text": "How to add a new Related Products Provider adapter\n #\n\n\nIn some pages, specially all related to a purchasable object, you may show some\nrelated purchasable objects as well. This features is very used in all websites\nto increase the valuable relation between final pages in the same website.\n\n\nScenario\n #\n\n\nElcodi offers a simple implementation of how these purchasable objects should be\nfound, taking the principal category as the common element between them all. The\nmain thing here is that maybe you work with external implementations or services\nthat makes this task.\n\n\nSolution\n #\n\n\nAgain, create your own adapter for that. Elcodi provides an interface for all\nexternal implementations (our implementation uses this interface as well).\n\n\nnamespace Elcodi\\Component\\Product\\Adapter\\SimilarPurchasablesProvider\\Interfaces;\n\nuse Elcodi\\Component\\Product\\Entity\\Interfaces\\PurchasableInterface;\n\n/**\n * Interface RelatedPurchasablesProviderInterface\n */\ninterface RelatedPurchasablesProviderInterface\n{\n    /**\n     * Given a Purchasable, return a collection of related purchasables.\n     *\n     * @param PurchasableInterface $purchasable Purchasable\n     * @param int                  $limit       Limit of elements retrieved\n     *\n     * @return array Related products\n     */\n    public function getRelatedPurchasables(PurchasableInterface $purchasable, $limit);\n\n    /**\n     * Given a Collection of Purchasables, return a collection of related\n     * purchasables.\n     *\n     * @param PurchasableInterface[] $purchasables Purchasable\n     * @param int                    $limit        Limit of elements retrieved\n     *\n     * @return array Related products\n     */\n    public function getRelatedPurchasablesFromArray(array $purchasables, $limit);\n}\n\n\n\n\nAs you can see, all adapters must implement two methods. This is because\nsometimes both methods require different implementations. Anyway, most\nimplementations will have common logic shared by both methods.\n\n\nUsed Adapter\n #\n\n\nThe adapter used by the Dependency Injection is the one aliased with the name\n\nelcodi.related_purchasables_provider\n.\n\n\nIf you want to change the adapter, the only thing you must do is overwrite the\nProduct Bundle configuration in your project, by adding this in your\n\n/app/config/config_local.yml\n file.\n\n\nelcodi_product:\n    related_purchasables_provider:\n        adapter: elcodi.related_purchasables_provider.same_category\n\n\n\n\nAdapters\n #\n\n\nThese are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.\n\n\nSame Category Related\n #\n\n\nTakes in account the same principal category of the given Purchasable. If the\nobject is a Variant, then its Product principal category is used. This\nimplementation not supports external Purchasable implementations.\n\n\n\n\nNamespace - Elcodi\\Component\\Product\\Adapter\\SimilarPurchasablesProvider\\SameCategoryRelatedPurchasableProvider\n\n\nDI name - \nelcodi.related_purchasables_provider.same_category", 
            "title": "Related purchasables provider"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/#how-to-add-a-new-related-products-provider-adapter", 
            "text": "In some pages, specially all related to a purchasable object, you may show some\nrelated purchasable objects as well. This features is very used in all websites\nto increase the valuable relation between final pages in the same website.", 
            "title": "How to add a new Related Products Provider adapter"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/#scenario", 
            "text": "Elcodi offers a simple implementation of how these purchasable objects should be\nfound, taking the principal category as the common element between them all. The\nmain thing here is that maybe you work with external implementations or services\nthat makes this task.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/#solution", 
            "text": "Again, create your own adapter for that. Elcodi provides an interface for all\nexternal implementations (our implementation uses this interface as well).  namespace Elcodi\\Component\\Product\\Adapter\\SimilarPurchasablesProvider\\Interfaces;\n\nuse Elcodi\\Component\\Product\\Entity\\Interfaces\\PurchasableInterface;\n\n/**\n * Interface RelatedPurchasablesProviderInterface\n */\ninterface RelatedPurchasablesProviderInterface\n{\n    /**\n     * Given a Purchasable, return a collection of related purchasables.\n     *\n     * @param PurchasableInterface $purchasable Purchasable\n     * @param int                  $limit       Limit of elements retrieved\n     *\n     * @return array Related products\n     */\n    public function getRelatedPurchasables(PurchasableInterface $purchasable, $limit);\n\n    /**\n     * Given a Collection of Purchasables, return a collection of related\n     * purchasables.\n     *\n     * @param PurchasableInterface[] $purchasables Purchasable\n     * @param int                    $limit        Limit of elements retrieved\n     *\n     * @return array Related products\n     */\n    public function getRelatedPurchasablesFromArray(array $purchasables, $limit);\n}  As you can see, all adapters must implement two methods. This is because\nsometimes both methods require different implementations. Anyway, most\nimplementations will have common logic shared by both methods.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/#used-adapter", 
            "text": "The adapter used by the Dependency Injection is the one aliased with the name elcodi.related_purchasables_provider .  If you want to change the adapter, the only thing you must do is overwrite the\nProduct Bundle configuration in your project, by adding this in your /app/config/config_local.yml  file.  elcodi_product:\n    related_purchasables_provider:\n        adapter: elcodi.related_purchasables_provider.same_category", 
            "title": "Used Adapter"
        }, 
        {
            "location": "/cookbook/adapters/related-purchasables-provider/#adapters", 
            "text": "These are our adapters included in the Core of the application. If you have\nimplemented another adapter and you think that can be interesting to share it,\nthen you can create a pull request with your work. We will appreciate it.  Same Category Related  #  Takes in account the same principal category of the given Purchasable. If the\nobject is a Variant, then its Product principal category is used. This\nimplementation not supports external Purchasable implementations.   Namespace - Elcodi\\Component\\Product\\Adapter\\SimilarPurchasablesProvider\\SameCategoryRelatedPurchasableProvider  DI name -  elcodi.related_purchasables_provider.same_category", 
            "title": "Adapters"
        }, 
        {
            "location": "/cookbook/workflow/create-automatic-coupon/", 
            "text": "", 
            "title": "Create automatic coupon"
        }, 
        {
            "location": "/cookbook/usage/elcodi-watermark/", 
            "text": "Elcodi Watermark\n #\n\n\nWe need a small watermark for all Elcodi E-commerce implementation. This\nwatermark should be very soft, small and imperceptible by the human eye, only\naccessible by developers and robots.\n\n\nWe want to introduce you a Symfony Bundle called\n\nHTTPHeadersBundle\n. This bundle\nis very basic, only 2 PHP classes indeed. You can read there the documentation,\nand we will explain how we are using this project.\n\n\nX-Elcodi\n #\n\n\nThis is the Response HTTP Header for Elcodi. As you can see in the \nconfig.yml\n\nfile in Bamboo, the HTTPHeadersBundle configuration sets this header for all\nsite pages\n\n\n#\n# HTTP Headers\n# Fill this data to ensure your ecommerce is unique and belongs to developers\n# Checkout the configuration in https://github.com/mmoreram/HTTPHeadersBundle\n#\nhttp_headers:\n    response:\n        x_elcodi:\n            name: X-Elcodi\n            values:\n                - This E-commerce is built using Elcodi and Symfony\n\n\n\n\nPlease, this header will allow some engines to detect your website as an\nimplementation of Elcodi. This means more installations, more development, and\nthis always means more confidence for other people.", 
            "title": "Elcodi watermark"
        }, 
        {
            "location": "/cookbook/usage/elcodi-watermark/#elcodi-watermark", 
            "text": "We need a small watermark for all Elcodi E-commerce implementation. This\nwatermark should be very soft, small and imperceptible by the human eye, only\naccessible by developers and robots.  We want to introduce you a Symfony Bundle called HTTPHeadersBundle . This bundle\nis very basic, only 2 PHP classes indeed. You can read there the documentation,\nand we will explain how we are using this project.", 
            "title": "Elcodi Watermark"
        }, 
        {
            "location": "/cookbook/usage/elcodi-watermark/#x-elcodi", 
            "text": "This is the Response HTTP Header for Elcodi. As you can see in the  config.yml \nfile in Bamboo, the HTTPHeadersBundle configuration sets this header for all\nsite pages  #\n# HTTP Headers\n# Fill this data to ensure your ecommerce is unique and belongs to developers\n# Checkout the configuration in https://github.com/mmoreram/HTTPHeadersBundle\n#\nhttp_headers:\n    response:\n        x_elcodi:\n            name: X-Elcodi\n            values:\n                - This E-commerce is built using Elcodi and Symfony  Please, this header will allow some engines to detect your website as an\nimplementation of Elcodi. This means more installations, more development, and\nthis always means more confidence for other people.", 
            "title": "X-Elcodi"
        }, 
        {
            "location": "/cookbook/usage/referrer-domain/", 
            "text": "Using referrer domain\n #\n\n\nYou would possible know the referrer of your site views, right? Well, Bamboo\nstore provides you a couple of tools for this.\n\n\nReferrer provider\n #\n\n\nin Elcodi Core component you will find the service with all business logic\nrelated to this. A simple class that will allow you to know some information\nabout your referrers.\n\n\nnamespace Elcodi\\Component\\Core\\Services;\n\n/**\n * Class ReferrerProvider\n */\nclass ReferrerProvider\n{\n    /**\n     * Get referrer\n     *\n     * @return string Referrer\n     */\n    public function getReferrer();\n\n    /**\n     * Get referrer\n     *\n     * @return string Referrer\n     */\n    public function getReferrerDomain();\n\n    /**\n     * Referrer is search engine\n     *\n     * @return boolean Is search engine\n     */\n    public function referrerIsSearchEngine();\n}\n\n\n\n\nYou can inject this service by using the dependency injection service name.\n\n\nservices:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi.provider.referrer\n\n\n\n\nReferrer Twig extension\n #\n\n\nIf you need to access to this information in the Twig layer, then there is an\nExtension for that.\n\n\n{{ referrer() }}\n{{ referrer_domain() }}\n{{ referrer_is_search_engine() }}", 
            "title": "Referrer domain"
        }, 
        {
            "location": "/cookbook/usage/referrer-domain/#using-referrer-domain", 
            "text": "You would possible know the referrer of your site views, right? Well, Bamboo\nstore provides you a couple of tools for this.", 
            "title": "Using referrer domain"
        }, 
        {
            "location": "/cookbook/usage/referrer-domain/#referrer-provider", 
            "text": "in Elcodi Core component you will find the service with all business logic\nrelated to this. A simple class that will allow you to know some information\nabout your referrers.  namespace Elcodi\\Component\\Core\\Services;\n\n/**\n * Class ReferrerProvider\n */\nclass ReferrerProvider\n{\n    /**\n     * Get referrer\n     *\n     * @return string Referrer\n     */\n    public function getReferrer();\n\n    /**\n     * Get referrer\n     *\n     * @return string Referrer\n     */\n    public function getReferrerDomain();\n\n    /**\n     * Referrer is search engine\n     *\n     * @return boolean Is search engine\n     */\n    public function referrerIsSearchEngine();\n}  You can inject this service by using the dependency injection service name.  services:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi.provider.referrer", 
            "title": "Referrer provider"
        }, 
        {
            "location": "/cookbook/usage/referrer-domain/#referrer-twig-extension", 
            "text": "If you need to access to this information in the Twig layer, then there is an\nExtension for that.  {{ referrer() }}\n{{ referrer_domain() }}\n{{ referrer_is_search_engine() }}", 
            "title": "Referrer Twig extension"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-collector/", 
            "text": "How to Implement a Collector\n #\n\n\nIf you look for how to create a simple Collector by using components provided by\nSymfony, you will find nothing. This guide will show you some light about how to\ndo it using existing Symfony code.\n\n\nPlease, read that article from \nMarc Morera\n called\n\nEventListeners as Collectors in Symfony\n\nthat talks about how to implement a simple collector by using the Event \nDispatcher symfony component.", 
            "title": "Implement a collector"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-collector/#how-to-implement-a-collector", 
            "text": "If you look for how to create a simple Collector by using components provided by\nSymfony, you will find nothing. This guide will show you some light about how to\ndo it using existing Symfony code.  Please, read that article from  Marc Morera  called EventListeners as Collectors in Symfony \nthat talks about how to implement a simple collector by using the Event \nDispatcher symfony component.", 
            "title": "How to Implement a Collector"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/", 
            "text": "How to Implement a Controller or a Command\n #\n\n\nControllers and Commands in Elcodi are exactly the same than Controllers and \nCommands in Symfony. No difference between them. But in Elcodi we have a strong\nphilosophy about how to create them in order to be valid or usable in the Open\nSource environment.\n\n\nScenario\n #\n\n\nWe have a Bamboo-based application in our server and we need to create a new \nentry-point for our application, for example a new Controller to manage orders\nfrom specific users, in order to create special newsletters and increase the\nnumber of orders per customer.\n\n\nControllers and Commands are designed and implemented following a simple but\nspecific way. We need to know how both classes are created in Elcodi in order to\nfollow the same philosophy in all places.\n\n\nSolution\n #\n\n\nFollowing this specific way, we need to know the differences between creating\nControllers and Commands as services, or simply rely to the framework the way\nthese classes are auto-discovered.\n\n\nServices in Elcodi\n #\n\n\nAll Elcodi Controllers and Commands are defined as services. This is because we\nare \nOverwriting Oriented Programming\n and we have in mind that every single\nimplementation sensible to be changed between projects must be easily \ncustomized.\n\n\nIn Symfony, and because Dependency Injection definition has a very well documented\noverwriting strategy, we have decided that everything must be defined as a \nservice.\n\n\nWe have a convention about how a Controller and a Command must be registered in\nyour DI container\n\n\nelcodi.controller.image_upload\nelcodi.command.populate_currency_rates\n\n\n\n\nOf course, and because it should only depend on the Symfony Components, but never\nthe Symfony Framework nor the FrameworkBundle, both implementations must not extend\nFramework classes.\n\n\nFramework Controllers in Bamboo\n #\n\n\nWhen you work in Bamboo (or in your project on top of Elcodi Components and \nBundles) we don't recommend the usage of Controllers and Commands as services.\nWe think that both implementations are Entry Points and should be Framework\nrelated.\n\n\nThis means that your Controllers or Commands should never have business logic,\nand should place all this logic in your service layer.\n\n\nHaving said that, we recommend the usage of \nFrameworkBundle\n Controller class to\nendow your controllers with easy access to the DI container and a good set of\npre-built methods.\n\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n */\nclass CartController extends Controller\n{\n}\n\n\n\n\nFramework Commands in Bamboo\n #\n\n\nWe have the same opinion for Commands and Controllers.\n\n\nuse Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\n\n/**\n * Cart controllers\n */\nclass MyCommand extends ContainerAwareCommand\n{\n}\n\n\n\n\nAnnotations in Bamboo Controllers\n #\n\n\nIn Bamboo, we use annotations in all our controllers in order to make the code more\nunderstandable and to focus only on business logic. Annotations solve\nrepetitive things and should be perfectly documented.\n\n\n\n\nMagic? Yes, of course, same magic than yml readers, than Container\ncompilation, than service builds... so what?\n\n\n\n\nFor this reason, we are using \n\nControllerExtraBundle\n and\n\nSensioFrameworkExtraBundle\n.\n\n\nLet's see an example.\n\n\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Entity as AnnotationEntity;\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Form as AnnotationForm;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n *\n * @Route(\n *      path = \n/cart\n,\n * )\n */\nclass CartController extends Controller\n{\n    /**\n     * Cart view\n     *\n     * @param FormView      $formView Form view\n     * @param CartInterface $cart     Cart\n     *\n     * @return Response Response\n     *\n     * @Route(\n     *      path = \n,\n     *      name = \nstore_cart_view\n,\n     *      methods = {\nGET\n}\n     * )\n     *\n     * @AnnotationEntity(\n     *      class = {\n     *          \nfactory\n = \nelcodi.wrapper.cart\n,\n     *          \nmethod\n = \nloadCart\n,\n     *          \nstatic\n = false,\n     *      },\n     *      name = \ncart\n\n     * )\n     * @AnnotationForm(\n     *      class = \nstore_cart_form_type_cart\n,\n     *      name  = \nformView\n,\n     *      entity = \ncart\n,\n     * )\n     */\n    public function viewAction(\n        FormView $formView,\n        CartInterface $cart\n    ) {\n        // ...\n\n        return $this-\nrenderTemplate(\n            'Pages:cart-view.html.twig',\n            [\n                // ...\n            ]\n        );\n    }\n}\n\n\n\n\nYou can find some documentation of both annotation packages\n\n\n\n\nControllerExtraBundle\n\n\nSensioFrameworkExtraBundle\n\n\n\n\nPlease, before using annotations in your project make sure that you know how\nthey work and how to use them. Read the documentation of both packages and try\nto understand their meaning.\n\n\nRelated links\n #\n\n\n\n\nSymfony docs - How to define controllers as services\n\n\nSymfony docs - How to define commands as services", 
            "title": "Implement a controller and a command"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/#how-to-implement-a-controller-or-a-command", 
            "text": "Controllers and Commands in Elcodi are exactly the same than Controllers and \nCommands in Symfony. No difference between them. But in Elcodi we have a strong\nphilosophy about how to create them in order to be valid or usable in the Open\nSource environment.", 
            "title": "How to Implement a Controller or a Command"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/#scenario", 
            "text": "We have a Bamboo-based application in our server and we need to create a new \nentry-point for our application, for example a new Controller to manage orders\nfrom specific users, in order to create special newsletters and increase the\nnumber of orders per customer.  Controllers and Commands are designed and implemented following a simple but\nspecific way. We need to know how both classes are created in Elcodi in order to\nfollow the same philosophy in all places.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/#solution", 
            "text": "Following this specific way, we need to know the differences between creating\nControllers and Commands as services, or simply rely to the framework the way\nthese classes are auto-discovered.  Services in Elcodi  #  All Elcodi Controllers and Commands are defined as services. This is because we\nare  Overwriting Oriented Programming  and we have in mind that every single\nimplementation sensible to be changed between projects must be easily \ncustomized.  In Symfony, and because Dependency Injection definition has a very well documented\noverwriting strategy, we have decided that everything must be defined as a \nservice.  We have a convention about how a Controller and a Command must be registered in\nyour DI container  elcodi.controller.image_upload\nelcodi.command.populate_currency_rates  Of course, and because it should only depend on the Symfony Components, but never\nthe Symfony Framework nor the FrameworkBundle, both implementations must not extend\nFramework classes.  Framework Controllers in Bamboo  #  When you work in Bamboo (or in your project on top of Elcodi Components and \nBundles) we don't recommend the usage of Controllers and Commands as services.\nWe think that both implementations are Entry Points and should be Framework\nrelated.  This means that your Controllers or Commands should never have business logic,\nand should place all this logic in your service layer.  Having said that, we recommend the usage of  FrameworkBundle  Controller class to\nendow your controllers with easy access to the DI container and a good set of\npre-built methods.  use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n */\nclass CartController extends Controller\n{\n}  Framework Commands in Bamboo  #  We have the same opinion for Commands and Controllers.  use Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\n\n/**\n * Cart controllers\n */\nclass MyCommand extends ContainerAwareCommand\n{\n}  Annotations in Bamboo Controllers  #  In Bamboo, we use annotations in all our controllers in order to make the code more\nunderstandable and to focus only on business logic. Annotations solve\nrepetitive things and should be perfectly documented.   Magic? Yes, of course, same magic than yml readers, than Container\ncompilation, than service builds... so what?   For this reason, we are using  ControllerExtraBundle  and SensioFrameworkExtraBundle .  Let's see an example.  use Mmoreram\\ControllerExtraBundle\\Annotation\\Entity as AnnotationEntity;\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Form as AnnotationForm;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n *\n * @Route(\n *      path =  /cart ,\n * )\n */\nclass CartController extends Controller\n{\n    /**\n     * Cart view\n     *\n     * @param FormView      $formView Form view\n     * @param CartInterface $cart     Cart\n     *\n     * @return Response Response\n     *\n     * @Route(\n     *      path =  ,\n     *      name =  store_cart_view ,\n     *      methods = { GET }\n     * )\n     *\n     * @AnnotationEntity(\n     *      class = {\n     *           factory  =  elcodi.wrapper.cart ,\n     *           method  =  loadCart ,\n     *           static  = false,\n     *      },\n     *      name =  cart \n     * )\n     * @AnnotationForm(\n     *      class =  store_cart_form_type_cart ,\n     *      name  =  formView ,\n     *      entity =  cart ,\n     * )\n     */\n    public function viewAction(\n        FormView $formView,\n        CartInterface $cart\n    ) {\n        // ...\n\n        return $this- renderTemplate(\n            'Pages:cart-view.html.twig',\n            [\n                // ...\n            ]\n        );\n    }\n}  You can find some documentation of both annotation packages   ControllerExtraBundle  SensioFrameworkExtraBundle   Please, before using annotations in your project make sure that you know how\nthey work and how to use them. Read the documentation of both packages and try\nto understand their meaning.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/#related-links", 
            "text": "Symfony docs - How to define controllers as services  Symfony docs - How to define commands as services", 
            "title": "Related links"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/", 
            "text": "How to Implement a Factory\n #\n\n\nFactories usage is one of the most distinctive things in Elcodi architecture\nstyle. Every single entity in Elcodi ecosystem is created using its own Factory,\nso by default, an entity should never define its own construction state.\n\n\nScenario\n #\n\n\nOur project have grown and we have some extra needs. We have created new \nentities, and because we strongly believe that an entity is not responsible of \nhow it should be created, the factory should holds this responsibility. \nThis means that an entity should never implement the \n__construct()\n method and \nit should never initialize any variable.\n\n\nIn one of our services we need to create a new entity instance. How easy is \ncreating this entity by using \nnew()\n, right? But then, this piece of code is\nnot testable anymore, so we should be able to mock this new entity.\n\n\nLet's create a new factory for that new entity!\n\n\nSolution\n #\n\n\nA factory is a simple class that, returns a new entity instance once it knows\nhow to build it. Because in Elcodi all entity namespaces are defined by a \nparameter, any factory must use these parameters to create an instance.\n\n\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * @var string\n     *\n     * Entity namespace\n     */\n    protected $entityNamespace;\n\n    /**\n     * Set Entity Namespace\n     *\n     * @param string $entityNamespace Entity namespace\n     *\n     * @return $this Self object\n     */\n    public function setEntityNamespace($entityNamespace)\n    {\n        $this-\nentityNamespace = $entityNamespace;\n\n        return $this;\n    }\n\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this-\ngetEntityNamespace();\n        $language = new $classNamespace();\n\n        $language-\nsetEnabled(false);\n\n        return $language;\n    }\n}\n\n\n\n\nAs you can see, the namespace is injected, and when the factory creates the \ninstance, uses this namespace. With this strategy, the factory becomes uncoupled\nfrom the entity implementation.\n\n\nIn order to make things easier, there is a Trait in package \nelcodi/core\n, \ndesigned to be an abstraction of a Factory. Extending abstract class \n\nAbstractFactory\n as is shown in examples, you can easily access to \n\n$this-\ngetEntityNamespace()\n having the same result as before.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this-\ngetEntityNamespace();\n        $language = new $classNamespace();\n\n        $language-\nsetEnabled(false);\n\n        return $language;\n    }\n}\n\n\n\n\nFactory as a service\n #\n\n\nBecause the factory dependencies need to be resolved, we must define the factory\nas a service.\n\n\nservices:\n\n    #\n    # Factory for entity language\n    #\n    elcodi.factory.language:\n        class: %elcodi.factory.language.class%\n        calls:\n            - [setEntityNamespace, [\n%elcodi.entity.language.class%\n]]\n\n\n\n\nOnce this factory is created as a service, you should inject this factory in \nyour service in order to using them when new entity instance is required.", 
            "title": "Implement a factory"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/#how-to-implement-a-factory", 
            "text": "Factories usage is one of the most distinctive things in Elcodi architecture\nstyle. Every single entity in Elcodi ecosystem is created using its own Factory,\nso by default, an entity should never define its own construction state.", 
            "title": "How to Implement a Factory"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/#scenario", 
            "text": "Our project have grown and we have some extra needs. We have created new \nentities, and because we strongly believe that an entity is not responsible of \nhow it should be created, the factory should holds this responsibility. \nThis means that an entity should never implement the  __construct()  method and \nit should never initialize any variable.  In one of our services we need to create a new entity instance. How easy is \ncreating this entity by using  new() , right? But then, this piece of code is\nnot testable anymore, so we should be able to mock this new entity.  Let's create a new factory for that new entity!", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/#solution", 
            "text": "A factory is a simple class that, returns a new entity instance once it knows\nhow to build it. Because in Elcodi all entity namespaces are defined by a \nparameter, any factory must use these parameters to create an instance.  use Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * @var string\n     *\n     * Entity namespace\n     */\n    protected $entityNamespace;\n\n    /**\n     * Set Entity Namespace\n     *\n     * @param string $entityNamespace Entity namespace\n     *\n     * @return $this Self object\n     */\n    public function setEntityNamespace($entityNamespace)\n    {\n        $this- entityNamespace = $entityNamespace;\n\n        return $this;\n    }\n\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this- getEntityNamespace();\n        $language = new $classNamespace();\n\n        $language- setEnabled(false);\n\n        return $language;\n    }\n}  As you can see, the namespace is injected, and when the factory creates the \ninstance, uses this namespace. With this strategy, the factory becomes uncoupled\nfrom the entity implementation.  In order to make things easier, there is a Trait in package  elcodi/core , \ndesigned to be an abstraction of a Factory. Extending abstract class  AbstractFactory  as is shown in examples, you can easily access to  $this- getEntityNamespace()  having the same result as before.  use Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this- getEntityNamespace();\n        $language = new $classNamespace();\n\n        $language- setEnabled(false);\n\n        return $language;\n    }\n}  Factory as a service  #  Because the factory dependencies need to be resolved, we must define the factory\nas a service.  services:\n\n    #\n    # Factory for entity language\n    #\n    elcodi.factory.language:\n        class: %elcodi.factory.language.class%\n        calls:\n            - [setEntityNamespace, [ %elcodi.entity.language.class% ]]  Once this factory is created as a service, you should inject this factory in \nyour service in order to using them when new entity instance is required.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/", 
            "text": "How to Implement a Form Type\n #\n\n\nA FormType object in Elcodi ecosystem must follow some rules in order to comply\nwith the project flexibility.\n\n\nScenario\n #\n\n\nWe need to manage one of our own new entities. We have created the entity, the\nform and the repository, so we need to create some extra pages in our admin\npanel in order to create, modify and delete them.\n\n\nIn order to create these new pages, we need some mechanism to create these \nforms, being able to do it properly and extensible, following the best Symfony \nand Elcodi standards.\n\n\nSolution\n #\n\n\nAs you may know, whenever we want to work with forms in Symfony, best practices \nsay that we should use FormType classes. These classes are meant to be a PHP \nrepresentation of how a form should be treated and defined.\n\n\nSo let's use them.\n\n\nSymfony Forms\n #\n\n\nSymfony Forms is not a Elcodi-related implementation, so first of all you should\nknow as much as possible about how Symfony Forms works.\n\n\nWe strongly encourage you to learn about them in their documentation before \nproceeding with our specific documentation.\n\n\nSymfony Book - Forms\n\n\nSymfony Best Practices - Forms\n\n\nUsing Factories\n #\n\n\nRemember that every single entity must be created via its factory in Elcodi\nBundles. For more information, please see \nFactories\n. \nIn order to use this feature in Symfony Form Types, we must inject always the \nrelated entity factory.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\n\n/**\n * @var AbstractFactory\n *\n * Factory\n */\nprotected $factory;\n\n/**\n * Sets Factory\n *\n * @param AbstractFactory $factory Factory\n *\n * @return $this Self object\n */\npublic function setFactory(AbstractFactory $factory)\n{\n    $this-\nfactory = $factory;\n\n    return $this;\n}\n\n\n\n\nAfter the factory is injected, we can use it in our FormType specification for\ndefining the \nempty_data\n value and the \ndata_class\n.\n\n\n/**\n * Default form options\n *\n * @param OptionsResolverInterface $resolver\n *\n * @return array With the options\n */\npublic function setDefaultOptions(OptionsResolverInterface $resolver)\n{\n    $resolver-\nsetDefaults([\n        'empty_data' =\n function () {\n            $this\n                -\nfactory\n                -\ncreate();\n        },\n        'data_class' =\n $this\n            -\nfactory\n            -\ngetEntityNamespace(),\n    ]);\n}\n\n\n\n\nIn order to make things easier, there is a Trait in the package \nelcodi/core\n, \ndesigned as a Factory container. To use it, just add it in your class, like any\nother trait, and you will be able to use the \n$this-\nfactory\n in your class.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Traits\\FactoryTrait;\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * Default form options\n     *\n     * @param OptionsResolverInterface $resolver\n     *\n     * @return array With the options\n     */\n    public function setDefaultOptions(OptionsResolverInterface $resolver)\n    {\n        $resolver-\nsetDefaults([\n            'empty_data' =\n function () {\n                $this\n                    -\nfactory\n                    -\ncreate();\n            },\n            'data_class' =\n $this\n                -\nfactory\n                -\ngetEntityNamespace(),\n        ]);\n    }\n}\n\n\n\n\nUsing namespaces\n #\n\n\nIf your FormType has any kind of relation with another entity, you will need to\ndefine this relation using a namespace. In order to comply again with the\nflexibility, we need to inject all namespaces using the entity manager \nparameter.\n\n\nThese namespaces in Elcodi must be injected through the class constructor.\n\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * @var string\n     *\n     * Image namespace\n     */\n    protected $imageNamespace;\n\n    /**\n     * Construct\n     *\n     * @param string $imageNamespace Image namespace\n     */\n    public function __construct($imageNamespace)\n    {\n        $this-\nimageNamespace = $imageNamespace;\n    }\n\n    /**\n     * buildForm function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            -\nadd('image', 'entity', [\n                'class'    =\n $this-\nimageNamespace,\n                'required' =\n false,\n                'label'    =\n 'image',\n                'multiple' =\n false,\n            ]);\n    }\n}\n\n\n\n\nFormType as a service\n #\n\n\nWe are using dependencies in our FormTypes, so remember that we need to define \nour classes as services.\n\n\nservices:\n\n    #\n    # Form Types\n    #\n    elcodi.admin.banner.form_type.banner:\n        class: Elcodi\\Admin\\BannerBundle\\Form\\Type\\BannerType\n        arguments:\n            - %elcodi.entity.image.class%\n        calls:\n            - [setFactory, [@elcodi.factory.banner]]\n        tags:\n            - { name: form.type, alias: elcodi_admin_banner_form_type_banner }\n\n\n\n\nThe alias of the FormType must be the same as the value returned by the method\n\ngetName()\n of the class\n\n\n/**\n * Return unique name for this form\n *\n * @return string\n */\npublic function getName()\n{\n    return 'elcodi_admin_banner_form_type_banner';\n}", 
            "title": "Implement a form type"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/#how-to-implement-a-form-type", 
            "text": "A FormType object in Elcodi ecosystem must follow some rules in order to comply\nwith the project flexibility.", 
            "title": "How to Implement a Form Type"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/#scenario", 
            "text": "We need to manage one of our own new entities. We have created the entity, the\nform and the repository, so we need to create some extra pages in our admin\npanel in order to create, modify and delete them.  In order to create these new pages, we need some mechanism to create these \nforms, being able to do it properly and extensible, following the best Symfony \nand Elcodi standards.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/#solution", 
            "text": "As you may know, whenever we want to work with forms in Symfony, best practices \nsay that we should use FormType classes. These classes are meant to be a PHP \nrepresentation of how a form should be treated and defined.  So let's use them.  Symfony Forms  #  Symfony Forms is not a Elcodi-related implementation, so first of all you should\nknow as much as possible about how Symfony Forms works.  We strongly encourage you to learn about them in their documentation before \nproceeding with our specific documentation.  Symfony Book - Forms  Symfony Best Practices - Forms  Using Factories  #  Remember that every single entity must be created via its factory in Elcodi\nBundles. For more information, please see  Factories . \nIn order to use this feature in Symfony Form Types, we must inject always the \nrelated entity factory.  use Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\n\n/**\n * @var AbstractFactory\n *\n * Factory\n */\nprotected $factory;\n\n/**\n * Sets Factory\n *\n * @param AbstractFactory $factory Factory\n *\n * @return $this Self object\n */\npublic function setFactory(AbstractFactory $factory)\n{\n    $this- factory = $factory;\n\n    return $this;\n}  After the factory is injected, we can use it in our FormType specification for\ndefining the  empty_data  value and the  data_class .  /**\n * Default form options\n *\n * @param OptionsResolverInterface $resolver\n *\n * @return array With the options\n */\npublic function setDefaultOptions(OptionsResolverInterface $resolver)\n{\n    $resolver- setDefaults([\n        'empty_data' =  function () {\n            $this\n                - factory\n                - create();\n        },\n        'data_class' =  $this\n            - factory\n            - getEntityNamespace(),\n    ]);\n}  In order to make things easier, there is a Trait in the package  elcodi/core , \ndesigned as a Factory container. To use it, just add it in your class, like any\nother trait, and you will be able to use the  $this- factory  in your class.  use Elcodi\\Component\\Core\\Factory\\Traits\\FactoryTrait;\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * Default form options\n     *\n     * @param OptionsResolverInterface $resolver\n     *\n     * @return array With the options\n     */\n    public function setDefaultOptions(OptionsResolverInterface $resolver)\n    {\n        $resolver- setDefaults([\n            'empty_data' =  function () {\n                $this\n                    - factory\n                    - create();\n            },\n            'data_class' =  $this\n                - factory\n                - getEntityNamespace(),\n        ]);\n    }\n}  Using namespaces  #  If your FormType has any kind of relation with another entity, you will need to\ndefine this relation using a namespace. In order to comply again with the\nflexibility, we need to inject all namespaces using the entity manager \nparameter.  These namespaces in Elcodi must be injected through the class constructor.  /**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * @var string\n     *\n     * Image namespace\n     */\n    protected $imageNamespace;\n\n    /**\n     * Construct\n     *\n     * @param string $imageNamespace Image namespace\n     */\n    public function __construct($imageNamespace)\n    {\n        $this- imageNamespace = $imageNamespace;\n    }\n\n    /**\n     * buildForm function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            - add('image', 'entity', [\n                'class'    =  $this- imageNamespace,\n                'required' =  false,\n                'label'    =  'image',\n                'multiple' =  false,\n            ]);\n    }\n}  FormType as a service  #  We are using dependencies in our FormTypes, so remember that we need to define \nour classes as services.  services:\n\n    #\n    # Form Types\n    #\n    elcodi.admin.banner.form_type.banner:\n        class: Elcodi\\Admin\\BannerBundle\\Form\\Type\\BannerType\n        arguments:\n            - %elcodi.entity.image.class%\n        calls:\n            - [setFactory, [@elcodi.factory.banner]]\n        tags:\n            - { name: form.type, alias: elcodi_admin_banner_form_type_banner }  The alias of the FormType must be the same as the value returned by the method getName()  of the class  /**\n * Return unique name for this form\n *\n * @return string\n */\npublic function getName()\n{\n    return 'elcodi_admin_banner_form_type_banner';\n}", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/", 
            "text": "How to Implement a Repository\n #\n\n\nCreating a repository in Elcodi is easy. Elcodi type repositories are used in the same\nway Symfony uses its repository classes.\n\n\nScenario\n #\n\n\nWe have created a new entity properly, and we are happy about that. We have a \nnew service that must create a specific search against this new entity, and we\nneed some nice class to place this logic\n\n\nWhat people need to create complicated search queries, they are used to placing\nall this logic inside their services using the repository. Great, this can be a\ngood decision if you're not planning to test your application. If you want, then\nyou should use your repositories as are meant to be used: one repository per \nentity with all specific query logic.\n\n\nSolution\n #\n\n\nEach entity has its own Repository. You will find all entities related \nrepositories inside the Components, hosted in \nRepository/\n folders.\n\n\nAll of them are mostly empty, because they extend \nAbstractRepository\n and, thereby\ndefault, have a set of accessible public methods. However some of them have custom\nmethods in order to build specific and complex queries.\n\n\nRelated Links\n #\n\n\n\n\n[Symfony docs - Custom repository classes]http://symfony.com/doc/current/book/doctrine.html#custom-repository-classes)", 
            "title": "Implement a repository"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/#how-to-implement-a-repository", 
            "text": "Creating a repository in Elcodi is easy. Elcodi type repositories are used in the same\nway Symfony uses its repository classes.", 
            "title": "How to Implement a Repository"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/#scenario", 
            "text": "We have created a new entity properly, and we are happy about that. We have a \nnew service that must create a specific search against this new entity, and we\nneed some nice class to place this logic  What people need to create complicated search queries, they are used to placing\nall this logic inside their services using the repository. Great, this can be a\ngood decision if you're not planning to test your application. If you want, then\nyou should use your repositories as are meant to be used: one repository per \nentity with all specific query logic.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/#solution", 
            "text": "Each entity has its own Repository. You will find all entities related \nrepositories inside the Components, hosted in  Repository/  folders.  All of them are mostly empty, because they extend  AbstractRepository  and, thereby\ndefault, have a set of accessible public methods. However some of them have custom\nmethods in order to build specific and complex queries.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/#related-links", 
            "text": "[Symfony docs - Custom repository classes]http://symfony.com/doc/current/book/doctrine.html#custom-repository-classes)", 
            "title": "Related Links"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/", 
            "text": "How to Implement an Entity\n #\n\n\nIn Elcodi we use an extremely thin model. It means that our entities are just\nparameters, getters and setters.\n\n\nScenario\n #\n\n\nOur website must start managing warehouses. We must be able to create new\nwarehouses, edit them and deleting them, as well as create new associations \nbetween warehouses and locations, in order to locate them.\n\n\nOur model needs to change, so our application should be enough robust to be \nchanged without many pain.\n\n\nSolution\n #\n\n\nIn order to change our model, we need to create a new entity following the \nstandards of Elcodi.\n\n\nCreating an entity is as easy as defining what an actor should own (parameters),\nforgetting about the behavior of this one. This logic will be placed then in the \nservice layer.\n\n\nLet's see a basic implementation of an entity.\n\n\nclass Warehouse\n{\n    /**\n     * @var name\n     *\n     * Product name\n     */\n    protected $name;\n\n    /**\n     * Get name\n     *\n     * @return string Product name\n     */\n    public function getName()\n    {\n        return $this-\nname;\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Product name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this-\nname = $name;\n\n        return $this;\n    }\n}\n\n\n\n\nAs you can see all properties are defined as protected. This is because Doctrine\nwill need to extend the class using \ntransparent Proxy Objects\n\nto implement lazy-loading.\n\n\nUsing Interfaces\n #\n\n\nAll Elcodi entities are an implementation of a \n\nHeader Interface\n.\nWe use some \n\nRole Interfaces\n in\nour code, but we are more focused in the first one because is more \nunderstandable for everyone when overriding default implementations.\n\n\nuse MyComponent\\Warehouse\\Entity\\Interfaces\\WarehouseInterface;\n\n/**\n * Class Warehouse\n */\nclass Warehouse implements WarehouseInterface\n{\n    // ...\n}\n\n\n\n\nUsing SimpleDoctrineMapping\n #\n\n\nUsually, final projects need to implement more entities inside their projects.\nSince now, this has been so easy but so magical, and once again, we really think\nthat this stuff should never be magic at all. Is your model, your business.\n\n\nIn our actual implementation, we are using an Open Source project called \n\nSimpleDoctrineMapping\n. \nYou should read carefully the documentation, indeed we strongly recommend it.\n\n\nYes, we need to say that, we'll need to disable the \nauto_mapping\n configuration \nitem inside DoctrineBundle. This flag allow this magic we really want to avoid.\n\n\nInstead of that, we will specifically define how our entities should be defined\nand treated inside our project.\n\n\nRelated links\n #\n\n\n\n\nSimpleDoctrineMapping Docs", 
            "title": "Implement an entity"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/#how-to-implement-an-entity", 
            "text": "In Elcodi we use an extremely thin model. It means that our entities are just\nparameters, getters and setters.", 
            "title": "How to Implement an Entity"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/#scenario", 
            "text": "Our website must start managing warehouses. We must be able to create new\nwarehouses, edit them and deleting them, as well as create new associations \nbetween warehouses and locations, in order to locate them.  Our model needs to change, so our application should be enough robust to be \nchanged without many pain.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/#solution", 
            "text": "In order to change our model, we need to create a new entity following the \nstandards of Elcodi.  Creating an entity is as easy as defining what an actor should own (parameters),\nforgetting about the behavior of this one. This logic will be placed then in the \nservice layer.  Let's see a basic implementation of an entity.  class Warehouse\n{\n    /**\n     * @var name\n     *\n     * Product name\n     */\n    protected $name;\n\n    /**\n     * Get name\n     *\n     * @return string Product name\n     */\n    public function getName()\n    {\n        return $this- name;\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Product name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this- name = $name;\n\n        return $this;\n    }\n}  As you can see all properties are defined as protected. This is because Doctrine\nwill need to extend the class using  transparent Proxy Objects \nto implement lazy-loading.  Using Interfaces  #  All Elcodi entities are an implementation of a  \nHeader Interface .\nWe use some  Role Interfaces  in\nour code, but we are more focused in the first one because is more \nunderstandable for everyone when overriding default implementations.  use MyComponent\\Warehouse\\Entity\\Interfaces\\WarehouseInterface;\n\n/**\n * Class Warehouse\n */\nclass Warehouse implements WarehouseInterface\n{\n    // ...\n}  Using SimpleDoctrineMapping  #  Usually, final projects need to implement more entities inside their projects.\nSince now, this has been so easy but so magical, and once again, we really think\nthat this stuff should never be magic at all. Is your model, your business.  In our actual implementation, we are using an Open Source project called  SimpleDoctrineMapping . \nYou should read carefully the documentation, indeed we strongly recommend it.  Yes, we need to say that, we'll need to disable the  auto_mapping  configuration \nitem inside DoctrineBundle. This flag allow this magic we really want to avoid.  Instead of that, we will specifically define how our entities should be defined\nand treated inside our project.", 
            "title": "Solution"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/#related-links", 
            "text": "SimpleDoctrineMapping Docs", 
            "title": "Related links"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-event-listener/", 
            "text": "How to implement an Event Listener\n #\n\n\nOne of the good reasons to work with Symfony is because has a great and big\nextension point. Symfony uses it's own Event Dispatcher component.\n\n\nScenario\n #\n\n\nOur project needs to grow with new features related to existing ones. Because of\nElcodi is always installed as a vendor, we should not be able to modify it at \nall. For example, each time an order is created, we should be able to send the\nadministrator of the website a new email.\n\n\nWe need to know how Event Listeners must be created in order to use them \nproperly, using Elcodi best practices and naming conventions.\n\n\nSolution\n #\n\n\nWhen we talk about Event Listeners in Symfony, we should think about a service \nwith an extra layer of configuration. For example, following the example exposed\nabove, let's create a new service that sends that email we need.\n\n\nOf course, this is not only a service but an EventListener, so the chosen method\nmust accept only one parameter. Depending of the event you want to hook your \nmethod, you will receive one Event type or other.\n\n\n\n\nYou should know something about the Event Dispatcher from Symfony. We strongly\nrecommend you to read something about it before continue reading this \ndocumentation.\n\n\n\n\nEach type of event is associated with a different type of event instance, so you\nshould \n\n\nuse Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface;\nuse Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * This class is intended to send an Email when any order is created\n */\nclass OrderEmailSenderEventListener\n{\n    /**\n     * @var string\n     *\n     * Address where the email has to be sent\n     */\n    private $email;\n\n    /**\n     * Send an email to the administrator of the website, once an Order has been\n     * successfully created.\n     *\n     * @param OrderOnCreatedEvent $event Order on Created event\n     *\n     * @return $this Self object\n     */\n    public function sendEmail(OrderOnCreatedEvent $event)\n    {\n        $order = $event-\ngetOrder();\n        // Send that email using $this-\nemail!\n\n        return $this;\n    }\n}\n\n\n\n\nIsolating your business logic\n #\n\n\nOur last implementation has one issue if you consider important your business\nlogic.\n\n\nImagine that you need to send this email from another service. Of course, this\nservice should know nothing about any kind of event, so, using last \nimplementation, something is clearly wrong.\n\n\nLet's see how we can fix improve this by doing just some small changes!\n\n\nuse Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface;\nuse Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * This class is intended to send an Email when any order is created\n */\nclass OrderEmailSenderEventListener\n{\n    /**\n     * @var string\n     *\n     * Address where the email has to be sent\n     */\n    private $email;\n\n    /**\n     * Send an email to the administrator of the website, once an Order has been\n     * successfully created.\n     *\n     * @param OrderOnCreatedEvent $event Order on Created event\n     *\n     * @return $this Self object\n     */\n    public function sendEmail(OrderOnCreatedEvent $event)\n    {\n        $order = $event-\ngetOrder();\n        $this-\nsendEmailByOrderAndEmail(\n            $order,\n            $this-\nemail\n        );\n\n        return $this;\n    }\n\n     /**\n      * Send an specific email given an order instance and the address where the\n      * email must be sent\n      *\n      * @param OrderInterface $order Order\n      * @param string         $email Email\n      *\n      * @return $this Self object\n      */\n    public function sendEmailByOrderAndEmail(OrderInterface $order, $email)\n    {\n        // Send that email using $this-\nemail!\n\n        return $this;\n    }\n}\n\n\n\n\nWith this implementation you can still be listening to the \norder.oncreated\n\nevent, and your business logic can be accessed from any point of entry.\n\n\nUsing Dependency Injection Tags\n #\n\n\nOnce the class is created and tested, we should add this extra configuration\nlayer in our Dependency Injection definition. And we will do such thing by using\ntags.\n\n\n\n\nOnce again, this is not Elcodi related, but Symfony. You can check a little \nbit more information by checking the Symfony Docs\n\n\n\n\nLet's see an example of how this configuration could be.\n\n\nservices:\n\n    elcodi.event_listener.order_email_sender:\n        class: My\\Bundle\\EventListener\\OrderEmailSenderEventListener\n        arguments:\n            - %administrator_email%\n        tags:\n            - { name: kernel.event_listener, event: order.oncreated, method: sendEmail }", 
            "title": "Implement an event listener"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-event-listener/#how-to-implement-an-event-listener", 
            "text": "One of the good reasons to work with Symfony is because has a great and big\nextension point. Symfony uses it's own Event Dispatcher component.", 
            "title": "How to implement an Event Listener"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-event-listener/#scenario", 
            "text": "Our project needs to grow with new features related to existing ones. Because of\nElcodi is always installed as a vendor, we should not be able to modify it at \nall. For example, each time an order is created, we should be able to send the\nadministrator of the website a new email.  We need to know how Event Listeners must be created in order to use them \nproperly, using Elcodi best practices and naming conventions.", 
            "title": "Scenario"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-event-listener/#solution", 
            "text": "When we talk about Event Listeners in Symfony, we should think about a service \nwith an extra layer of configuration. For example, following the example exposed\nabove, let's create a new service that sends that email we need.  Of course, this is not only a service but an EventListener, so the chosen method\nmust accept only one parameter. Depending of the event you want to hook your \nmethod, you will receive one Event type or other.   You should know something about the Event Dispatcher from Symfony. We strongly\nrecommend you to read something about it before continue reading this \ndocumentation.   Each type of event is associated with a different type of event instance, so you\nshould   use Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface;\nuse Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * This class is intended to send an Email when any order is created\n */\nclass OrderEmailSenderEventListener\n{\n    /**\n     * @var string\n     *\n     * Address where the email has to be sent\n     */\n    private $email;\n\n    /**\n     * Send an email to the administrator of the website, once an Order has been\n     * successfully created.\n     *\n     * @param OrderOnCreatedEvent $event Order on Created event\n     *\n     * @return $this Self object\n     */\n    public function sendEmail(OrderOnCreatedEvent $event)\n    {\n        $order = $event- getOrder();\n        // Send that email using $this- email!\n\n        return $this;\n    }\n}  Isolating your business logic  #  Our last implementation has one issue if you consider important your business\nlogic.  Imagine that you need to send this email from another service. Of course, this\nservice should know nothing about any kind of event, so, using last \nimplementation, something is clearly wrong.  Let's see how we can fix improve this by doing just some small changes!  use Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface;\nuse Elcodi\\Component\\Cart\\Event\\OrderOnCreatedEvent;\n\n/**\n * This class is intended to send an Email when any order is created\n */\nclass OrderEmailSenderEventListener\n{\n    /**\n     * @var string\n     *\n     * Address where the email has to be sent\n     */\n    private $email;\n\n    /**\n     * Send an email to the administrator of the website, once an Order has been\n     * successfully created.\n     *\n     * @param OrderOnCreatedEvent $event Order on Created event\n     *\n     * @return $this Self object\n     */\n    public function sendEmail(OrderOnCreatedEvent $event)\n    {\n        $order = $event- getOrder();\n        $this- sendEmailByOrderAndEmail(\n            $order,\n            $this- email\n        );\n\n        return $this;\n    }\n\n     /**\n      * Send an specific email given an order instance and the address where the\n      * email must be sent\n      *\n      * @param OrderInterface $order Order\n      * @param string         $email Email\n      *\n      * @return $this Self object\n      */\n    public function sendEmailByOrderAndEmail(OrderInterface $order, $email)\n    {\n        // Send that email using $this- email!\n\n        return $this;\n    }\n}  With this implementation you can still be listening to the  order.oncreated \nevent, and your business logic can be accessed from any point of entry.  Using Dependency Injection Tags  #  Once the class is created and tested, we should add this extra configuration\nlayer in our Dependency Injection definition. And we will do such thing by using\ntags.   Once again, this is not Elcodi related, but Symfony. You can check a little \nbit more information by checking the Symfony Docs   Let's see an example of how this configuration could be.  services:\n\n    elcodi.event_listener.order_email_sender:\n        class: My\\Bundle\\EventListener\\OrderEmailSenderEventListener\n        arguments:\n            - %administrator_email%\n        tags:\n            - { name: kernel.event_listener, event: order.oncreated, method: sendEmail }", 
            "title": "Solution"
        }, 
        {
            "location": "/component/entity-translator/", 
            "text": "Entity Translator\n #\n\n\nTranslate your entities in a very decoupled way.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nThe main goal of this repository is to create an specific translation layer on \ntop of any entity, using a simple and soft layer over the mapping doctrine, and\nnot mixing them, as this would be a bad practice.\n\n\nWhat offers\n #\n\n\nThis package offers, as a bundle, the mechanism of adding automatically all this\nlayer by using several Doctrine and Form event listeners. With a simple \nconfiguration can handle all the translations.\n\n\nUsage\n #\n\n\nThe model is the most important part of a project, right? We strongly believe\nthat, so we think that coupling the entities with the translation infrastructure\nis a bad practice.\n\n\nThis component provides an external translation engine with some nice services\nto make an entity translation something really easy and enjoyable.\n\n\nLet's figure out we are working with a Product object. Our model clean, with two\nfields: name and description. All this documentation assumes the usage of this\nclass.\n\n\n/**\n * Class Product\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n\n    /**\n     * Get Id\n     *\n     * @return string Id\n     */\n    public function getId()\n    {\n        return $this-\nid;\n    }\n\n    /**\n     * Sets Id\n     *\n     * @param string $id Id\n     *\n     * @return $this Self object\n     */\n    public function setId($id)\n    {\n        $this-\nid = $id;\n\n        return $this;\n    }\n\n    /**\n     * Get Name\n     *\n     * @return mixed Name\n     */\n    public function getName()\n    {\n        return $this-\nname;\n    }\n\n    /**\n     * Sets Name\n     *\n     * @param mixed $name Name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this-\nname = $name;\n\n        return $this;\n    }\n\n    /**\n     * Get Description\n     *\n     * @return string Description\n     */\n    public function getDescription()\n    {\n        return $this-\ndescription;\n    }\n\n    /**\n     * Sets Description\n     *\n     * @param string $description Description\n     *\n     * @return $this Self object\n     */\n    public function setDescription($description)\n    {\n        $this-\ndescription = $description;\n\n        return $this;\n    }\n}\n\n\n\n\nWe want to manage the translations of both properties. Important, each project\nneeds to define what fields must be translatable, this is not related to the\ncomponent itself.\n\n\nEntityTranslationProvider\n #\n\n\nThe translation provider is responsible to connect with the persistent layer and\nprovide the results, using an specific format, to the managers and services.\n\n\n/**\n * Interface EntityTranslationProviderInterface\n */\ninterface EntityTranslationProviderInterface\n{\n    /**\n     * Get translation\n     *\n     * @param string $entityType  Type of entity\n     * @param string $entityId    Id of entity\n     * @param string $entityField Field of entity\n     * @param string $locale      Locale\n     *\n     * @return string Value fetched\n     */\n    public function getTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $locale\n    );\n\n    /**\n     * Set translation\n     *\n     * @param string $entityType       Type of entity\n     * @param string $entityId         Id of entity\n     * @param string $entityField      Field of entity\n     * @param string $translationValue Translated value\n     * @param string $locale           Locale\n     *\n     * @return string Value fetched\n     */\n    public function setTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $translationValue,\n        $locale\n    );\n\n    /**\n     * Flush all previously set translations.\n     *\n     * @return $this self Object\n     */\n    public function flushTranslations();\n}\n\n\n\n\nThere is the possibility of using specific providers for some specific\ndecorations, for example, the \nCachedEntityTranslationProvider\n implementation,\nthat decorates the main provider by adding an extra cache layer.\n\n\nEntityTranslatorBuilder\n #\n\n\nTranslation configuration is not set on the fly. It means that a Translator\nneeds to know what entities and what fields must take in account for\ntranslations.\n\n\nFor that reason we need to build the translator using a TranslatorBuilder.\n\n\n$entityTranslationProvider;\n$entityTranslatorFactory = new TranslatorFactory();\n$entityTranslator = $this-\ngetMock(\n    'Elcodi\\Component\\EntityTranslator\\Services\\EntityTranslator', \n    [], \n    [], \n    '', \n    false\n);\n\n$configuration = [\n    'Elcodi\\Component\\EntityTranslator\\Tests\\Fixtures\\TranslatableProduct' =\n [\n        'alias'  =\n 'product',\n        'idGetter' =\n 'getId',\n        'fields' =\n [\n            'name' =\n [\n                'setter' =\n 'setName',\n                'getter' =\n 'getName',\n            ]\n        ]\n    ],\n];\n\n$entityTranslatorBuilder = new EntityTranslatorBuilder(\n    $entityTranslationProvider,\n    $translatorFactory,\n    $configuration\n);\n$entityTranslator = $translatorBuilder-\ncompile();\n\n\n\n\nA compiled translator is, somehow, an immutable object. This means that,\ninternally, can change because of new instances, but externally can only be\naccessed by getters.\n\n\nEntityTranslator\n #\n\n\nThe translator itself. This implementation enables you to work with entities\ninstead of translations.\n\n\n/**\n * Interface EntityTranslatorInterface\n */\ninterface EntityTranslatorInterface\n{\n    /**\n     * Translate object\n     *\n     * @param Object $object Object\n     * @param string $locale Locale to be translated\n     */\n    public function translate($object, $locale);\n\n    /**\n     * Saves object translations\n     *\n     * @param Object $object       Object\n     * @param array  $translations Translations\n     */\n    public function save($object, array $translations);\n}\n\n\n\n\nUsing the same configuration than before, lets see an example about how we can\nmanage our entity translations using this service.\n\n\n$product = new TranslatableProduct();\n$product\n    -\nsetId(1)\n    -\nsetName('productName');\n\n$entityTranslator-\nsave($product, [\n    'es' =\n [\n        'name' =\n 'el nombre',\n        'description' =\n 'la descripci\u00f3n',\n    ],\n    'en' =\n [\n        'name' =\n 'the name',\n        'description' =\n 'the description',\n        'anotherfield' =\n 'some value',\n    ],\n]);\n\n/**\n * At this point, all the data have been persisted to database and cached.\n * As you can see, the `translate` method returns the translated object, but\n * both objects are the same\n */\n\n$translatedProduct = $translator-\ntranslate($product, 'en');\n\n$translatedName = $translatedProduct-\ngetName();\necho $translatedName;\n// = \nthe name\n\n\n/**\n * So because both object are the same, you can just apply the translation\n * without using the returned object\n */\n\n$translator-\ntranslate($product, 'es');\n\n$translatedName = $product-\ngetName();\necho $translatedName;\n// = \nel nombre\n\n\n\n\n\n\nTo when you save all the translations of an entity, the \nEntityTranslator\n will\nmake a unique flush to the persistence layer, in order to improve this action.\n\n\nUsing Doctrine\n #\n\n\nEasy and simple. Let's work with a simple entity mapped in Doctrine.\n\n\n/**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type=\nstring\n)\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type=\ntext\n)\n     *\n     * Description\n     */\n    protected $description;\n}\n\n\n\n\nThis example will assume that you want to make both fields, name and\ndescription, translatable. To make it happen, we can simply remove  the mapping\nof both fields, to rely the responsibility of translation to the Translator\ncomponent.\n\n\n/**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n}\n\n\n\n\nNow your installation will see the Product as a simple id. Why is this good for\nus? This example uses Annotations, and we highly recommend to define all your\nmapping configuration using \nyml\n so you can easily decouple your model\nimplementation (entities) and your mapping configuration (Product.orm.yml) and\ndisable some fields for mapping with the same entity implementation.\n\n\nConfiguring the entity translator\n #\n\n\nNow, we need to configure the translator. You need to define what entities and\nfields you allow the engine to manage. Let's see the configuration for this\nexample.\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n\n            // idGetter, by default, getId\n            idGetter: getId\n            fields:\n                name:\n                    // getter, by default, getName in this case\n                    // setter, by default, setName in this case\n                    getter: getName\n                    setter: setName\n                description:\n                    getter: getDescription\n                    setter: setDescription\n\n\n\n\nThis is the basic definition of the Product translation. You can see that there\nis come specific information set by default, so indeed, this configuration could\nbe defined as well that way\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n            fields:\n                name: ~\n                description: ~\n\n\n\n\nYou can use Interfaces as well, so in that case, to ensure that the\nconfiguration will be still valid even if you change the Product implementation,\nyou can use an Interface for that\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Interfaces\\ProductInterface:\n            alias: product\n            fields:\n                name: ~\n                description: ~\n\n\n\n\nSaving translations\n #\n\n\nDo you want to translate an entity? Great, let's do that! You can easily manage\nyour translation using the entity translator service.\n\n\n$entityTranslator = $this\n    -\ncontainer\n    -\nget('elcodi.entity_translator');\n\n\n\n\nOnce you have the service instance, you can set your entity translations in a\nvery simple way. In this example, let's create a new entity, let's save it into\ndatabase and let's translate it.\n\n\n$product = new Product();\n$product-\nsetId(1);\n\n$entityTranslator-\nsave($product, [\n    'es' =\n [\n        'name' =\n 'el nombre',\n        'description' =\n 'la descripci\u00f3n',\n    ],\n    'en' =\n [\n        'name' =\n 'the name',\n        'description' =\n 'the description',\n        'anotherfield' =\n 'some value',\n    ],\n]);\n\n\n\n\nTranslating an entity\n #\n\n\nSo, your entity is translated? Well, let's load the translations of an entity.\nYou only need the entity and the language you want it to be translated to.\n\n\n$product = $this\n    -\nget('doctrine.orm.entity_manager')\n    -\nfind(1);\n\n$entityTranslator-\ntranslate($product, 'en');\n\n\n\n\nAnd that's it. Your product is now translated to english, and because both\nfields, name and description, are not mapped anymore, you could flush the entity\nmanager and no information would be saved.\n\n\nTranslations in forms\n #\n\n\nThis is maybe the most important feature of this Bundle. How can we handle all\nthis stuff in our forms? Very simple. We don't have to change our form\ndefinition but only adapt it to add an EventSubscriber.\n\n\nLet's see an example.\n\n\nuse Elcodi\\Component\\EntityTranslator\\EventListener\\Traits\\EntityTranslatableFormTrait;\nuse Symfony\\Component\\Form\\AbstractType;\n\n/**\n * Class ProductType\n */\nclass ProductType extends AbstractType\n{\n    use EntityTranslatableFormTrait;\n\n    /**\n     * Buildform function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            -\nadd('name', 'text', [\n                'required' =\n true,\n                'label'    =\n 'name',\n            ])\n            -\nadd('description', 'textarea', [\n                'required' =\n false,\n                'label'    =\n 'description',\n            ]);\n\n        $builder-\naddEventSubscriber($this-\ngetEntityTranslatorFormEventListener());\n    }\n\n    /**\n     * Return unique name for this form\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return 'form_type_product';\n    }\n}\n\n\n\n\nAs you can see, there are only two changes in this formType. First one is that\nyou must add this trait in order to add a protected variable and two methods.\nThe second change is that you must add the EventSubscriber the way is shown in\nthe example.\n\n\nBecause now the formType has some dependencies, you must define this formType as\na service in the dependency injection configuration.\n\n\nservices:\n    form_type.product:\n        class: My\\Namespace\\Form\\Type\\ProductType\n        calls:\n            - [setEntityTranslatorFormEventListener, [@elcodi.entity_translator_form_event_listener]]\n        tags:\n            - { name: form.type, alias: form_type_product }\n\n\n\n\nAnd that's it. Try to render your form, treating name and description like they\nwere normal fields and what you will see is that, instead of rendering a text\ninput field and a Textarea, three of each will be rendered.\n\n\nCustom form views\n #\n\n\nYou can easily customize the way of rendering these fields by adding some format\ninto the rendering of \ntranslatable_field\n. You can find more information in\nchapter - \nWhat are Form Themes?\n\n\nAutomatic entity translation\n #\n\n\nYou can enable the automatic translation of all loaded entities by enabling the\nrelated configuration flag \nauto_translate\n.\n\n\nelcodi_entity_translation:\n    auto_translate: true\n\n\n\n\nBy default this value is true. If true, every time you load a new entity from\nDoctrine than is defined as translatable (a field is included in the\nconfiguration), that entity will be translated using the current locale.", 
            "title": "Entity translator"
        }, 
        {
            "location": "/component/entity-translator/#entity-translator", 
            "text": "Translate your entities in a very decoupled way.   Component Repository  Bundle Repository   The main goal of this repository is to create an specific translation layer on \ntop of any entity, using a simple and soft layer over the mapping doctrine, and\nnot mixing them, as this would be a bad practice.", 
            "title": "Entity Translator"
        }, 
        {
            "location": "/component/entity-translator/#what-offers", 
            "text": "This package offers, as a bundle, the mechanism of adding automatically all this\nlayer by using several Doctrine and Form event listeners. With a simple \nconfiguration can handle all the translations.", 
            "title": "What offers"
        }, 
        {
            "location": "/component/entity-translator/#usage", 
            "text": "The model is the most important part of a project, right? We strongly believe\nthat, so we think that coupling the entities with the translation infrastructure\nis a bad practice.  This component provides an external translation engine with some nice services\nto make an entity translation something really easy and enjoyable.  Let's figure out we are working with a Product object. Our model clean, with two\nfields: name and description. All this documentation assumes the usage of this\nclass.  /**\n * Class Product\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n\n    /**\n     * Get Id\n     *\n     * @return string Id\n     */\n    public function getId()\n    {\n        return $this- id;\n    }\n\n    /**\n     * Sets Id\n     *\n     * @param string $id Id\n     *\n     * @return $this Self object\n     */\n    public function setId($id)\n    {\n        $this- id = $id;\n\n        return $this;\n    }\n\n    /**\n     * Get Name\n     *\n     * @return mixed Name\n     */\n    public function getName()\n    {\n        return $this- name;\n    }\n\n    /**\n     * Sets Name\n     *\n     * @param mixed $name Name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this- name = $name;\n\n        return $this;\n    }\n\n    /**\n     * Get Description\n     *\n     * @return string Description\n     */\n    public function getDescription()\n    {\n        return $this- description;\n    }\n\n    /**\n     * Sets Description\n     *\n     * @param string $description Description\n     *\n     * @return $this Self object\n     */\n    public function setDescription($description)\n    {\n        $this- description = $description;\n\n        return $this;\n    }\n}  We want to manage the translations of both properties. Important, each project\nneeds to define what fields must be translatable, this is not related to the\ncomponent itself.", 
            "title": "Usage"
        }, 
        {
            "location": "/component/entity-translator/#entitytranslationprovider", 
            "text": "The translation provider is responsible to connect with the persistent layer and\nprovide the results, using an specific format, to the managers and services.  /**\n * Interface EntityTranslationProviderInterface\n */\ninterface EntityTranslationProviderInterface\n{\n    /**\n     * Get translation\n     *\n     * @param string $entityType  Type of entity\n     * @param string $entityId    Id of entity\n     * @param string $entityField Field of entity\n     * @param string $locale      Locale\n     *\n     * @return string Value fetched\n     */\n    public function getTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $locale\n    );\n\n    /**\n     * Set translation\n     *\n     * @param string $entityType       Type of entity\n     * @param string $entityId         Id of entity\n     * @param string $entityField      Field of entity\n     * @param string $translationValue Translated value\n     * @param string $locale           Locale\n     *\n     * @return string Value fetched\n     */\n    public function setTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $translationValue,\n        $locale\n    );\n\n    /**\n     * Flush all previously set translations.\n     *\n     * @return $this self Object\n     */\n    public function flushTranslations();\n}  There is the possibility of using specific providers for some specific\ndecorations, for example, the  CachedEntityTranslationProvider  implementation,\nthat decorates the main provider by adding an extra cache layer.", 
            "title": "EntityTranslationProvider"
        }, 
        {
            "location": "/component/entity-translator/#entitytranslatorbuilder", 
            "text": "Translation configuration is not set on the fly. It means that a Translator\nneeds to know what entities and what fields must take in account for\ntranslations.  For that reason we need to build the translator using a TranslatorBuilder.  $entityTranslationProvider;\n$entityTranslatorFactory = new TranslatorFactory();\n$entityTranslator = $this- getMock(\n    'Elcodi\\Component\\EntityTranslator\\Services\\EntityTranslator', \n    [], \n    [], \n    '', \n    false\n);\n\n$configuration = [\n    'Elcodi\\Component\\EntityTranslator\\Tests\\Fixtures\\TranslatableProduct' =  [\n        'alias'  =  'product',\n        'idGetter' =  'getId',\n        'fields' =  [\n            'name' =  [\n                'setter' =  'setName',\n                'getter' =  'getName',\n            ]\n        ]\n    ],\n];\n\n$entityTranslatorBuilder = new EntityTranslatorBuilder(\n    $entityTranslationProvider,\n    $translatorFactory,\n    $configuration\n);\n$entityTranslator = $translatorBuilder- compile();  A compiled translator is, somehow, an immutable object. This means that,\ninternally, can change because of new instances, but externally can only be\naccessed by getters.", 
            "title": "EntityTranslatorBuilder"
        }, 
        {
            "location": "/component/entity-translator/#entitytranslator", 
            "text": "The translator itself. This implementation enables you to work with entities\ninstead of translations.  /**\n * Interface EntityTranslatorInterface\n */\ninterface EntityTranslatorInterface\n{\n    /**\n     * Translate object\n     *\n     * @param Object $object Object\n     * @param string $locale Locale to be translated\n     */\n    public function translate($object, $locale);\n\n    /**\n     * Saves object translations\n     *\n     * @param Object $object       Object\n     * @param array  $translations Translations\n     */\n    public function save($object, array $translations);\n}  Using the same configuration than before, lets see an example about how we can\nmanage our entity translations using this service.  $product = new TranslatableProduct();\n$product\n    - setId(1)\n    - setName('productName');\n\n$entityTranslator- save($product, [\n    'es' =  [\n        'name' =  'el nombre',\n        'description' =  'la descripci\u00f3n',\n    ],\n    'en' =  [\n        'name' =  'the name',\n        'description' =  'the description',\n        'anotherfield' =  'some value',\n    ],\n]);\n\n/**\n * At this point, all the data have been persisted to database and cached.\n * As you can see, the `translate` method returns the translated object, but\n * both objects are the same\n */\n\n$translatedProduct = $translator- translate($product, 'en');\n\n$translatedName = $translatedProduct- getName();\necho $translatedName;\n// =  the name \n\n/**\n * So because both object are the same, you can just apply the translation\n * without using the returned object\n */\n\n$translator- translate($product, 'es');\n\n$translatedName = $product- getName();\necho $translatedName;\n// =  el nombre   To when you save all the translations of an entity, the  EntityTranslator  will\nmake a unique flush to the persistence layer, in order to improve this action.", 
            "title": "EntityTranslator"
        }, 
        {
            "location": "/component/entity-translator/#using-doctrine", 
            "text": "Easy and simple. Let's work with a simple entity mapped in Doctrine.  /**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type= string )\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type= text )\n     *\n     * Description\n     */\n    protected $description;\n}  This example will assume that you want to make both fields, name and\ndescription, translatable. To make it happen, we can simply remove  the mapping\nof both fields, to rely the responsibility of translation to the Translator\ncomponent.  /**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n}  Now your installation will see the Product as a simple id. Why is this good for\nus? This example uses Annotations, and we highly recommend to define all your\nmapping configuration using  yml  so you can easily decouple your model\nimplementation (entities) and your mapping configuration (Product.orm.yml) and\ndisable some fields for mapping with the same entity implementation.", 
            "title": "Using Doctrine"
        }, 
        {
            "location": "/component/entity-translator/#configuring-the-entity-translator", 
            "text": "Now, we need to configure the translator. You need to define what entities and\nfields you allow the engine to manage. Let's see the configuration for this\nexample.  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n\n            // idGetter, by default, getId\n            idGetter: getId\n            fields:\n                name:\n                    // getter, by default, getName in this case\n                    // setter, by default, setName in this case\n                    getter: getName\n                    setter: setName\n                description:\n                    getter: getDescription\n                    setter: setDescription  This is the basic definition of the Product translation. You can see that there\nis come specific information set by default, so indeed, this configuration could\nbe defined as well that way  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n            fields:\n                name: ~\n                description: ~  You can use Interfaces as well, so in that case, to ensure that the\nconfiguration will be still valid even if you change the Product implementation,\nyou can use an Interface for that  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Interfaces\\ProductInterface:\n            alias: product\n            fields:\n                name: ~\n                description: ~", 
            "title": "Configuring the entity translator"
        }, 
        {
            "location": "/component/entity-translator/#saving-translations", 
            "text": "Do you want to translate an entity? Great, let's do that! You can easily manage\nyour translation using the entity translator service.  $entityTranslator = $this\n    - container\n    - get('elcodi.entity_translator');  Once you have the service instance, you can set your entity translations in a\nvery simple way. In this example, let's create a new entity, let's save it into\ndatabase and let's translate it.  $product = new Product();\n$product- setId(1);\n\n$entityTranslator- save($product, [\n    'es' =  [\n        'name' =  'el nombre',\n        'description' =  'la descripci\u00f3n',\n    ],\n    'en' =  [\n        'name' =  'the name',\n        'description' =  'the description',\n        'anotherfield' =  'some value',\n    ],\n]);", 
            "title": "Saving translations"
        }, 
        {
            "location": "/component/entity-translator/#translating-an-entity", 
            "text": "So, your entity is translated? Well, let's load the translations of an entity.\nYou only need the entity and the language you want it to be translated to.  $product = $this\n    - get('doctrine.orm.entity_manager')\n    - find(1);\n\n$entityTranslator- translate($product, 'en');  And that's it. Your product is now translated to english, and because both\nfields, name and description, are not mapped anymore, you could flush the entity\nmanager and no information would be saved.", 
            "title": "Translating an entity"
        }, 
        {
            "location": "/component/entity-translator/#translations-in-forms", 
            "text": "This is maybe the most important feature of this Bundle. How can we handle all\nthis stuff in our forms? Very simple. We don't have to change our form\ndefinition but only adapt it to add an EventSubscriber.  Let's see an example.  use Elcodi\\Component\\EntityTranslator\\EventListener\\Traits\\EntityTranslatableFormTrait;\nuse Symfony\\Component\\Form\\AbstractType;\n\n/**\n * Class ProductType\n */\nclass ProductType extends AbstractType\n{\n    use EntityTranslatableFormTrait;\n\n    /**\n     * Buildform function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            - add('name', 'text', [\n                'required' =  true,\n                'label'    =  'name',\n            ])\n            - add('description', 'textarea', [\n                'required' =  false,\n                'label'    =  'description',\n            ]);\n\n        $builder- addEventSubscriber($this- getEntityTranslatorFormEventListener());\n    }\n\n    /**\n     * Return unique name for this form\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return 'form_type_product';\n    }\n}  As you can see, there are only two changes in this formType. First one is that\nyou must add this trait in order to add a protected variable and two methods.\nThe second change is that you must add the EventSubscriber the way is shown in\nthe example.  Because now the formType has some dependencies, you must define this formType as\na service in the dependency injection configuration.  services:\n    form_type.product:\n        class: My\\Namespace\\Form\\Type\\ProductType\n        calls:\n            - [setEntityTranslatorFormEventListener, [@elcodi.entity_translator_form_event_listener]]\n        tags:\n            - { name: form.type, alias: form_type_product }  And that's it. Try to render your form, treating name and description like they\nwere normal fields and what you will see is that, instead of rendering a text\ninput field and a Textarea, three of each will be rendered.", 
            "title": "Translations in forms"
        }, 
        {
            "location": "/component/entity-translator/#custom-form-views", 
            "text": "You can easily customize the way of rendering these fields by adding some format\ninto the rendering of  translatable_field . You can find more information in\nchapter -  What are Form Themes?", 
            "title": "Custom form views"
        }, 
        {
            "location": "/component/entity-translator/#automatic-entity-translation", 
            "text": "You can enable the automatic translation of all loaded entities by enabling the\nrelated configuration flag  auto_translate .  elcodi_entity_translation:\n    auto_translate: true  By default this value is true. If true, every time you load a new entity from\nDoctrine than is defined as translatable (a field is included in the\nconfiguration), that entity will be translated using the current locale.", 
            "title": "Automatic entity translation"
        }, 
        {
            "location": "/component/", 
            "text": "Components\n #\n\n\nEach Component/Bundle will be properly described here. This format will be \napplied in each one, in order to make easier for the reader to follow the \ncontent.\n\n\n\n\nWhat is the package intended for\n\n\nWhat offers\n\n\nDetailed documentation\n\n\nSome links and next steps\n\n\n\n\nComponents documentation\n #\n\n\n\n\nEntity Translator\n\n\nMedia\n\n\nMenu\n\n\nSitemap\n\n\nState Transition Machine\n\n\nMetrics\n\n\nTemplate", 
            "title": "Home"
        }, 
        {
            "location": "/component/#components", 
            "text": "Each Component/Bundle will be properly described here. This format will be \napplied in each one, in order to make easier for the reader to follow the \ncontent.   What is the package intended for  What offers  Detailed documentation  Some links and next steps", 
            "title": "Components"
        }, 
        {
            "location": "/component/#components-documentation", 
            "text": "Entity Translator  Media  Menu  Sitemap  State Transition Machine  Metrics  Template", 
            "title": "Components documentation"
        }, 
        {
            "location": "/component/media/", 
            "text": "Media\n #\n\n\nManage your media entities.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nOf course, what is an E-commerce without images management. We are not focused \non that, but we have created a tiny and simple image manager, that will provide\nyou an easy way of image upload and resize.\n\n\nWhat offers\n #\n\n\nThis component mainly contains routes as public resources. You will be able as\nwell to modify the way images are resized by using adapters, and a set of events\nfor image manipulation.\n\n\nYou will find as well the minimum implementation of Image and File entity needed\nto make it work.\n\n\nUpload an image: Route\n #\n\n\nFirst step for managing images is the uploading process. At the end, it is only\na controller proposed by the framework with an specific route defined.\n\n\nIf we take a look at Bamboo we will discover that we really have this route \ndefined in file \nrouting_admin.yml\n.\n\n\nadmin_media:\n    resource: \n@AdminMediaBundle/Resources/config/routing.yml\n\n\n\n\n\nof course, this piece of code is just an inclusion of an external \nyaml\n file,\nprovided by the bundle \nMediaBundle\n. Such file contains this code.\n\n\n#\n# Routing\n#\n\nelcodi.route.image_upload:\n    path: /images/upload\n    methods: POST\n    defaults:\n        _controller: elcodi.controller.image_upload:uploadAction\n\nelcodi.route.image_resize:\n    path: /images/{id}/resize/{height}/{width}/{type}.{_format}\n    methods: GET\n    defaults:\n        _controller: elcodi.controller.image_resize:resizeAction\n\nelcodi.route.image_view:\n    path: /images/{id}/render.{_format}\n    methods: GET\n    defaults:\n        _controller: elcodi.controller.image_resize:resizeAction\n        height: 0\n        width: 0\n        type: 0\n\n\n\n\n\nLet's focus only in the first route. Take in account that this route is defined\nonly as \nPOST\n.\n\n\nBy default, this controller will check a field called \nfile\n, but you can change\nthis value by overwriting the bundle configuration value\n\n\nelcodi_media:\n    images:\n        upload:\n            field_name: file\n\n\n\n\nThis value will be available in your container as a parameter with name\n\nelcodi.image_upload_field_name\n.\n\n\nUpload an image: Response\n #\n\n\nOnce you have uploaded your image, you will receive a response depending on the\naction result.\n\n\nIf the upload process has been success, you will receive this response\n\n\n{  \n   \nstatus\n:\nok\n,\n   \nresponse\n:{  \n      \nid\n:19,\n      \nextension\n:\njpg\n,\n      \nroutes\n:{  \n         \nview\n:\n\\/images\\/{id}\\/render.{_format}\n,\n         \nresize\n:\n\\/images\\/{id}\\/resize\\/{height}\\/{width}\\/{type}.{_format}\n,\n         \ndelete\n:\n\\/admin\\/media\\/image\\/{id}\\/delete\n\n      }\n   }\n}\n\n\n\n\nOtherwise, you will have a fail response\n\n\n{  \n   \nstatus\n:\nko\n,\n   \nresponse\n:{  \n      \nid\n:19,\n      \nextension\n:\njpg\n,\n      \nroutes\n:{  \n         \nview\n:\n\\/images\\/{id}\\/render.{_format}\n,\n         \nresize\n:\n\\/images\\/{id}\\/resize\\/{height}\\/{width}\\/{type}.{_format}\n,\n         \ndelete\n:\n\\/admin\\/media\\/image\\/{id}\\/delete\n\n      }\n   }\n}\n\n\n\n\nView an image\n #\n\n\nOnce your image, you can access to it using an already built in route.\n\n\nResize an image\n #", 
            "title": "Media"
        }, 
        {
            "location": "/component/media/#media", 
            "text": "Manage your media entities.   Component Repository  Bundle Repository   Of course, what is an E-commerce without images management. We are not focused \non that, but we have created a tiny and simple image manager, that will provide\nyou an easy way of image upload and resize.", 
            "title": "Media"
        }, 
        {
            "location": "/component/media/#what-offers", 
            "text": "This component mainly contains routes as public resources. You will be able as\nwell to modify the way images are resized by using adapters, and a set of events\nfor image manipulation.  You will find as well the minimum implementation of Image and File entity needed\nto make it work.", 
            "title": "What offers"
        }, 
        {
            "location": "/component/media/#upload-an-image-route", 
            "text": "First step for managing images is the uploading process. At the end, it is only\na controller proposed by the framework with an specific route defined.  If we take a look at Bamboo we will discover that we really have this route \ndefined in file  routing_admin.yml .  admin_media:\n    resource:  @AdminMediaBundle/Resources/config/routing.yml   of course, this piece of code is just an inclusion of an external  yaml  file,\nprovided by the bundle  MediaBundle . Such file contains this code.  #\n# Routing\n#\n\nelcodi.route.image_upload:\n    path: /images/upload\n    methods: POST\n    defaults:\n        _controller: elcodi.controller.image_upload:uploadAction\n\nelcodi.route.image_resize:\n    path: /images/{id}/resize/{height}/{width}/{type}.{_format}\n    methods: GET\n    defaults:\n        _controller: elcodi.controller.image_resize:resizeAction\n\nelcodi.route.image_view:\n    path: /images/{id}/render.{_format}\n    methods: GET\n    defaults:\n        _controller: elcodi.controller.image_resize:resizeAction\n        height: 0\n        width: 0\n        type: 0  Let's focus only in the first route. Take in account that this route is defined\nonly as  POST .  By default, this controller will check a field called  file , but you can change\nthis value by overwriting the bundle configuration value  elcodi_media:\n    images:\n        upload:\n            field_name: file  This value will be available in your container as a parameter with name elcodi.image_upload_field_name .", 
            "title": "Upload an image: Route"
        }, 
        {
            "location": "/component/media/#upload-an-image-response", 
            "text": "Once you have uploaded your image, you will receive a response depending on the\naction result.  If the upload process has been success, you will receive this response  {  \n    status : ok ,\n    response :{  \n       id :19,\n       extension : jpg ,\n       routes :{  \n          view : \\/images\\/{id}\\/render.{_format} ,\n          resize : \\/images\\/{id}\\/resize\\/{height}\\/{width}\\/{type}.{_format} ,\n          delete : \\/admin\\/media\\/image\\/{id}\\/delete \n      }\n   }\n}  Otherwise, you will have a fail response  {  \n    status : ko ,\n    response :{  \n       id :19,\n       extension : jpg ,\n       routes :{  \n          view : \\/images\\/{id}\\/render.{_format} ,\n          resize : \\/images\\/{id}\\/resize\\/{height}\\/{width}\\/{type}.{_format} ,\n          delete : \\/admin\\/media\\/image\\/{id}\\/delete \n      }\n   }\n}", 
            "title": "Upload an image: Response"
        }, 
        {
            "location": "/component/media/#view-an-image", 
            "text": "Once your image, you can access to it using an already built in route.", 
            "title": "View an image"
        }, 
        {
            "location": "/component/media/#resize-an-image", 
            "text": "", 
            "title": "Resize an image"
        }, 
        {
            "location": "/component/menu/", 
            "text": "Menu\n #\n\n\nCreate, manage and modify menus and nodes in a very simple and intuitive way.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nThe main goal of this component is the decoupling between how a menu must be \ncreated by a project, and the way all leafs are generated, filtered and \nmodified, in order to give this responsibility to the actor who really has to\ndo it.\n\n\nWhat offers\n #\n\n\nThis component offers both the basic model for such structure, basically \ncomposed by two simple entities (Menu and MenuNode), with a very detailed and\nspecific business layer. In this layer you will find all the tools to extend\nand modify built structures.\n\n\nStructure\n #\n\n\nLet's see a simple view of how Menu is modeled\n\n\nMenu\n  |\n  |- Node1\n  |   |\n  |   |- Node2\n  |   |   |\n  |   |   |- Node3\n  |   |\n  |   |- Node4\n  |\n  |- Node5\n\n\n\n\nCreating a new Menu\n #\n\n\nYou can create a new Menu with their MenuNodes just using their factories. Let's\nsee an example of how to build a structure.\n\n\nuse Elcodi\\Component\\Menu\\Factory\\MenuFactory;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n$menuNodeFactory = new NodeFactory();\n$menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n$menuNode = $menuFactory\n    -\ncreate()\n    -\nsetName('Dashboard')\n    -\nsetCode('dashboard')\n    -\nsetUrl('http://myurl.com')\n    -\nsetActiveUrls([\n        'http://myurl.com/admin'\n    ])\n    -\nsetEnabled(true);\n\n$menuFactory = new MenuFactory();\n$menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Menu');\n$menu = $menuFactory\n    -\ncreate()\n    -\nsetName('admin')\n    -\nsetDescription('Admin menu')\n    -\nsetEnabled(true)\n    -\naddSubnode($menuNode);\n\n\n\n\nManaging menus\n #\n\n\nUsing the class \nMenuManager\n you will be able to manage your menus. This \nmanager is not simple, so has the responsibility to manage all menus using local\ncache, Doctrine cache and Database repository.\n\n\nuse Doctrine\\Common\\Cache\\CacheProvider;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nuse Elcodi\\Component\\Core\\Encoder\\Interfaces\\EncoderInterface;\nuse Elcodi\\Component\\Menu\\Repository\\MenuRepository;\n\n$menuRepository = ...; // MenuRepository\n$menuObjectManager = ...; // ObjectManager\n$menuCache = ...; // CacheProvider\n$menuEncoder = ...; //EncoderInterface\n$menuCacheKey = 'menus';\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder);\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nEach menu, once loaded from database, is detached in a cascade mode. It means\nthat you cannot modify a menu using any kind of event and save it into database.\n\n\nLets see how a menu can be changed on the fly.\n\n\n\n\nSince now, when we refer to a Changer element, we are referring to Filters,\nModifiers or Builders\n\n\n\n\nCache\n #\n\n\nOf course this component is built on top of a simple cache layer, so each time \na new menu is loaded from database, there are two different stages: before the \nmenu is cached \nElcodiMenuStages::BEFORE_CACHE\n and after the menu is cached \n\nElcodiMenuStages::AFTER_CACHE\n.\n\n\nThe difference is that when you apply a changer before the result is cached, \nthose changes will be reused until the menu is removed from the cache and \nrebuilt again.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n\n\n\nSo, if one specific filter, a builder or a modifier must be executed in every\nrequest, then must be defined as the after-cache stage.\n\n\nSpecific menus\n #\n\n\nWhen we add a changer element, we can specify a set of menu elements where we\nwant this changes to be applied to. You can as well apply them to all menus, so\nthis parameter should be an empty array.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin', 'store'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n\n\n\nIn that case, we are setting that our filter should only be applied to menus \ncalled \nadmin\n and \nstore\n.\n\n\nPriority\n #\n\n\nOnce we have several changers, then we can prioritize them by using priority\nparameter.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n$menuFilterer\n    -\naddMenuFilter(\n        new AnotherMenuFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        10\n    );\n\n\n\n\nIn that case, and because more priority means earlier execution, filter\n\nAnotherMenuFilter\n will be executed before than filter \nMenuDisabledFilter\n.\n\n\nFiltering menus\n #\n\n\nYou can filter existing menus. It means that, considering any node, one by one,\nyou can decide if this node (and all subnodes) must continue being inside the \nmenu.\n\n\nIf a node is considered as invalid, then all subnodes will, automatically, \ntreated as invalids.\n\n\nLet's see an example of a MenuFilter that removed a node if this one is not \nenabled.\n\n\nuse Elcodi\\Component\\Menu\\Filter\\Interfaces\\MenuFilterInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\n\n/**\n * Class MenuDisabledFilter\n */\nclass MenuDisabledFilter implements MenuFilterInterface\n{\n    /**\n     * Filter a node once this has to be rendered\n     *\n     * @param NodeInterface $menuNode Menu node\n     *\n     * @return boolean Node must be rendered\n     */\n    public function filter(NodeInterface $menuNode)\n    {\n        return $menuNode-\nisEnabled();\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time. In this example we will add a filter that will check \nwhen a menu is disabled in database. Then this menu node should be removed from\nthe tree.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuFilterer)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nIf we check the menu tree, then we could draw something like that\n\n\nMenu\n  |\n  |- Node1 \nenabled\n\n  |   |\n  |   |- Node2 \ndisabled\n\n  |   |   |\n  |   |   |- Node3 \nenabled\n\n  |   |\n  |   |- Node4 \nenabled\n\n  |\n  |- Node5 \ndisabled\n\n\n\n\n\nSo after applying this filters, we will have this menu\n\n\nMenu\n  |\n  |- Node1 \nenabled\n\n      |\n      |- Node4 \nenabled\n\n\n\n\n\nBuilding menus\n #\n\n\nOnce the menu is requested from the repository and detached from the object\nmanager, you can add more nodes in order to configure it.\n\n\nLet's see an example that adds a new Node inside the Node dashboard. For this,\nboth entities Menu and Node have a method called \nfindNodeByKey\n that returns,\nif exists, the Node with given code, looking for inside all subnodes, \nrecursively.\n\n\nuse Elcodi\\Component\\Menu\\Builder\\Interfaces\\MenuBuilderInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n/**\n * Class MenuBuilderUser\n */\nclass MenuBuilderUser implements MenuBuilderInterface\n{\n    /**\n     * Build the menu\n     *\n     * @param MenuInterface $menu Menu\n     */\n    public function build(MenuInterface $menuNode)\n    {\n        $menuNodeFactory = new NodeFactory();\n        $menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n        $userNode = $menuNodeFactory\n            -\ncreate()\n            -\nsetName('User')\n            -\nsetCode('user')\n            -\nsetUrl('http://myurl.com/admin/user')\n            -\nsetEnabled(true);\n\n        $dashboardNode = $menu-\nfindSubnodeByName('Dashboard');\n\n        if ($dashboardNode instanceof NodeInterface) {\n            $dashboardNode-\naddSubnode($userNode);\n        }\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuBuilder;\n\n$menuBuilder = new MenuBuilder();\n$menuBuilder\n    -\naddMenuBuilder(\n        new MenuBuilderUser(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuBuilder)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nModifying menus\n #\n\n\nMaybe you want to modify a single menu. For this you can use the Menu Modifiers,\na type of changer that is intended, only, for single Menu Node modifications.\n\n\nLet's see an example that sets \nactive\n as true if, given a Request object, \ncurrent route matches any of specified as active routes.\n\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Modifier\\Interfaces\\MenuModifierInterface;\n\n/**\n * Class MenuActiveModifier\n */\nclass MenuActiveModifier implements MenuModifierInterface\n{\n    /**\n     * Modifier the menu node\n     *\n     * @param NodeInterface $menuNode Menu node\n     */\n    public function modify(NodeInterface $menuNode)\n    {\n        $request = ...; // Request\n\n        $currentRoute = $request-\nget('_route');\n\n        if (in_array($currentRoute, $menuNode-\ngetActiveUrls())) {\n            $menuNode-\nsetActive(true);\n        }\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuModifier;\n\n$menuModifier = new MenuModifier();\n$menuModifier\n    -\naddMenuModifier(\n        new MenuActiveModifier(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuModifier)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nUsing the DIC\n #\n\n\nExposing your Menu changers (Filters, Builders and Modifiers) is so simple using\nthe Symfony Dependency Injection definitions. For this purpose, this bundle is\nbuilt on top the tags feature, allowing to define a simple changer just adding\na simple tag.\n\n\nBy default, this Bundle has three changers defined and enabled.\n\n\nservices:\n\n    #\n    # Menu filters\n    #\n    elcodi.menu_filter.menu_disabled:\n        class: Elcodi\\Component\\Menu\\Filter\\MenuDisabledFilter\n        tags:\n            - { name: menu.filter }\n\n    #\n    # Menu modifiers\n    #\n    elcodi.menu_modifier.menu_active:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuActiveModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n    elcodi.menu_modifier.menu_expanded:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuExpandedModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n\n\n\nAs you can see, there is no any Builder defined here. Let's see an example of a\nBuilder definition.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.plugins:\n        class: Elcodi\\Admin\\PluginBundle\\MenuBuilder\\PluginMenuBuilder\n        arguments:\n            - @elcodi.factory.menu_node\n            - @router\n            - @elcodi.enabled_plugins\n        tags:\n            - { name: menu.builder }\n\n\n\n\nYou can define as much elements you need.\n\n\nWorkflow\n #\n\n\nThe order matters. It means that is not the same to apply all the filters first\nof all and then execute the modifiers, or applying the other way.\n\n\nThis bundle define all changers in this order\n\n\n\n\nBuilders\n\n\nFilters\n\n\nModifiers\n\n\n\n\nCache\n #\n\n\nEach changer can be used before or after cache by setting its stage. Please, \nread the \ncomponent documentation\n to \nunderstand what means this configuration and what is indended for.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, stage: before_cache }\n            - { name: menu.builder, stage: after_cache }\n\n\n\n\nBy default, \nbefore_cache\n will be used.\n\n\nSpecific menus\n #\n\n\nEach changer can be assigned to a set of menus by using the menus property in \nthe tag definition.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, menus: ['admin', 'store'] }\n\n\n\n\nBy default, all menus will be assigned.\n\n\nPriority\n #\n\n\nEach group will prioritize all its instances by using priority. You can set a \npriority using the tag.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, priority: 10 }\n\n\n\n\nBy default, priority 0 will be used.\n\n\n\n\nThe more priority, the before this changer is applied. Negative values are\nkindly allowed here.", 
            "title": "Menu"
        }, 
        {
            "location": "/component/menu/#menu", 
            "text": "Create, manage and modify menus and nodes in a very simple and intuitive way.   Component Repository  Bundle Repository   The main goal of this component is the decoupling between how a menu must be \ncreated by a project, and the way all leafs are generated, filtered and \nmodified, in order to give this responsibility to the actor who really has to\ndo it.", 
            "title": "Menu"
        }, 
        {
            "location": "/component/menu/#what-offers", 
            "text": "This component offers both the basic model for such structure, basically \ncomposed by two simple entities (Menu and MenuNode), with a very detailed and\nspecific business layer. In this layer you will find all the tools to extend\nand modify built structures.", 
            "title": "What offers"
        }, 
        {
            "location": "/component/menu/#structure", 
            "text": "Let's see a simple view of how Menu is modeled  Menu\n  |\n  |- Node1\n  |   |\n  |   |- Node2\n  |   |   |\n  |   |   |- Node3\n  |   |\n  |   |- Node4\n  |\n  |- Node5", 
            "title": "Structure"
        }, 
        {
            "location": "/component/menu/#creating-a-new-menu", 
            "text": "You can create a new Menu with their MenuNodes just using their factories. Let's\nsee an example of how to build a structure.  use Elcodi\\Component\\Menu\\Factory\\MenuFactory;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n$menuNodeFactory = new NodeFactory();\n$menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n$menuNode = $menuFactory\n    - create()\n    - setName('Dashboard')\n    - setCode('dashboard')\n    - setUrl('http://myurl.com')\n    - setActiveUrls([\n        'http://myurl.com/admin'\n    ])\n    - setEnabled(true);\n\n$menuFactory = new MenuFactory();\n$menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Menu');\n$menu = $menuFactory\n    - create()\n    - setName('admin')\n    - setDescription('Admin menu')\n    - setEnabled(true)\n    - addSubnode($menuNode);", 
            "title": "Creating a new Menu"
        }, 
        {
            "location": "/component/menu/#managing-menus", 
            "text": "Using the class  MenuManager  you will be able to manage your menus. This \nmanager is not simple, so has the responsibility to manage all menus using local\ncache, Doctrine cache and Database repository.  use Doctrine\\Common\\Cache\\CacheProvider;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nuse Elcodi\\Component\\Core\\Encoder\\Interfaces\\EncoderInterface;\nuse Elcodi\\Component\\Menu\\Repository\\MenuRepository;\n\n$menuRepository = ...; // MenuRepository\n$menuObjectManager = ...; // ObjectManager\n$menuCache = ...; // CacheProvider\n$menuEncoder = ...; //EncoderInterface\n$menuCacheKey = 'menus';\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder);\n\n$adminMenu = $menuManager- loadMenuByCode('admin');  Each menu, once loaded from database, is detached in a cascade mode. It means\nthat you cannot modify a menu using any kind of event and save it into database.  Lets see how a menu can be changed on the fly.   Since now, when we refer to a Changer element, we are referring to Filters,\nModifiers or Builders", 
            "title": "Managing menus"
        }, 
        {
            "location": "/component/menu/#cache", 
            "text": "Of course this component is built on top of a simple cache layer, so each time \na new menu is loaded from database, there are two different stages: before the \nmenu is cached  ElcodiMenuStages::BEFORE_CACHE  and after the menu is cached  ElcodiMenuStages::AFTER_CACHE .  The difference is that when you apply a changer before the result is cached, \nthose changes will be reused until the menu is removed from the cache and \nrebuilt again.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );  So, if one specific filter, a builder or a modifier must be executed in every\nrequest, then must be defined as the after-cache stage.", 
            "title": "Cache"
        }, 
        {
            "location": "/component/menu/#specific-menus", 
            "text": "When we add a changer element, we can specify a set of menu elements where we\nwant this changes to be applied to. You can as well apply them to all menus, so\nthis parameter should be an empty array.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin', 'store'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );  In that case, we are setting that our filter should only be applied to menus \ncalled  admin  and  store .", 
            "title": "Specific menus"
        }, 
        {
            "location": "/component/menu/#priority", 
            "text": "Once we have several changers, then we can prioritize them by using priority\nparameter.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n$menuFilterer\n    - addMenuFilter(\n        new AnotherMenuFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        10\n    );  In that case, and because more priority means earlier execution, filter AnotherMenuFilter  will be executed before than filter  MenuDisabledFilter .", 
            "title": "Priority"
        }, 
        {
            "location": "/component/menu/#filtering-menus", 
            "text": "You can filter existing menus. It means that, considering any node, one by one,\nyou can decide if this node (and all subnodes) must continue being inside the \nmenu.  If a node is considered as invalid, then all subnodes will, automatically, \ntreated as invalids.  Let's see an example of a MenuFilter that removed a node if this one is not \nenabled.  use Elcodi\\Component\\Menu\\Filter\\Interfaces\\MenuFilterInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\n\n/**\n * Class MenuDisabledFilter\n */\nclass MenuDisabledFilter implements MenuFilterInterface\n{\n    /**\n     * Filter a node once this has to be rendered\n     *\n     * @param NodeInterface $menuNode Menu node\n     *\n     * @return boolean Node must be rendered\n     */\n    public function filter(NodeInterface $menuNode)\n    {\n        return $menuNode- isEnabled();\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time. In this example we will add a filter that will check \nwhen a menu is disabled in database. Then this menu node should be removed from\nthe tree.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuFilterer)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');  If we check the menu tree, then we could draw something like that  Menu\n  |\n  |- Node1  enabled \n  |   |\n  |   |- Node2  disabled \n  |   |   |\n  |   |   |- Node3  enabled \n  |   |\n  |   |- Node4  enabled \n  |\n  |- Node5  disabled   So after applying this filters, we will have this menu  Menu\n  |\n  |- Node1  enabled \n      |\n      |- Node4  enabled", 
            "title": "Filtering menus"
        }, 
        {
            "location": "/component/menu/#building-menus", 
            "text": "Once the menu is requested from the repository and detached from the object\nmanager, you can add more nodes in order to configure it.  Let's see an example that adds a new Node inside the Node dashboard. For this,\nboth entities Menu and Node have a method called  findNodeByKey  that returns,\nif exists, the Node with given code, looking for inside all subnodes, \nrecursively.  use Elcodi\\Component\\Menu\\Builder\\Interfaces\\MenuBuilderInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n/**\n * Class MenuBuilderUser\n */\nclass MenuBuilderUser implements MenuBuilderInterface\n{\n    /**\n     * Build the menu\n     *\n     * @param MenuInterface $menu Menu\n     */\n    public function build(MenuInterface $menuNode)\n    {\n        $menuNodeFactory = new NodeFactory();\n        $menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n        $userNode = $menuNodeFactory\n            - create()\n            - setName('User')\n            - setCode('user')\n            - setUrl('http://myurl.com/admin/user')\n            - setEnabled(true);\n\n        $dashboardNode = $menu- findSubnodeByName('Dashboard');\n\n        if ($dashboardNode instanceof NodeInterface) {\n            $dashboardNode- addSubnode($userNode);\n        }\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time.  use Elcodi\\Component\\Menu\\Services\\MenuBuilder;\n\n$menuBuilder = new MenuBuilder();\n$menuBuilder\n    - addMenuBuilder(\n        new MenuBuilderUser(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuBuilder)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');", 
            "title": "Building menus"
        }, 
        {
            "location": "/component/menu/#modifying-menus", 
            "text": "Maybe you want to modify a single menu. For this you can use the Menu Modifiers,\na type of changer that is intended, only, for single Menu Node modifications.  Let's see an example that sets  active  as true if, given a Request object, \ncurrent route matches any of specified as active routes.  use Symfony\\Component\\HttpFoundation\\Request;\n\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Modifier\\Interfaces\\MenuModifierInterface;\n\n/**\n * Class MenuActiveModifier\n */\nclass MenuActiveModifier implements MenuModifierInterface\n{\n    /**\n     * Modifier the menu node\n     *\n     * @param NodeInterface $menuNode Menu node\n     */\n    public function modify(NodeInterface $menuNode)\n    {\n        $request = ...; // Request\n\n        $currentRoute = $request- get('_route');\n\n        if (in_array($currentRoute, $menuNode- getActiveUrls())) {\n            $menuNode- setActive(true);\n        }\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time.  use Elcodi\\Component\\Menu\\Services\\MenuModifier;\n\n$menuModifier = new MenuModifier();\n$menuModifier\n    - addMenuModifier(\n        new MenuActiveModifier(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuModifier)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');", 
            "title": "Modifying menus"
        }, 
        {
            "location": "/component/menu/#using-the-dic", 
            "text": "Exposing your Menu changers (Filters, Builders and Modifiers) is so simple using\nthe Symfony Dependency Injection definitions. For this purpose, this bundle is\nbuilt on top the tags feature, allowing to define a simple changer just adding\na simple tag.  By default, this Bundle has three changers defined and enabled.  services:\n\n    #\n    # Menu filters\n    #\n    elcodi.menu_filter.menu_disabled:\n        class: Elcodi\\Component\\Menu\\Filter\\MenuDisabledFilter\n        tags:\n            - { name: menu.filter }\n\n    #\n    # Menu modifiers\n    #\n    elcodi.menu_modifier.menu_active:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuActiveModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n    elcodi.menu_modifier.menu_expanded:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuExpandedModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }  As you can see, there is no any Builder defined here. Let's see an example of a\nBuilder definition.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.plugins:\n        class: Elcodi\\Admin\\PluginBundle\\MenuBuilder\\PluginMenuBuilder\n        arguments:\n            - @elcodi.factory.menu_node\n            - @router\n            - @elcodi.enabled_plugins\n        tags:\n            - { name: menu.builder }  You can define as much elements you need.", 
            "title": "Using the DIC"
        }, 
        {
            "location": "/component/menu/#workflow", 
            "text": "The order matters. It means that is not the same to apply all the filters first\nof all and then execute the modifiers, or applying the other way.  This bundle define all changers in this order   Builders  Filters  Modifiers", 
            "title": "Workflow"
        }, 
        {
            "location": "/component/menu/#cache_1", 
            "text": "Each changer can be used before or after cache by setting its stage. Please, \nread the  component documentation  to \nunderstand what means this configuration and what is indended for.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, stage: before_cache }\n            - { name: menu.builder, stage: after_cache }  By default,  before_cache  will be used.", 
            "title": "Cache"
        }, 
        {
            "location": "/component/menu/#specific-menus_1", 
            "text": "Each changer can be assigned to a set of menus by using the menus property in \nthe tag definition.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, menus: ['admin', 'store'] }  By default, all menus will be assigned.", 
            "title": "Specific menus"
        }, 
        {
            "location": "/component/menu/#priority_1", 
            "text": "Each group will prioritize all its instances by using priority. You can set a \npriority using the tag.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, priority: 10 }  By default, priority 0 will be used.   The more priority, the before this changer is applied. Negative values are\nkindly allowed here.", 
            "title": "Priority"
        }, 
        {
            "location": "/component/metrics/", 
            "text": "Metrics\n #\n\n\nAdd a simple asynchronous metrics layer into your Symfony project.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nRequirements\n #\n\n\nMetrics main adapter requires Redis to be installed. It uses some complex data \nstructures to all metrics cache and read, and Redis offers by default this \nstructures with a very fast reading time penalty.\n\n\nIt is required to install Redis in version, at least, \nv2.8.9\n. This version\nintroduced used methods like \nHyperLogLog\n.\n\n\nIf any other bucket adapter is installed and used, then you may not require\nRedis but other libraries (each adapter should document it).\n\n\nWhat offers\n #\n\n\nThis package provides a simple but powerful metrics layer, ready to be used in\nyour Symfony project, and inspired by how Google Analytics uses your client\nresources.\n\n\nThe package is divided in three main blocks\n\n The core, where all the service layer is placed\n\n The input, where all the data is inserted in the system\n* The API, where all the data is required and read from\n\n\nWhen we talk about metrics, we are talking about some indicators of how our site\nis working. In order to provide the final user with some useful data, this \ncomponent allows you to store metrics in a very different way. Let's see all\nthese ways using examples.\n\n\nUnique beacon\n #\n\n\nFor example, unique users. This type of metric allow you to get unique elements\ngiven an identifiable per each actor. Each entry represents only one increment.\n\n\n/**\n * Metric type beacon unique.\n *\n * This type will be treated as a simple beacon in the metric ecosystem.\n * Useful for getting nb of elements\n *\n * * To get unique values over the time\n */\nconst TYPE_BEACON_UNIQUE = 1;\n\n\n\n\nThe usage is quite simple. If you need to add this beacon in your PHP classes,\nthen use the \nMetricManager\n instance, injectable in your classes by using the\nservice called \nelcodi.manager.metric\n.\n\n\nIn this example, we want to add a new metric called \nhomepage_controller\n,\nwe want to track how many unique users visit this controller (imagine that this\ncontroller is behind a firewall that require all users to have credentials), and\nthat the store itself has its own tracker, no matter what's the value.\n\n\nuse Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    -\nmetricManager\n    -\naddEntry(\n        $storeTracker,\n        'homepage_controller',\n        $user-\ngetId(),\n        ElcodiMetricTypes::TYPE_BEACON_UNIQUE,\n        new DateTime()\n    );\n\n\n\n\nAs you can see, in that case we are not tracking how many users render the final\ntwig, but how many users use the controller.\n\n\nIf our desire is tracking the page view, then you should use the Javascript\nlibrary, designed and created for that purpose. Read the\nInitializing metrics section\n\n\n_etc.push([\n123456789\n, 'homepage', {{user.id}}, '1']);\n\n\n\n\nIn Bamboo, the identifier of the store is available by using the Twig global \nvariable \nstore_tracker\n.\n\n\n_etc.push([\n{{ store_tracker }}\n, 'homepage', {{user.id}}, '1']);\n\n\n\n\nTotal beacon\n #\n\n\nSame as unique beacons, but each beacon represents a new entry, no matter what\nthe user where this beacon comes from, each one means a new entry. Useful for\ntotal page requests. Each entry represents only one increment.\n\n\nIn this example, we want to do the same as before but no matter what user the\nvisit comes from.\n\n\nuse Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    -\nmetricManager\n    -\naddEntry(\n        $storeTracker,\n        'homepage_controller',\n        '',\n        ElcodiMetricTypes::TYPE_BEACON_TOTAL,\n        new DateTime()\n    );\n\n\n\n\nIf you want the same behavior but in your twig layer\n\n\n_etc.push([\n123456789\n, 'homepage', '', '2']);\n\n\n\n\nMixed (Unique and Total) beacon\n #\n\n\nSometimes you want to add both, unique and total beacons. Well, instead of\ncreating two different beacons, you can create  only one representing both.\nBecause this means that the user must be identified somehow for the unique\nentry, remember to add the unique value as well.\n\n\nuse Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    -\nmetricManager\n    -\naddEntry(\n        $storeTracker,\n        'homepage_controller',\n        $user-\ngetId(),\n        ElcodiMetricTypes::TYPE_BEACON_ALL,\n        new DateTime()\n    );\n\n\n\n\nAnd for the twig layer\n\n\n_etc.push([\n123456789\n, 'homepage', {{user.id}}, '3']);\n\n\n\n\nAccumulated beacon\n #\n\n\nThis type allow you to create an incremental accumulator, for example for\nrepresenting the total value of your total earnings. In that case, we need the\namount of the order as integer.\n\n\nuse Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$orderAmount = ...;\n$storeTracker = ...;\n$this\n    -\nmetricManager\n    -\naddEntry(\n        $storeTracker,\n        'order_earnings',\n        $orderAmount,\n        ElcodiMetricTypes::TYPE_ACCUMULATED,\n        new DateTime()\n    );\n\n\n\n\nThis type of metric is special for the PHP layer, so all entries must define a\nvalue. Anyway, you can use it as well in your twig layer.\n\n\n_etc.push([\n123456789\n, 'metric', 10, '4']);\n\n\n\n\nDistributive beacon\n #\n\n\nGiven an undetermined set of values, for examples, the referrer of the visit,\ncreate a metric\n\n\nGiven a set of supplementary values, for example operating systems (you cannot\nuse two of them at the same time), this type of beacon allow you to build\ndistributive metrics using a set of possible values. Each entry represents only\none increment.\n\n\nIn our example we will check if the user visiting a controller is logged or not.\n\n\nuse Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$isLogged = ...;\n$storeTracker = ...;\n$metricName = $isLogged\n    ? 'framework_is_logged'\n    : 'framework_is_not_logged';\n\n$this\n    -\nmetricManager\n    -\naddEntry(\n        $storeTracker,\n        $metricName,\n        '0',\n        ElcodiMetricTypes::TYPE_DISTRIBUTIVE,\n        new DateTime()\n    );\n\n\n\n\nAnother example, and using it in the twig layer, is the representation if all\nreferrers of your site. You must use this type of metric because you cannot\ndefine a set of possible values (that should be a list of all websites in the\nworld... insane!)\n\n\n\n\nThis type of metric can be misunderstood. Only use it for non-closed set of\nelements. Otherwise, for example for knowing if your users are visiting your\nsite using a mobile platform or a desktop platform, use the first metric type.\n\n\n\n\nSo let's see the example of the referrers. We will use the twig method\n\nreferrer_domain()\n for such information. Visit\n\nUse Referrer Domain\n cookbook for more\ninformation.\n\n\n_etc.push([\n123456789\n, 'referrer', {{ referrer_domain() }}, '8'])\n\n\n\n\nMetrics routes\n #\n\n\nOnce we know all different type of metrics, we should know as well how to\ninitialize all the environment. One of this things we must ensure that are\nactive is the route that we will use for our asynchronous calls.\n\n\nelcodi_metric:\n    resource: \n@ElcodiMetricBundle/Resources/config/routing.yml\n\n\n\n\n\nAs you can see, MetricBundle provides you the file with these routes. You only\nneed to include it in your router.\n\n\nAs soon as is included, you should see the route enabled in your project by\nusing the command \nphp app/console router:debug\n\n\n# elcodi.route.metric_input\nRewriteCond %{REQUEST_URI} ^/api/_m/([^/]++)/([^/\\.]++)\\.png$\nRewriteCond %{REQUEST_METHOD} !^(GET|HEAD)$ [NC]\nRewriteRule .* - [S=1,E=_ROUTING_allow_GET:1,E=_ROUTING_allow_HEAD:1]\nRewriteCond %{REQUEST_URI} ^/api/_m/([^/]++)/([^/\\.]++)\\.png$\n\n\n\n\nAs you can see, this route starts with the prefix \n/api\n. This is because in\nBamboo this route is considered an Api route, and is prefixed with \n/api\n.\n\n\nJS initialization\n #\n\n\nYou must initialize the JS layer as well. For this chapter, please be sure that\nyour assets are properly installed and dumped.\n\n\nphp app/console assets:install\nphp app/console assetic:dump\n\n\n\n\nFirst of all you must initialize the JS metric library. Put this piece of code\nin your layout header. That simple!\n\n\nscript\n\n\n    /**\n     * Tracker generator for elcodi bamboo store\n     */\n    var _etc = _etc || [];\n\n    (function() {\n        var _etracker = document.createElement('script');\n        _etracker.type = 'text/javascript';\n        _etracker.async = true;\n        _etracker.src = '/bundles/elcodimetric/js/tracker.js';\n        var _etracker_s = document.getElementsByTagName('script')[0];\n        _etracker_s.parentNode.insertBefore(_etracker, _etracker_s);\n    }());\n\n/script\n\n\n\n\n\nIn simple words, what this piece of code does is create a new block of JS code\nat the end of your code, adding all the metric library asynchronously. This\nmeans none blocking at all.\n\n\nTake a look at the first line of the code.\n\n\nvar _etc = _etc || [];\n\n\n\n\nWith this line you will be able to work with metrics even if the library is not\ninitialized yet. Let's see how!\n\n\nAdding beacons\n #\n\n\nRemember all beacons definitions? Well, if you have an idea about what your\nfirst metric could be, let's create it.\n\n\nFor this example, we will use the referrer metric again. Let's remember how we\ncan use it.\n\n\n_etc.push([\n123456789\n, 'referrer', {{ referrer_domain() }}, '8'])\n\n\n\n\nThe object \n_etc\n is an array while the metric JS library is not installed.\nArrays in JS have a public method called \npush()\n that basically what it does\nis pushing the element. That simple. This call does nothing, just pushing.\n\n\nAs long as the metrics library is installed, one of the processes this JS code\ndoes is, just at the beginning of its execution, take this array, save the\nobjects inside, and create a new object in the same variable, with the same name\nand the same public method: \npush()\n.\n\n\nAfter that, introduces again the previously saved objects and, unlike the simple\nJS array, this object does something else when this method is called: the AJAX\ncall to the metrics API.\n\n\nAnd everything in a very very soft way and without any page slowness for your\nuser.\n\n\nConsulting values\n #\n\n\nOkay, now our website tracks some values for your analysis. But how can we read\nall this data from our backend? Well, the component itself uses a set of\nservices with a very simple way of doing that job.\n\n\nnamespace Elcodi\\Component\\Metric\\Core\\Bucket\\Abstracts;\n\n/**\n * Class AbstractMetricsBucket\n */\nabstract class AbstractMetricsBucket\n{\n    /**\n     * Get number of unique beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of hits\n     */\n    public function getBeaconsUnique($token, $event, array $dates);\n\n    /**\n     * Get the total of beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of beacons, given an event and dates\n     */\n    public function getBeaconsTotal($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Accumulation of event and given dates\n     */\n    public function getAccumulation($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * [\n     *      \nvalue3\n: 24,\n     *      \nvalue7\n: 13,\n     *      \nvalue8\n: 9,\n     * ]\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return array Distribution with totals\n     */\n    public function getDistributions($token, $event, array $dates);\n}\n\n\n\n\nYou can inject this service by using the dependency injection name\n\n\nservices:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi.metrics_bucket\n\n\n\n\nYou can create new adapters as well. Please read the\n\nMetric Adapters Cookbook\n\n\nTwig extension\n #\n\n\nYou can read this information as well in your twig layer. In that case, you\nshould have stored in a twig local variable the array of Datetime instances. In\nthat case, let's figure that we have this array in a variable called \ndates\n.\n\n\n{{ metric_beacon_unique(123456789, 'unique_visits', dates) }}\n{{ metric_beacon_total(123456789, 'total_visits', dates) }}\n{{ metric_accumulation(123456789, 'order_total', dates) }}\n{{ metric_distributive(123456789, 'referrers', dates) }}\n\n\n\n\nAll methods are a simple call to service methods, without any kind of\ntransformation.\n\n\nMetrics Intervals Resolver\n #\n\n\nThe last parameter of all these methods is an array of dates, and because can be\na heavy task creating intervals of dates, Bamboo provides as well a simple\nmechanism for building these structures easily.\n\n\n\n\nThis service is just a helper for Bamboo installation, providing some extra\nconfiguration and definition for custom charts. If you want to use it for your\nown project, please, check the specification of the classes involved.\n\n\n\n\nThere is a class called \nMetricIntervalsResolver\n with a simple method. \n\n\nnamespace Elcodi\\Admin\\MetricBundle\\Services;\n\n/**\n * Class MetricIntervalsResolver\n */\nclass MetricIntervalsResolver\n{\n    /**\n     * Given a type, create and configure the interval container\n     *\n     * @param integer $type Type of calculation\n     *\n     * @return IntervalContainer\n     */\n    public function getIntervalContainer($type);\n}\n\n\n\n\nWhat this class does for you is create an instance of \nIntervalContainer\n built\nwith an array of DateTime instances, given given \n$type\n. This type will tell\nthe method what kind of interval you want to build. These are all pre-built\ntypes.\n\n\nnamespace Elcodi\\Admin\\MetricBundle;\n\n/**\n * Class AdminPanelTypes\n */\nclass AdminPanelTypes\n{\n    /**\n     * @param integer\n     *\n     * Panel type today\n     */\n    const PANEL_TYPE_TODAY = 1;\n\n    /**\n     * @param integer\n     *\n     * Panel type yesterday\n     */\n    const PANEL_TYPE_YESTERDAY = 2;\n\n    /**\n     * @param integer\n     *\n     * Panel type last week\n     */\n    const PANEL_TYPE_LAST_WEEK = 3;\n\n    /**\n     * @param integer\n     *\n     * Panel type last month\n     */\n    const PANEL_TYPE_LAST_MONTH = 4;\n\n    /**\n     * @param integer\n     *\n     * Panel type last quarter\n     */\n    const PANEL_TYPE_LAST_QUARTER = 5;\n}\n\n\n\n\nAs said before, this method returns a \nIntervalContainer\n instance. This object\nreturns some data related to the chart itself.\n\n\nThe most important and used method of this object is \ngetElements()\n, used if\nthe value of \ndates\n is an instance of that. Then, the call of any metric read\nturns like that\n\n\n{{ metric_beacon_unique(123456789, 'unique_visits', dates.getElements()) }}\n\n\n\n\nYou can inject this resolver as well using the dependency injection name.\n\n\nservices:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi_admin.metric_intervals_resolver\n\n\n\n\nAnd finally, you can access to this method in your Twig layer as well\n\n\n{% set todayIntervalContainer = metric_create_interval_container(1) %}\n{{ metric_beacon_unique(123456789, 'unique_visits', todayIntervalContainer.getElements()) }}", 
            "title": "Metrics"
        }, 
        {
            "location": "/component/metrics/#metrics", 
            "text": "Add a simple asynchronous metrics layer into your Symfony project.   Component Repository  Bundle Repository", 
            "title": "Metrics"
        }, 
        {
            "location": "/component/metrics/#requirements", 
            "text": "Metrics main adapter requires Redis to be installed. It uses some complex data \nstructures to all metrics cache and read, and Redis offers by default this \nstructures with a very fast reading time penalty.  It is required to install Redis in version, at least,  v2.8.9 . This version\nintroduced used methods like  HyperLogLog .  If any other bucket adapter is installed and used, then you may not require\nRedis but other libraries (each adapter should document it).", 
            "title": "Requirements"
        }, 
        {
            "location": "/component/metrics/#what-offers", 
            "text": "This package provides a simple but powerful metrics layer, ready to be used in\nyour Symfony project, and inspired by how Google Analytics uses your client\nresources.  The package is divided in three main blocks  The core, where all the service layer is placed  The input, where all the data is inserted in the system\n* The API, where all the data is required and read from  When we talk about metrics, we are talking about some indicators of how our site\nis working. In order to provide the final user with some useful data, this \ncomponent allows you to store metrics in a very different way. Let's see all\nthese ways using examples.", 
            "title": "What offers"
        }, 
        {
            "location": "/component/metrics/#unique-beacon", 
            "text": "For example, unique users. This type of metric allow you to get unique elements\ngiven an identifiable per each actor. Each entry represents only one increment.  /**\n * Metric type beacon unique.\n *\n * This type will be treated as a simple beacon in the metric ecosystem.\n * Useful for getting nb of elements\n *\n * * To get unique values over the time\n */\nconst TYPE_BEACON_UNIQUE = 1;  The usage is quite simple. If you need to add this beacon in your PHP classes,\nthen use the  MetricManager  instance, injectable in your classes by using the\nservice called  elcodi.manager.metric .  In this example, we want to add a new metric called  homepage_controller ,\nwe want to track how many unique users visit this controller (imagine that this\ncontroller is behind a firewall that require all users to have credentials), and\nthat the store itself has its own tracker, no matter what's the value.  use Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    - metricManager\n    - addEntry(\n        $storeTracker,\n        'homepage_controller',\n        $user- getId(),\n        ElcodiMetricTypes::TYPE_BEACON_UNIQUE,\n        new DateTime()\n    );  As you can see, in that case we are not tracking how many users render the final\ntwig, but how many users use the controller.  If our desire is tracking the page view, then you should use the Javascript\nlibrary, designed and created for that purpose. Read the\nInitializing metrics section  _etc.push([ 123456789 , 'homepage', {{user.id}}, '1']);  In Bamboo, the identifier of the store is available by using the Twig global \nvariable  store_tracker .  _etc.push([ {{ store_tracker }} , 'homepage', {{user.id}}, '1']);", 
            "title": "Unique beacon"
        }, 
        {
            "location": "/component/metrics/#total-beacon", 
            "text": "Same as unique beacons, but each beacon represents a new entry, no matter what\nthe user where this beacon comes from, each one means a new entry. Useful for\ntotal page requests. Each entry represents only one increment.  In this example, we want to do the same as before but no matter what user the\nvisit comes from.  use Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    - metricManager\n    - addEntry(\n        $storeTracker,\n        'homepage_controller',\n        '',\n        ElcodiMetricTypes::TYPE_BEACON_TOTAL,\n        new DateTime()\n    );  If you want the same behavior but in your twig layer  _etc.push([ 123456789 , 'homepage', '', '2']);", 
            "title": "Total beacon"
        }, 
        {
            "location": "/component/metrics/#mixed-unique-and-total-beacon", 
            "text": "Sometimes you want to add both, unique and total beacons. Well, instead of\ncreating two different beacons, you can create  only one representing both.\nBecause this means that the user must be identified somehow for the unique\nentry, remember to add the unique value as well.  use Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$user = ...;\n$storeTracker = ...;\n$this\n    - metricManager\n    - addEntry(\n        $storeTracker,\n        'homepage_controller',\n        $user- getId(),\n        ElcodiMetricTypes::TYPE_BEACON_ALL,\n        new DateTime()\n    );  And for the twig layer  _etc.push([ 123456789 , 'homepage', {{user.id}}, '3']);", 
            "title": "Mixed (Unique and Total) beacon"
        }, 
        {
            "location": "/component/metrics/#accumulated-beacon", 
            "text": "This type allow you to create an incremental accumulator, for example for\nrepresenting the total value of your total earnings. In that case, we need the\namount of the order as integer.  use Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$orderAmount = ...;\n$storeTracker = ...;\n$this\n    - metricManager\n    - addEntry(\n        $storeTracker,\n        'order_earnings',\n        $orderAmount,\n        ElcodiMetricTypes::TYPE_ACCUMULATED,\n        new DateTime()\n    );  This type of metric is special for the PHP layer, so all entries must define a\nvalue. Anyway, you can use it as well in your twig layer.  _etc.push([ 123456789 , 'metric', 10, '4']);", 
            "title": "Accumulated beacon"
        }, 
        {
            "location": "/component/metrics/#distributive-beacon", 
            "text": "Given an undetermined set of values, for examples, the referrer of the visit,\ncreate a metric  Given a set of supplementary values, for example operating systems (you cannot\nuse two of them at the same time), this type of beacon allow you to build\ndistributive metrics using a set of possible values. Each entry represents only\none increment.  In our example we will check if the user visiting a controller is logged or not.  use Elcodi\\Component\\Metric\\ElcodiMetricTypes;\n\n$isLogged = ...;\n$storeTracker = ...;\n$metricName = $isLogged\n    ? 'framework_is_logged'\n    : 'framework_is_not_logged';\n\n$this\n    - metricManager\n    - addEntry(\n        $storeTracker,\n        $metricName,\n        '0',\n        ElcodiMetricTypes::TYPE_DISTRIBUTIVE,\n        new DateTime()\n    );  Another example, and using it in the twig layer, is the representation if all\nreferrers of your site. You must use this type of metric because you cannot\ndefine a set of possible values (that should be a list of all websites in the\nworld... insane!)   This type of metric can be misunderstood. Only use it for non-closed set of\nelements. Otherwise, for example for knowing if your users are visiting your\nsite using a mobile platform or a desktop platform, use the first metric type.   So let's see the example of the referrers. We will use the twig method referrer_domain()  for such information. Visit Use Referrer Domain  cookbook for more\ninformation.  _etc.push([ 123456789 , 'referrer', {{ referrer_domain() }}, '8'])", 
            "title": "Distributive beacon"
        }, 
        {
            "location": "/component/metrics/#metrics-routes", 
            "text": "Once we know all different type of metrics, we should know as well how to\ninitialize all the environment. One of this things we must ensure that are\nactive is the route that we will use for our asynchronous calls.  elcodi_metric:\n    resource:  @ElcodiMetricBundle/Resources/config/routing.yml   As you can see, MetricBundle provides you the file with these routes. You only\nneed to include it in your router.  As soon as is included, you should see the route enabled in your project by\nusing the command  php app/console router:debug  # elcodi.route.metric_input\nRewriteCond %{REQUEST_URI} ^/api/_m/([^/]++)/([^/\\.]++)\\.png$\nRewriteCond %{REQUEST_METHOD} !^(GET|HEAD)$ [NC]\nRewriteRule .* - [S=1,E=_ROUTING_allow_GET:1,E=_ROUTING_allow_HEAD:1]\nRewriteCond %{REQUEST_URI} ^/api/_m/([^/]++)/([^/\\.]++)\\.png$  As you can see, this route starts with the prefix  /api . This is because in\nBamboo this route is considered an Api route, and is prefixed with  /api .", 
            "title": "Metrics routes"
        }, 
        {
            "location": "/component/metrics/#js-initialization", 
            "text": "You must initialize the JS layer as well. For this chapter, please be sure that\nyour assets are properly installed and dumped.  php app/console assets:install\nphp app/console assetic:dump  First of all you must initialize the JS metric library. Put this piece of code\nin your layout header. That simple!  script \n\n    /**\n     * Tracker generator for elcodi bamboo store\n     */\n    var _etc = _etc || [];\n\n    (function() {\n        var _etracker = document.createElement('script');\n        _etracker.type = 'text/javascript';\n        _etracker.async = true;\n        _etracker.src = '/bundles/elcodimetric/js/tracker.js';\n        var _etracker_s = document.getElementsByTagName('script')[0];\n        _etracker_s.parentNode.insertBefore(_etracker, _etracker_s);\n    }()); /script   In simple words, what this piece of code does is create a new block of JS code\nat the end of your code, adding all the metric library asynchronously. This\nmeans none blocking at all.  Take a look at the first line of the code.  var _etc = _etc || [];  With this line you will be able to work with metrics even if the library is not\ninitialized yet. Let's see how!", 
            "title": "JS initialization"
        }, 
        {
            "location": "/component/metrics/#adding-beacons", 
            "text": "Remember all beacons definitions? Well, if you have an idea about what your\nfirst metric could be, let's create it.  For this example, we will use the referrer metric again. Let's remember how we\ncan use it.  _etc.push([ 123456789 , 'referrer', {{ referrer_domain() }}, '8'])  The object  _etc  is an array while the metric JS library is not installed.\nArrays in JS have a public method called  push()  that basically what it does\nis pushing the element. That simple. This call does nothing, just pushing.  As long as the metrics library is installed, one of the processes this JS code\ndoes is, just at the beginning of its execution, take this array, save the\nobjects inside, and create a new object in the same variable, with the same name\nand the same public method:  push() .  After that, introduces again the previously saved objects and, unlike the simple\nJS array, this object does something else when this method is called: the AJAX\ncall to the metrics API.  And everything in a very very soft way and without any page slowness for your\nuser.", 
            "title": "Adding beacons"
        }, 
        {
            "location": "/component/metrics/#consulting-values", 
            "text": "Okay, now our website tracks some values for your analysis. But how can we read\nall this data from our backend? Well, the component itself uses a set of\nservices with a very simple way of doing that job.  namespace Elcodi\\Component\\Metric\\Core\\Bucket\\Abstracts;\n\n/**\n * Class AbstractMetricsBucket\n */\nabstract class AbstractMetricsBucket\n{\n    /**\n     * Get number of unique beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of hits\n     */\n    public function getBeaconsUnique($token, $event, array $dates);\n\n    /**\n     * Get the total of beacons given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Number of beacons, given an event and dates\n     */\n    public function getBeaconsTotal($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return integer Accumulation of event and given dates\n     */\n    public function getAccumulation($token, $event, array $dates);\n\n    /**\n     * Get distributions given an event and a set of dates\n     *\n     * [\n     *       value3 : 24,\n     *       value7 : 13,\n     *       value8 : 9,\n     * ]\n     *\n     * @param string $token Event\n     * @param string $event Token\n     * @param array  $dates Dates\n     *\n     * @return array Distribution with totals\n     */\n    public function getDistributions($token, $event, array $dates);\n}  You can inject this service by using the dependency injection name  services:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi.metrics_bucket  You can create new adapters as well. Please read the Metric Adapters Cookbook", 
            "title": "Consulting values"
        }, 
        {
            "location": "/component/metrics/#twig-extension", 
            "text": "You can read this information as well in your twig layer. In that case, you\nshould have stored in a twig local variable the array of Datetime instances. In\nthat case, let's figure that we have this array in a variable called  dates .  {{ metric_beacon_unique(123456789, 'unique_visits', dates) }}\n{{ metric_beacon_total(123456789, 'total_visits', dates) }}\n{{ metric_accumulation(123456789, 'order_total', dates) }}\n{{ metric_distributive(123456789, 'referrers', dates) }}  All methods are a simple call to service methods, without any kind of\ntransformation.", 
            "title": "Twig extension"
        }, 
        {
            "location": "/component/metrics/#metrics-intervals-resolver", 
            "text": "The last parameter of all these methods is an array of dates, and because can be\na heavy task creating intervals of dates, Bamboo provides as well a simple\nmechanism for building these structures easily.   This service is just a helper for Bamboo installation, providing some extra\nconfiguration and definition for custom charts. If you want to use it for your\nown project, please, check the specification of the classes involved.   There is a class called  MetricIntervalsResolver  with a simple method.   namespace Elcodi\\Admin\\MetricBundle\\Services;\n\n/**\n * Class MetricIntervalsResolver\n */\nclass MetricIntervalsResolver\n{\n    /**\n     * Given a type, create and configure the interval container\n     *\n     * @param integer $type Type of calculation\n     *\n     * @return IntervalContainer\n     */\n    public function getIntervalContainer($type);\n}  What this class does for you is create an instance of  IntervalContainer  built\nwith an array of DateTime instances, given given  $type . This type will tell\nthe method what kind of interval you want to build. These are all pre-built\ntypes.  namespace Elcodi\\Admin\\MetricBundle;\n\n/**\n * Class AdminPanelTypes\n */\nclass AdminPanelTypes\n{\n    /**\n     * @param integer\n     *\n     * Panel type today\n     */\n    const PANEL_TYPE_TODAY = 1;\n\n    /**\n     * @param integer\n     *\n     * Panel type yesterday\n     */\n    const PANEL_TYPE_YESTERDAY = 2;\n\n    /**\n     * @param integer\n     *\n     * Panel type last week\n     */\n    const PANEL_TYPE_LAST_WEEK = 3;\n\n    /**\n     * @param integer\n     *\n     * Panel type last month\n     */\n    const PANEL_TYPE_LAST_MONTH = 4;\n\n    /**\n     * @param integer\n     *\n     * Panel type last quarter\n     */\n    const PANEL_TYPE_LAST_QUARTER = 5;\n}  As said before, this method returns a  IntervalContainer  instance. This object\nreturns some data related to the chart itself.  The most important and used method of this object is  getElements() , used if\nthe value of  dates  is an instance of that. Then, the call of any metric read\nturns like that  {{ metric_beacon_unique(123456789, 'unique_visits', dates.getElements()) }}  You can inject this resolver as well using the dependency injection name.  services:\n    my_service:\n        class: My\\Service\\Class;\n        arguments:\n            - @elcodi_admin.metric_intervals_resolver  And finally, you can access to this method in your Twig layer as well  {% set todayIntervalContainer = metric_create_interval_container(1) %}\n{{ metric_beacon_unique(123456789, 'unique_visits', todayIntervalContainer.getElements()) }}", 
            "title": "Metrics Intervals Resolver"
        }, 
        {
            "location": "/component/sitemap/", 
            "text": "Sitemap\n #\n\n\nUse and configure the Sitemap component in your Symfony project.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nThe bundle is built in different layers, going from the real seed of any kind\nof sitemap implementation (each element), to the final profiling.\n\n\nWhat offers\n #\n\n\nThis package should work as a black box, so some configuration and some classes\nto implement the way some entities are searched or are transformed should be\nenough.\n\n\nThe package provides you as well a simple set of generated services and commands\nto make easier the generation of the documents. Read this documentation for more\ninformation about how you can generate simple and complex Sitemap documents.\n\n\n\n\nCan be useful as well for creating integration files with external \nmarketplaces, for example, Google Products.\n\n\n\n\nBlocks\n #\n\n\nOn a sitemap, a block is the element that we would like to index. If a product\nhas a page then we would like our sitemap to contain an entry url per product \npage. The items to index in a sitemap can be pages of products, categories, and \nany other entity on the project.\n\n\nWhen we talk about a block, we are really talking about a specific set of urls\nrelated to entities provided by a specific repository, for example all enabled \nproducts.\n\n\n# Each block defines a way of creating dynamically a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: ~\n        # Repository service used for retrieving the array of entities\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~\n\n\n\n\nEach block needs a transformer, intended to transform an entity instance to \nevery single information needed by the sitemap generator. Every transformer must\nbe an implementation of SitemapTransformerInterface and must be defined as a\nservice in our Dependency Injection Container.\n\n\n/**\n * Interface SitemapTransformerInterface\n */\ninterface SitemapTransformerInterface\n{\n    /**\n     * Get url given an entity\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string url\n     */\n    public function getLoc($element, $language = null);\n\n    /**\n     * Get last mod\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string Last mod value\n     */\n    public function getLastMod($element, $language = null);\n}\n\n\n\n\nThen we need to pass the name of the service to the block configuration.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: elcodi.sitemap_transformer.product\n\n\n\n\n\n\nThis element is a mandatory and must be defined for each Block\n\n\n\n\nThat said, we need to also define how this product collection must be\nretrieved from our database. For this reason you must specify the\nrepository service, the method used and the arguments for such method.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n            disabled: false\n\n\n\n\nThese elements are required and have no default values, to make sure\nthat every block definition is carefully defined and configured. \n\n\nFinally, we can define the \nchangeFrequency\n and the \npriority\n elements. Both\nvalues will be used for all block instances. They are not required.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~\n\n\n\n\nStatics\n #\n\n\nAn Static is a representation of a route, defined by its name and some \nnon-required values.\n\n\nelcodi_sitemap:\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~\n\n\n\n\nBuilders\n #\n\n\nA sitemap instance is built using a sorted set of Statics and Blocks and\nrendered by a specific renderer. The result of this built is dumped using a\nspecific dumper in a pre-defined path.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking into account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n\n\n\nFirst of all we need to define what blocks and statics we are going to use for\nsuch sitemap. It is important to know that the order matters.\n\n\nFor example, in our case, we will create a new sitemap called \nmain\n that will\ncontain a block and a static.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n\n\n\n\n\n\nThis component will first render the statics and then the blocks.\n\n\n\n\nThen, a renderer will transform this set of entries into a special format. By \ndefault this component gives you one renderer implementation, the \nXmlRenderer\n.\nThis implementation is the one used by default.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n\n\n\n\nIf you want to use your own renderer, you can create a new service implementing \n\nSitemapRendererInterface\n.\n\n\n/**\n * Interface SitemapRendererInterface\n */\ninterface SitemapRendererInterface\n{\n    /**\n     * Given an array of sitemapElements, renders the Sitemap\n     *\n     * @param SitemapElement[] $sitemapElements Elements\n     * @param string           $basepath        Base path\n     *\n     * @return string Render\n     */\n    public function render(array $sitemapElements, $basepath);\n}\n\n\n\n\nFinally, a dumper will dump your rendered data. By default this component gives\nyou one dumper implementation, the \nFilesystemDumper\n. This implementation is \nthe one used by default.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n\n\n\nIf you want to use your own dumper, you can create a new dumper implementing\n\nSitemapDumperInterface\n.\n\n\n/**\n * Interface SitemapDumperInterface\n */\ninterface SitemapDumperInterface\n{\n    /**\n     * Dumps a sitemap given a path\n     *\n     * @param string $path    Path\n     * @param string $sitemap Sitemap\n     *\n     * @return $this Self object\n     */\n    public function dump($path, $sitemap);\n}\n\n\n\n\nThis dumper uses a path. This path is required by any defined builder and can\ncontain a placeholder for the sitemap language, using \n{_locale}\n.\n\n\nServices\n #\n\n\nElcodi generates a Dependency Injection service for each builder using our\nstandard. In our example, with given configuration we will have available a new\npublic service.\n\n\nelcodi.sitemap_builder.main\n\n\n\n\nCalling this service, the DI will create a SitemapBuilder instance, ready\nto be used.\n\n\n/**\n * Class SitemapBuilder\n */\nclass SitemapBuilder\n{\n    /**\n     * Build sitemap builder\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     *\n     * @return string Generated data\n     */\n    public function build($basepath, $language = null);\n}\n\n\n\n\nElcodi also generates a service for each dumper, using the same notation as\nbuilders.\n\n\nelcodi.sitemap_dumper.main\n\n\n\n\nCalling this service, the DI will create a SitemapDumper instance, ready\nto be used.\n\n\n/**\n * Class SitemapDumper\n */\nclass SitemapDumper\n{\n    /**\n     * Dump builder using a dumper\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     */\n    public function dump($basepath, $language = null);\n}\n\n\n\n\nAs you can see, both services require the basepath of the site. It means that\nyou can call, for example, the \nbuild\n method using firstly the basepath \n\nhttp://localhost:8000\n and then \nhttps://myurl.com\n. Because this information\ndoes not belong to the instance but the call, it is mandatory to set this\ninformation when the sitemap is generated.\n\n\nYou must define the language as well, but this second parameter is not required.\nThis value is passed to the transformer, and your transformer implementation \nwill decide what to do with this language.\n\n\nDumper Command\n #\n\n\nThis command is intended for a single sitemap generation. You must provide the\nname of the builder as each builder has an associated dumper and a specific \nbasepath used for this built and an optional language.\n\n\nphp app/console elcodi:sitemap:dump main http://localhost:8000\nphp app/console elcodi:sitemap:dump main https://myurl.com\nphp app/console elcodi:sitemap:dump main http://localhost:8000 --language=es\n\n\n\n\nProfiles\n #\n\n\nUsing the dumper is so nice and easy if you just manage static languages, but\nhow about if our site needs to generate several builders using, for example, all \nthe enabled languages of our site?\n\n\nIn order to solve this common problem, this bundle provides as well what we call\na sitemap profile.\n\n\nelcodi_sitemap:\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main\n\n\n\n\nThere are two elements to be defined here, both required.\n\n\nFirst, we need to decide what builders we want to include in this profile.\nThis is just a set of builders, an array. That easy.\n\n\nSecond, we must define a service in our project, intended to return all enabled\nlanguages in our site. This service must return an array of locales.\n\n\nIn elcodi we have a service called \nelcodi.languages_iso\n.\n\n\nelcodi.languages_iso_array:\n    class: stdClass\n    factory: [@elcodi.languages_iso, toArray]\n\n\n\n\n\n\nYes, in Symfony a service can use the factory pattern to return a simple \narray using the stdClass keyword.\n\n\n\n\nElcodi generates a service for each profile, using our standard. In our example, \nwith the given configuration we will have available a new public service.\n\n\nelcodi.sitemap_profile.main\n\n\n\n\nCalling this service, the DI will create a SitemapProfile instance, ready\nto be used.\n\n\n/**\n * Class SitemapProfile\n */\nclass SitemapProfile\n{\n    /**\n     * Build full profile\n     *\n     * @param string $basepath Basepath\n     *\n     * @return $this Self object\n     */\n    public function dump($basepath);\n}\n\n\n\n\nProfile Command\n #\n\n\nThis command is intended for profile generation. You must provide the\nname of the profile and a specific basepath used for this build.\n\n\nphp app/console elcodi:sitemap:profile main http://localhost:8000\nphp app/console elcodi:sitemap:profile main https://myurl.com", 
            "title": "Sitemap"
        }, 
        {
            "location": "/component/sitemap/#sitemap", 
            "text": "Use and configure the Sitemap component in your Symfony project.   Component Repository  Bundle Repository   The bundle is built in different layers, going from the real seed of any kind\nof sitemap implementation (each element), to the final profiling.", 
            "title": "Sitemap"
        }, 
        {
            "location": "/component/sitemap/#what-offers", 
            "text": "This package should work as a black box, so some configuration and some classes\nto implement the way some entities are searched or are transformed should be\nenough.  The package provides you as well a simple set of generated services and commands\nto make easier the generation of the documents. Read this documentation for more\ninformation about how you can generate simple and complex Sitemap documents.   Can be useful as well for creating integration files with external \nmarketplaces, for example, Google Products.   Blocks  #  On a sitemap, a block is the element that we would like to index. If a product\nhas a page then we would like our sitemap to contain an entry url per product \npage. The items to index in a sitemap can be pages of products, categories, and \nany other entity on the project.  When we talk about a block, we are really talking about a specific set of urls\nrelated to entities provided by a specific repository, for example all enabled \nproducts.  # Each block defines a way of creating dynamically a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: ~\n        # Repository service used for retrieving the array of entities\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~  Each block needs a transformer, intended to transform an entity instance to \nevery single information needed by the sitemap generator. Every transformer must\nbe an implementation of SitemapTransformerInterface and must be defined as a\nservice in our Dependency Injection Container.  /**\n * Interface SitemapTransformerInterface\n */\ninterface SitemapTransformerInterface\n{\n    /**\n     * Get url given an entity\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string url\n     */\n    public function getLoc($element, $language = null);\n\n    /**\n     * Get last mod\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string Last mod value\n     */\n    public function getLastMod($element, $language = null);\n}  Then we need to pass the name of the service to the block configuration.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: elcodi.sitemap_transformer.product   This element is a mandatory and must be defined for each Block   That said, we need to also define how this product collection must be\nretrieved from our database. For this reason you must specify the\nrepository service, the method used and the arguments for such method.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n            disabled: false  These elements are required and have no default values, to make sure\nthat every block definition is carefully defined and configured.   Finally, we can define the  changeFrequency  and the  priority  elements. Both\nvalues will be used for all block instances. They are not required.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~  Statics  #  An Static is a representation of a route, defined by its name and some \nnon-required values.  elcodi_sitemap:\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~  Builders  #  A sitemap instance is built using a sorted set of Statics and Blocks and\nrendered by a specific renderer. The result of this built is dumped using a\nspecific dumper in a pre-defined path.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking into account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml  First of all we need to define what blocks and statics we are going to use for\nsuch sitemap. It is important to know that the order matters.  For example, in our case, we will create a new sitemap called  main  that will\ncontain a block and a static.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage   This component will first render the statics and then the blocks.   Then, a renderer will transform this set of entries into a special format. By \ndefault this component gives you one renderer implementation, the  XmlRenderer .\nThis implementation is the one used by default.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~  If you want to use your own renderer, you can create a new service implementing  SitemapRendererInterface .  /**\n * Interface SitemapRendererInterface\n */\ninterface SitemapRendererInterface\n{\n    /**\n     * Given an array of sitemapElements, renders the Sitemap\n     *\n     * @param SitemapElement[] $sitemapElements Elements\n     * @param string           $basepath        Base path\n     *\n     * @return string Render\n     */\n    public function render(array $sitemapElements, $basepath);\n}  Finally, a dumper will dump your rendered data. By default this component gives\nyou one dumper implementation, the  FilesystemDumper . This implementation is \nthe one used by default.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml  If you want to use your own dumper, you can create a new dumper implementing SitemapDumperInterface .  /**\n * Interface SitemapDumperInterface\n */\ninterface SitemapDumperInterface\n{\n    /**\n     * Dumps a sitemap given a path\n     *\n     * @param string $path    Path\n     * @param string $sitemap Sitemap\n     *\n     * @return $this Self object\n     */\n    public function dump($path, $sitemap);\n}  This dumper uses a path. This path is required by any defined builder and can\ncontain a placeholder for the sitemap language, using  {_locale} .  Services  #  Elcodi generates a Dependency Injection service for each builder using our\nstandard. In our example, with given configuration we will have available a new\npublic service.  elcodi.sitemap_builder.main  Calling this service, the DI will create a SitemapBuilder instance, ready\nto be used.  /**\n * Class SitemapBuilder\n */\nclass SitemapBuilder\n{\n    /**\n     * Build sitemap builder\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     *\n     * @return string Generated data\n     */\n    public function build($basepath, $language = null);\n}  Elcodi also generates a service for each dumper, using the same notation as\nbuilders.  elcodi.sitemap_dumper.main  Calling this service, the DI will create a SitemapDumper instance, ready\nto be used.  /**\n * Class SitemapDumper\n */\nclass SitemapDumper\n{\n    /**\n     * Dump builder using a dumper\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     */\n    public function dump($basepath, $language = null);\n}  As you can see, both services require the basepath of the site. It means that\nyou can call, for example, the  build  method using firstly the basepath  http://localhost:8000  and then  https://myurl.com . Because this information\ndoes not belong to the instance but the call, it is mandatory to set this\ninformation when the sitemap is generated.  You must define the language as well, but this second parameter is not required.\nThis value is passed to the transformer, and your transformer implementation \nwill decide what to do with this language.  Dumper Command  #  This command is intended for a single sitemap generation. You must provide the\nname of the builder as each builder has an associated dumper and a specific \nbasepath used for this built and an optional language.  php app/console elcodi:sitemap:dump main http://localhost:8000\nphp app/console elcodi:sitemap:dump main https://myurl.com\nphp app/console elcodi:sitemap:dump main http://localhost:8000 --language=es  Profiles  #  Using the dumper is so nice and easy if you just manage static languages, but\nhow about if our site needs to generate several builders using, for example, all \nthe enabled languages of our site?  In order to solve this common problem, this bundle provides as well what we call\na sitemap profile.  elcodi_sitemap:\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main  There are two elements to be defined here, both required.  First, we need to decide what builders we want to include in this profile.\nThis is just a set of builders, an array. That easy.  Second, we must define a service in our project, intended to return all enabled\nlanguages in our site. This service must return an array of locales.  In elcodi we have a service called  elcodi.languages_iso .  elcodi.languages_iso_array:\n    class: stdClass\n    factory: [@elcodi.languages_iso, toArray]   Yes, in Symfony a service can use the factory pattern to return a simple \narray using the stdClass keyword.   Elcodi generates a service for each profile, using our standard. In our example, \nwith the given configuration we will have available a new public service.  elcodi.sitemap_profile.main  Calling this service, the DI will create a SitemapProfile instance, ready\nto be used.  /**\n * Class SitemapProfile\n */\nclass SitemapProfile\n{\n    /**\n     * Build full profile\n     *\n     * @param string $basepath Basepath\n     *\n     * @return $this Self object\n     */\n    public function dump($basepath);\n}  Profile Command  #  This command is intended for profile generation. You must provide the\nname of the profile and a specific basepath used for this build.  php app/console elcodi:sitemap:profile main http://localhost:8000\nphp app/console elcodi:sitemap:profile main https://myurl.com", 
            "title": "What offers"
        }, 
        {
            "location": "/component/state-transition-machine/", 
            "text": "State Transition Machine\n #\n\n\nAdd states in your entities.\n\n\n\n\nComponent Repository\n\n\nBundle Repository\n\n\n\n\nCan your entity change its states? This component will help you to implement \nthis in a very decoupled way, providing you a very simple way for definition of\nthese states and a very easy way of managing them.\n\n\nWhat offers\n #\n\n\nOffers all the transition machine model classes, as well as all the service \nlayer for it management, or a complete set of events dispatched during all \ntransitions between states.\n\n\nUsage\n #\n\n\nThis component provides you a State Transition Machine for your entities. To\nunderstand what is a State Transition Machine, let's see an example about a use\ncase.\n\n\nLet's figure out we are working with a Order object. We want to give some states\nto this Order, like \"new\", \"paid\" and \"shipped\". Well, this is the perfect\nscenario for this component. The only thing you must define is the set of states\nand how you should jump from one to another.\n\n\nLet's see an example.\n\n\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n\n\n\nYou have four states here.\n\n new: First state or point of entry\n\n paid: The order is paid\n\n shipped: The order is shipped but is not received yet\n\n received: The order is received\n\n\nAnd we have three transitions between these states.\n\n pay: We pay an order\n\n ship: We ship an order\n* receive: A ship is being received\n\n\nMachine Builder\n #\n\n\nSo, this component provides a way to play with all this information in a very\nsingle way, providing as well one machine for each configuration, identified by\na string. Let's see an example of how to build a useful Machine for our project.\n\n\n?php\n\nuse Elcodi\\Component\\StateTransitionMachine\\Factory\\MachineFactor;\n\n$machineIdentifier = 'order_states';\n$pointOfEntry = 'new';\n$machineFactory = new MachineFactory;\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n$machineBuilder = new MachineBuilder(\n    $machineFactory,\n    $machineIdentifier,\n    $configuration,\n    $pointOfEntry\n);\n$machine = $machineBuilder-\ncompile();\n\n\n\n\nTo build a MachineCompiler we need this information:\n\n Machine Factory: The factory that the MachineBuilder will use to build a new\nMachine instance\n\n Machine identifier: The identifier of the machine. This value must be unique\n\n Configuration: The states definition. This parameter must be an array of\nedges, and each edge must be an array with this elements: \nfrom state\n,\n\ntransition name\n and \nto state\n.\n\n Point of Entry: The first state to add once the object is initialized\n\n\nMachine\n #\n\n\nOnce the MachineBuilder is compiled, this method returns us a MachineInterface\nimplementation, with the possibility of using 4 methods.\n\n\n    /**\n     * Get machine id\n     *\n     * @return string Machine identifier\n     */\n    public function getId();\n\n    /**\n     * Get point of entry\n     *\n     * @return string Point of entry\n     */\n    public function getPointOfEntry();\n\n    /**\n     * Applies a transition from a state\n     *\n     * @param string $startStateName Start state name\n     * @param string $transitionName Transition name\n     *\n     * @return Transition Transition created\n     *\n     * @throws TransitionNotAccessibleException Transition not accessible\n     * @throws TransitionNotValidException      Invalid transition name\n     */\n    public function transition(\n        $startStateName,\n        $transitionName\n    );\n\n    /**\n     * Reaches a state given a start state\n     *\n     * @param string $startStateName Start state name\n     * @param string $finalStateName Final state name\n     *\n     * @return Transition Transition created\n     *\n     * @throws StateNotReachableException State is not reachable\n     */\n    public function reachState(\n        $startStateName,\n        $finalStateName\n    );\n\n\n\n\nGiven the last example with the last configuration, lets try to do apply the\n\npay\n transition from the \nnew\n state using the \ntransition\n method.\n\n\necho $machine-\ngetId();\n// = order_states\n\necho $machine-\ngetPointOfEntry();\n// = new\n\n$transition = $machine-\ntransition('unpaid', 'pay');\necho get_class($transition);\n// = \\Elcodi\\Component\\StateTransitionMachine\\Definition\\Transition\n\necho $transition-\ngetName();\n// = pay\n\necho $transition-\ngetStart()-\ngetName();\n// = new\n\necho $transition-\ngetFinal()-\ngetName();\n// = paid\n\n\n\n\nWe can use the \nreachState\n method as well, to reach an specific state no matter\nthe name of the transition. The result should be the same as the last example.\n\n\n$transition = $machine-\nreachState('new', 'paid');\n\n\n\n\nBecause using a machine is a transactional action, all errors will be notified\nwith Exceptions. In that case, because we can not \nship\n an \nnew\n order, we\nwould receive a \nTransitionNotAccessibleException\n exception.\n\n\n$transition = $machine-\ntransition('new', 'ship');\n\n\n\n\nMachine Manager\n #\n\n\nTo make things easier and to provide a nice interface for the final user, a\n\nMachineManager\n object is created. This object provide as well a nice interface\nto dispatch events using the Symfony Event Dispatcher Component.\n\n\nLet's see how it works using the previous Machine object. To make it happen, we\nmust work with implementations of the interface\n\n\\Elcodi\\Component\\StateTransitionMachine\\Entity\\Interfaces\\StatefulInterface\n,\nso our \nOrder\n instance is one of these.\n\n\nEvery entity implementing this interface, in order to be able to work with an\nspecific machine, must be initialized once to make sure that the first state is\nalready injected. Once this object is initialized, this action is not required\nanymore.\n\n\n$stateLineFactory = new StateLineFactory();\n$eventDispatcher = new EventDispatcher();\n$machineManager = new MachineManager(\n    $machine,\n    $eventDispatcher,\n    $stateLineFactory,\n);\n\n$order = new Order();\n$machineManager-\ninitialize($order, 'First state');\n$transition = $machineManager-\nreachState($order, 'paid', 'The order have been\npaid');\n\n\n\n\nBecause the point of entry state is \nnew\n and we can reach the State \npaid\n,\nthis transition will be valid.\nIn this action, several events will be dispatched from the $eventDispatched\ninstance.", 
            "title": "State transition machine"
        }, 
        {
            "location": "/component/state-transition-machine/#state-transition-machine", 
            "text": "Add states in your entities.   Component Repository  Bundle Repository   Can your entity change its states? This component will help you to implement \nthis in a very decoupled way, providing you a very simple way for definition of\nthese states and a very easy way of managing them.", 
            "title": "State Transition Machine"
        }, 
        {
            "location": "/component/state-transition-machine/#what-offers", 
            "text": "Offers all the transition machine model classes, as well as all the service \nlayer for it management, or a complete set of events dispatched during all \ntransitions between states.", 
            "title": "What offers"
        }, 
        {
            "location": "/component/state-transition-machine/#usage", 
            "text": "This component provides you a State Transition Machine for your entities. To\nunderstand what is a State Transition Machine, let's see an example about a use\ncase.  Let's figure out we are working with a Order object. We want to give some states\nto this Order, like \"new\", \"paid\" and \"shipped\". Well, this is the perfect\nscenario for this component. The only thing you must define is the set of states\nand how you should jump from one to another.  Let's see an example.  $configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];  You have four states here.  new: First state or point of entry  paid: The order is paid  shipped: The order is shipped but is not received yet  received: The order is received  And we have three transitions between these states.  pay: We pay an order  ship: We ship an order\n* receive: A ship is being received", 
            "title": "Usage"
        }, 
        {
            "location": "/component/state-transition-machine/#machine-builder", 
            "text": "So, this component provides a way to play with all this information in a very\nsingle way, providing as well one machine for each configuration, identified by\na string. Let's see an example of how to build a useful Machine for our project.  ?php\n\nuse Elcodi\\Component\\StateTransitionMachine\\Factory\\MachineFactor;\n\n$machineIdentifier = 'order_states';\n$pointOfEntry = 'new';\n$machineFactory = new MachineFactory;\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n$machineBuilder = new MachineBuilder(\n    $machineFactory,\n    $machineIdentifier,\n    $configuration,\n    $pointOfEntry\n);\n$machine = $machineBuilder- compile();  To build a MachineCompiler we need this information:  Machine Factory: The factory that the MachineBuilder will use to build a new\nMachine instance  Machine identifier: The identifier of the machine. This value must be unique  Configuration: The states definition. This parameter must be an array of\nedges, and each edge must be an array with this elements:  from state , transition name  and  to state .  Point of Entry: The first state to add once the object is initialized", 
            "title": "Machine Builder"
        }, 
        {
            "location": "/component/state-transition-machine/#machine", 
            "text": "Once the MachineBuilder is compiled, this method returns us a MachineInterface\nimplementation, with the possibility of using 4 methods.      /**\n     * Get machine id\n     *\n     * @return string Machine identifier\n     */\n    public function getId();\n\n    /**\n     * Get point of entry\n     *\n     * @return string Point of entry\n     */\n    public function getPointOfEntry();\n\n    /**\n     * Applies a transition from a state\n     *\n     * @param string $startStateName Start state name\n     * @param string $transitionName Transition name\n     *\n     * @return Transition Transition created\n     *\n     * @throws TransitionNotAccessibleException Transition not accessible\n     * @throws TransitionNotValidException      Invalid transition name\n     */\n    public function transition(\n        $startStateName,\n        $transitionName\n    );\n\n    /**\n     * Reaches a state given a start state\n     *\n     * @param string $startStateName Start state name\n     * @param string $finalStateName Final state name\n     *\n     * @return Transition Transition created\n     *\n     * @throws StateNotReachableException State is not reachable\n     */\n    public function reachState(\n        $startStateName,\n        $finalStateName\n    );  Given the last example with the last configuration, lets try to do apply the pay  transition from the  new  state using the  transition  method.  echo $machine- getId();\n// = order_states\n\necho $machine- getPointOfEntry();\n// = new\n\n$transition = $machine- transition('unpaid', 'pay');\necho get_class($transition);\n// = \\Elcodi\\Component\\StateTransitionMachine\\Definition\\Transition\n\necho $transition- getName();\n// = pay\n\necho $transition- getStart()- getName();\n// = new\n\necho $transition- getFinal()- getName();\n// = paid  We can use the  reachState  method as well, to reach an specific state no matter\nthe name of the transition. The result should be the same as the last example.  $transition = $machine- reachState('new', 'paid');  Because using a machine is a transactional action, all errors will be notified\nwith Exceptions. In that case, because we can not  ship  an  new  order, we\nwould receive a  TransitionNotAccessibleException  exception.  $transition = $machine- transition('new', 'ship');", 
            "title": "Machine"
        }, 
        {
            "location": "/component/state-transition-machine/#machine-manager", 
            "text": "To make things easier and to provide a nice interface for the final user, a MachineManager  object is created. This object provide as well a nice interface\nto dispatch events using the Symfony Event Dispatcher Component.  Let's see how it works using the previous Machine object. To make it happen, we\nmust work with implementations of the interface \\Elcodi\\Component\\StateTransitionMachine\\Entity\\Interfaces\\StatefulInterface ,\nso our  Order  instance is one of these.  Every entity implementing this interface, in order to be able to work with an\nspecific machine, must be initialized once to make sure that the first state is\nalready injected. Once this object is initialized, this action is not required\nanymore.  $stateLineFactory = new StateLineFactory();\n$eventDispatcher = new EventDispatcher();\n$machineManager = new MachineManager(\n    $machine,\n    $eventDispatcher,\n    $stateLineFactory,\n);\n\n$order = new Order();\n$machineManager- initialize($order, 'First state');\n$transition = $machineManager- reachState($order, 'paid', 'The order have been\npaid');  Because the point of entry state is  new  and we can reach the State  paid ,\nthis transition will be valid.\nIn this action, several events will be dispatched from the $eventDispatched\ninstance.", 
            "title": "Machine Manager"
        }, 
        {
            "location": "/component/template/", 
            "text": "Template\n #\n\n\nCreate, install and manage several templates in your Bamboo installation.\n\n\n\n\nComponent Repository\n\n\nBundle Repository", 
            "title": "Template"
        }, 
        {
            "location": "/component/template/#template", 
            "text": "Create, install and manage several templates in your Bamboo installation.   Component Repository  Bundle Repository", 
            "title": "Template"
        }
    ]
}